<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>chimez's blog (Posts about library)</title><link>https://chimez.github.io/</link><description></description><atom:link href="https://chimez.github.io/categories/cat_library.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:chimez@163.com"&gt;chimez&lt;/a&gt; </copyright><lastBuildDate>Sun, 04 Jul 2021 04:43:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>SLEPc</title><link>https://chimez.github.io/posts/slepc/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-orga815a4b" class="outline-2"&gt;
&lt;h2 id="orga815a4b"&gt;SLEPc: PETSc 的本征值求解器扩展&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga815a4b"&gt;
&lt;p&gt;
&lt;a href="https://slepc.upv.es/"&gt;SLEPc&lt;/a&gt; 是用来求 PETSc 矩阵的扩展库。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org91dcfbc" class="outline-3"&gt;
&lt;h3 id="org91dcfbc"&gt;基本结构&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org91dcfbc"&gt;
&lt;p&gt;
SLEPc 有以下基本部分构成
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;EPS (Eigenvalue Problem Solver)&lt;/li&gt;
&lt;li&gt;SVD (Singular Value Decomposition)&lt;/li&gt;
&lt;li&gt;PEP (Polynomial Eigenvalue Problem)&lt;/li&gt;
&lt;li&gt;NEP (Nonlinear Eigenvalue Problem)&lt;/li&gt;
&lt;li&gt;MFN (Matrix Function)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
还有一些辅助模块
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;ST (Spectral Transformation)&lt;/li&gt;
&lt;li&gt;BV (Basis Vectors)&lt;/li&gt;
&lt;li&gt;DS (Dense System)&lt;/li&gt;
&lt;li&gt;RG (Region)&lt;/li&gt;
&lt;li&gt;FN (Mathematical Function)&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgca8fb29" class="outline-3"&gt;
&lt;h3 id="orgca8fb29"&gt;安装&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgca8fb29"&gt;
&lt;p&gt;
下载时注意，SLEPc 的版本必须和 PETSc 版本一样
&lt;/p&gt;

&lt;p&gt;
编译选项
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   ./configure --download-arpack --download-blopex --download-hpddm --download-primme
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
最后别忘了把环境变量 &lt;code&gt;SLEPC_DIR&lt;/code&gt; 加上
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge520544" class="outline-3"&gt;
&lt;h3 id="orge520544"&gt;基本使用&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge520544"&gt;
&lt;p&gt;
程序开始和结束时分别调用 &lt;code&gt;SlepcInitialize()&lt;/code&gt; 和 &lt;code&gt;SlepcFinalize()&lt;/code&gt;, 实际上就是 &lt;code&gt;PetscInitialize()&lt;/code&gt; 和 &lt;code&gt;PetscFinalize()&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
矩阵的使用跟 &lt;code&gt;PETSc&lt;/code&gt; 完全一致
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0341242" class="outline-3"&gt;
&lt;h3 id="org0341242"&gt;EPS: 矩阵本征值求解器&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0341242"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfe5f94b" class="outline-4"&gt;
&lt;h4 id="orgfe5f94b"&gt;基本使用&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgfe5f94b"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;EPSCreate(MPI_Comm comm,EPS *eps);&lt;/code&gt; 
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建求解器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetOperators(EPS eps,Mat A,Mat B);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置要解的算符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetFromOptions(EPS eps);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;添加运行时设置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSolve(EPS eps);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;运行求解器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSDestroy(EPS *eps);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;销毁求解器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetUp(EPS eps);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;某些更具体的设置, 如果有需要的话，要在运行求解器之前设置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSGetST(EPS eps,ST *st);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获得谱变换器(ST), EPS 会默认自动创建一个 ST 对象，如果需要设置谱变换，就要这样获得它&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSView(EPS eps,PetscViewer viewer);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;打印求解器配置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;slepceps.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


    &lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* problem matrix */&lt;/span&gt;
    &lt;span class="cm"&gt;/* do something to fill A */&lt;/span&gt;

    &lt;span class="n"&gt;PetscErrorCode&lt;/span&gt; &lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="cm"&gt;/* Create eigensolver context */&lt;/span&gt;
    &lt;span class="n"&gt;EPS&lt;/span&gt; &lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* eigenproblem solver context */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Set operators. In this case, it is a standard eigenvalue problem */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSSetOperators&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSSetProblemType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EPS_HEP&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* show EPS setup */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PETSC_VIEWER_STDOUT_WORLD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Set solver parameters at runtime */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSSetFromOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Solve the eigensystem */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSSolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Optional: Get some information from the solver and display it */&lt;/span&gt;
    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetIterationNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;its&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" Number of iterations of the method: %D&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;EPSType&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" Solution method: %s&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;nev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetDimensions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;nev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" Number of requested eigenvalues: %D&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nev&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;PetscReal&lt;/span&gt; &lt;span class="n"&gt;tol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;maxit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetTolerances&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;maxit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" Stopping condition: tol=%.4g, maxit=%D&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;tol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Display solution and clean up */&lt;/span&gt;
    &lt;span class="cm"&gt;/* Get number of converged approximate eigenpairs */&lt;/span&gt;
    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;nconv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetConverged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;nconv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" Number of converged eigenpairs: %D&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nconv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nconv&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Display eigenvalues and relative errors */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
			&lt;span class="s"&gt;"           k          ||Ax-kx||/||kx||&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
			&lt;span class="s"&gt;"   ----------------- ------------------&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;nconv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="cm"&gt;/* Get converged eigenpairs: i-th eigenvalue is stored in kr (real part) and ki (imaginary part) */&lt;/span&gt;
	&lt;span class="n"&gt;PetscScalar&lt;/span&gt; &lt;span class="n"&gt;kr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ki&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;Vec&lt;/span&gt; &lt;span class="n"&gt;xr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatCreateVecs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatCreateVecs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSGetEigenpair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ki&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;xi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="cm"&gt;/* Compute the relative error associated to each eigenpair */&lt;/span&gt;
	&lt;span class="n"&gt;PetscReal&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSComputeError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EPS_ERROR_RELATIVE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="n"&gt;PetscReal&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscRealPart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;PetscReal&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscImaginaryPart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" %9f%+9fi %12g&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"   %12f       %12g&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscPrintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="cm"&gt;/* Free work space */&lt;/span&gt;

    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;eps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org75526a9" class="outline-4"&gt;
&lt;h4 id="org75526a9"&gt;求解器配置&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org75526a9"&gt;
&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="orgd080ad1"&gt;&lt;/a&gt;问题类型&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgd080ad1"&gt;
&lt;p&gt;
问题类型使用 &lt;code&gt;EPSSetProblemType(EPS eps,EPSProblemType type);&lt;/code&gt; 进行设置
&lt;/p&gt;

&lt;p&gt;
可选的有
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;问题类型&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;EPSProblemTyle&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;命令行选项&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Hermitian&lt;/td&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;HEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;hermitian&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Non-Hermitian&lt;/td&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;NHEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;non&lt;/sub&gt;&lt;sub&gt;hermitian&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Generalized Hermitian&lt;/td&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;GHEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;gen&lt;/sub&gt;&lt;sub&gt;hermitian&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Generalized Hermitian indefinite&lt;/td&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;GHIEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;gen&lt;/sub&gt;&lt;sub&gt;indefinite&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Generalized Non-Hermitian&lt;/td&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;GNHEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;gen&lt;/sub&gt;&lt;sub&gt;non&lt;/sub&gt;&lt;sub&gt;hermitian&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;GNHEP with positive (semi-)definite&lt;/td&gt;
&lt;td class="org-left"&gt;BEPS&lt;sub&gt;PGNHEP&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;pos&lt;/sub&gt;&lt;sub&gt;gen&lt;/sub&gt;&lt;sub&gt;non&lt;/sub&gt;&lt;sub&gt;hermitian&lt;/sub&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
还可以用一系列函数来判断设置的问题类型
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;EPSIsGeneralized(EPS eps,PetscBool *gen);&lt;/li&gt;
&lt;li&gt;EPSIsHermitian(EPS eps,PetscBool *her);&lt;/li&gt;
&lt;li&gt;EPSIsPositive(EPS eps,PetscBool *pos);&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org13d0e0e"&gt;&lt;/a&gt;求解本征值个数&lt;br&gt;
&lt;div class="outline-text-5" id="text-org13d0e0e"&gt;
&lt;p&gt;
使用 &lt;code&gt;EPSSetDimensions(EPS eps,PetscInt nev,PetscInt ncv,PetscInt mpd);&lt;/code&gt; 设置要求的本征值个数
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;PetscInt nev&lt;/code&gt; 本征值个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PetscInt ncv&lt;/code&gt; 最大工作空间的维数，指的是用多少个中间向量, &lt;code&gt;ncv&lt;/code&gt; 至少和 &lt;code&gt;nev&lt;/code&gt; 一样多，最好是它的两倍以上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PetscInt mpd&lt;/code&gt; 最大投影空间维数，用来计算很多本征值个数的时候，设置它可以减少工作空间的需求&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org5ffc797"&gt;&lt;/a&gt;求解本征值位置&lt;br&gt;
&lt;div class="outline-text-5" id="text-org5ffc797"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;EPSSetWhichEigenpairs(EPS eps,EPSWhich which);&lt;/code&gt; 设置要求本征值的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetTarget(EPS eps,PetscScalar target);&lt;/code&gt; 设置计算距离某个值最近的本征值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetInterval(EPS eps,PetscScalar a,PetscScalar b);&lt;/code&gt; 计算 \(\lambda \in [a, b]\) 的所有本征值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetTwoSided(EPS eps,PetscBool twosided);&lt;/code&gt; 计算非厄米问题的左本征矢&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
可选的本征值位置有
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;EPSWhich&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;命令行&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;LARGEST&lt;/sub&gt;&lt;sub&gt;MAGNITUDE&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;largest&lt;/sub&gt;&lt;sub&gt;magnitude&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最大 \(\vert \lambda\vert\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;SMALLEST&lt;/sub&gt;&lt;sub&gt;MAGNITUDE&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;smallest&lt;/sub&gt;&lt;sub&gt;magnitude&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\vert\lambda\vert\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;LARGEST&lt;/sub&gt;&lt;sub&gt;REAL&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;largest&lt;/sub&gt;&lt;sub&gt;real&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最大 \(\mathrm{Re}(\lambda)\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;SMALLEST&lt;/sub&gt;&lt;sub&gt;REAL&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;smallest&lt;/sub&gt;&lt;sub&gt;real&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\mathrm{Re}(\lambda)\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;LARGEST&lt;/sub&gt;&lt;sub&gt;IMAGINARY&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;largest&lt;/sub&gt;&lt;sub&gt;imaginary&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最大 \(\mathrm{Im}(\lambda)\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;SMALLEST&lt;/sub&gt;&lt;sub&gt;IMAGINARY&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;smallest&lt;/sub&gt;&lt;sub&gt;imaginary&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\mathrm{Im}(\lambda)\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;TARGET&lt;/sub&gt;&lt;sub&gt;MAGNITUDE&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;magnitude&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\vert\lambda - \tau\vert\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;TARGET&lt;/sub&gt;&lt;sub&gt;REAL&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;real&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\vert\mathrm{Re}(\lambda-\tau)\vert\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;TARGET&lt;/sub&gt;&lt;sub&gt;IMAGINARY&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;target&lt;/sub&gt;&lt;sub&gt;imaginary&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;最小 \(\vert\mathrm{Im}(\lambda-\tau)\vert\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;ALL&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;-eps&lt;sub&gt;all&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;所有 \(\lambda \in [a,b]\)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;EPS&lt;sub&gt;WHICH&lt;/sub&gt;&lt;sub&gt;USER&lt;/sub&gt;&lt;/td&gt;
&lt;td class="org-left"&gt; &lt;/td&gt;
&lt;td class="org-left"&gt;用户定义&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org8fc18cf"&gt;&lt;/a&gt;选择算法&lt;br&gt;
&lt;div class="outline-text-5" id="text-org8fc18cf"&gt;
&lt;p&gt;
通过 &lt;code&gt;EPSSetType(EPS eps,EPSType method);&lt;/code&gt; 设置求解器使用的算法
&lt;/p&gt;


&lt;p&gt;
SLEPc 支持的算法有
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;基本算法
&lt;ul class="org-ul"&gt;
&lt;li&gt;Power Itration, Rayleigh Quotient iteration(RQI)&lt;/li&gt;
&lt;li&gt;Subspace Iteration with Rayleigh-Ritz projection and locking&lt;/li&gt;
&lt;li&gt;Arnoldi method with explicit restart and deflation&lt;/li&gt;
&lt;li&gt;Lanczos with explicit restart&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Krylov-Schur, thick-restart Lanczos method (默认)&lt;/li&gt;
&lt;li&gt;Generalized Davidson&lt;/li&gt;
&lt;li&gt;Jacobi-Davidson&lt;/li&gt;
&lt;li&gt;RQCG&lt;/li&gt;
&lt;li&gt;LOBPCG&lt;/li&gt;
&lt;li&gt;CISS&lt;/li&gt;
&lt;li&gt;Lyapunov inverse iteration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
由于实现支持有限，只有 &lt;code&gt;arnoldi&lt;/code&gt;, &lt;code&gt;krylov-schur&lt;/code&gt;, &lt;code&gt;gd&lt;/code&gt;, &lt;code&gt;jd&lt;/code&gt;, &lt;code&gt;arpack&lt;/code&gt; 支持所有类型的问题求解
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;方法&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;EPSType&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;选项名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Power / Inverse / RQI&lt;/td&gt;
&lt;td class="org-left"&gt;EPSPOWER&lt;/td&gt;
&lt;td class="org-left"&gt;power&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Subspace Iteration&lt;/td&gt;
&lt;td class="org-left"&gt;EPSSUBSPACE&lt;/td&gt;
&lt;td class="org-left"&gt;subspace&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Arnoldi&lt;/td&gt;
&lt;td class="org-left"&gt;EPSARNOLDI&lt;/td&gt;
&lt;td class="org-left"&gt;arnoldi&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Lanczos&lt;/td&gt;
&lt;td class="org-left"&gt;EPSLANCZOS&lt;/td&gt;
&lt;td class="org-left"&gt;lanczos&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Krylov-Schur&lt;/td&gt;
&lt;td class="org-left"&gt;EPSKRYLOVSCHUR&lt;/td&gt;
&lt;td class="org-left"&gt;krylovschur&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Generalized Davidson&lt;/td&gt;
&lt;td class="org-left"&gt;EPSGD&lt;/td&gt;
&lt;td class="org-left"&gt;gd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Jacobi-Davidson&lt;/td&gt;
&lt;td class="org-left"&gt;EPSJD&lt;/td&gt;
&lt;td class="org-left"&gt;jd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Rayleigh quotient CG&lt;/td&gt;
&lt;td class="org-left"&gt;EPSRQCG&lt;/td&gt;
&lt;td class="org-left"&gt;rqcg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;LOBPCG&lt;/td&gt;
&lt;td class="org-left"&gt;EPSLOBPCG&lt;/td&gt;
&lt;td class="org-left"&gt;lobpcg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Contour integral SS&lt;/td&gt;
&lt;td class="org-left"&gt;EPSCISS&lt;/td&gt;
&lt;td class="org-left"&gt;ciss&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Lyapunov Inverse Iteration&lt;/td&gt;
&lt;td class="org-left"&gt;EPSLYAPII&lt;/td&gt;
&lt;td class="org-left"&gt;lyapii&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;LAPACK solver&lt;/td&gt;
&lt;td class="org-left"&gt;EPSLAPACK&lt;/td&gt;
&lt;td class="org-left"&gt;lapack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to arpack&lt;/td&gt;
&lt;td class="org-left"&gt;EPSARPACK&lt;/td&gt;
&lt;td class="org-left"&gt;arpack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to primme&lt;/td&gt;
&lt;td class="org-left"&gt;EPSPRIMME&lt;/td&gt;
&lt;td class="org-left"&gt;primme&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to evsl&lt;/td&gt;
&lt;td class="org-left"&gt;EPSEVSL&lt;/td&gt;
&lt;td class="org-left"&gt;evsl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to trlan&lt;/td&gt;
&lt;td class="org-left"&gt;EPSTRLAN&lt;/td&gt;
&lt;td class="org-left"&gt;trlan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to blopex&lt;/td&gt;
&lt;td class="org-left"&gt;EPSBLOPEX&lt;/td&gt;
&lt;td class="org-left"&gt;blopex&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to scalapack&lt;/td&gt;
&lt;td class="org-left"&gt;EPSSCALAPACK&lt;/td&gt;
&lt;td class="org-left"&gt;scalapack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to elpa&lt;/td&gt;
&lt;td class="org-left"&gt;EPSELPA&lt;/td&gt;
&lt;td class="org-left"&gt;elpa&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to elemental&lt;/td&gt;
&lt;td class="org-left"&gt;EPSELEMENTAL&lt;/td&gt;
&lt;td class="org-left"&gt;elemental&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Wrapper to feast&lt;/td&gt;
&lt;td class="org-left"&gt;EPSFEAST&lt;/td&gt;
&lt;td class="org-left"&gt;feast&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgcf0bd30"&gt;&lt;/a&gt;获得结果&lt;br&gt;
&lt;div class="outline-text-5" id="text-orgcf0bd30"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;EPSGetConverged(EPS eps,PetscInt *nconv);&lt;/code&gt; 获得收敛的解个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSGetEigenpair(EPS eps,PetscInt j,PetscScalar *kr,PetscScalar *ki,Vec xr,Vec xi);&lt;/code&gt; 获得本征值和本征矢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSGetLeftEigenvector(EPS eps,PetscInt j,Vec yr,Vec yi);&lt;/code&gt; 获得左本征矢，如果设置求解器计算左本征矢的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSComputeError(EPS eps,PetscInt j,EPSErrorType type,PetscReal *error);&lt;/code&gt; 获得结果的误差
&lt;ol class="org-ol"&gt;
&lt;li&gt;可选的误差类型有 \(||r||\) &lt;code&gt;EPS_ERROR_ABSOLUTE&lt;/code&gt;, \(||r||/|\lambda|\) &lt;code&gt;EPS_ERROR_RELATIVE&lt;/code&gt;, \(||r||/(||A||+|\lambda| ||B||)\) &lt;code&gt;EPS_ERROR_BACKWARD&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSGetIterationNumber(EPS eps,PetscInt *its);&lt;/code&gt; 获得迭代次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetTolerances(EPS eps,PetscReal tol,PetscInt max_it);&lt;/code&gt; 设置误差和最大迭代次数
&lt;ol class="org-ol"&gt;
&lt;li&gt;默认误差 \(10^{-8}\)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetTrueResidual(EPS eps,PetscBool trueres);&lt;/code&gt; 设置使用真实残差计算收敛条件，而不是默认的简化形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSSetConvergenceTest(EPS eps,EPSConv conv);&lt;/code&gt; 设置收敛条件
&lt;ol class="org-ol"&gt;
&lt;li&gt;可选的误差类型有 \(||r||\) &lt;code&gt;EPS_CONV_ABS&lt;/code&gt;, \(||r||/|\lambda|\) &lt;code&gt;EPS_CONV_REL&lt;/code&gt;, \(||r||/(||A||+|\lambda| ||B||)\) &lt;code&gt;EPS_CONV_NORM&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EPSGetErrorEstimate(EPS eps,PetscInt j,PetscReal *errest);&lt;/code&gt; 获得误差估计&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;如果编译时使用实数模式，那么 &lt;code&gt;kr, ki&lt;/code&gt; 等分别是实部和虚部&lt;/li&gt;
&lt;li&gt;如果编译时使用复数模式，那么 &lt;code&gt;kr, xr&lt;/code&gt; 中就保存复数结果， &lt;code&gt;ki,xi&lt;/code&gt; 不使用（设为全零）&lt;/li&gt;
&lt;li&gt;如果设置命令行选项 &lt;code&gt;-eps_monitor&lt;/code&gt; 那么会在每次迭代过程中打印计算过程&lt;/li&gt;
&lt;li&gt;其它命令行选项甚至可以画图 （ &lt;code&gt;-eps_monitor draw:draw_lg -draw_pause .2&lt;/code&gt; ）&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org3e4f3ab"&gt;&lt;/a&gt;其它设置&lt;br&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a id="org15ffade"&gt;&lt;/a&gt;初始猜解&lt;br&gt;
&lt;div class="outline-text-6" id="text-org15ffade"&gt;
&lt;p&gt;
&lt;code&gt;EPSSetInitialSpace(EPS eps,PetscInt n,Vec is[]);&lt;/code&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orge7ecad2"&gt;&lt;/a&gt;处理简并&lt;br&gt;&lt;/li&gt;

&lt;li&gt;&lt;a id="org2f274fe"&gt;&lt;/a&gt;选择正交化方法&lt;br&gt;&lt;/li&gt;

&lt;li&gt;&lt;a id="org24b54ab"&gt;&lt;/a&gt;选择滤波算法&lt;br&gt;&lt;/li&gt;

&lt;li&gt;&lt;a id="org143fdff"&gt;&lt;/a&gt;计算大量本征值的方法&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>C</category><category>eigenvalue</category><category>mpi</category><category>parallel</category><category>petsc</category><guid>https://chimez.github.io/posts/slepc/</guid><pubDate>Sat, 03 Jul 2021 05:08:47 GMT</pubDate></item><item><title>pthread</title><link>https://chimez.github.io/posts/pthread/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org78e1009" class="outline-2"&gt;
&lt;h2 id="org78e1009"&gt;pthread: POSIX Threads&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org78e1009"&gt;
&lt;p&gt;
pthread 是 POSIX 标准的线程 API, 放在头文件 &lt;code&gt;&amp;lt;pthread.h&amp;gt;&lt;/code&gt; 中，并由 libc 提供实现。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdaf6f76" class="outline-4"&gt;
&lt;h4 id="orgdaf6f76"&gt;参考&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgdaf6f76"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a href="https://hpc-tutorials.llnl.gov/posix/"&gt;llnl 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdcdac83" class="outline-3"&gt;
&lt;h3 id="orgdcdac83"&gt;pthread API&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdcdac83"&gt;
&lt;p&gt;
标准 pthread API 包括以下几部分
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;线程管理：创建、检测、合并等&lt;/li&gt;
&lt;li&gt;互斥锁(mutex)：创建、销毁、加锁、解锁等&lt;/li&gt;
&lt;li&gt;条件变量：在线程间共享锁、创建、销毁、等待和信号&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
同步：管理读写锁和屏障
&lt;/p&gt;

&lt;p&gt;
API 命名结构如下：
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Routine Prefix&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Functional Group&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Threads themselves and miscellaneous subroutines&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_attr_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Thread attributes objects&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_mutex_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Mutexes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_mutexattr_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Mutex attributes objects.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_cond_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Condition variables&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_condattr_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Condition attributes objects&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_key_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Thread-specific data keys&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_rwlock_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Read/write locks&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;&lt;code&gt;pthread_barrier_&lt;/code&gt;&lt;/td&gt;
&lt;td class="org-left"&gt;Synchronization barriers&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4c3c753" class="outline-3"&gt;
&lt;h3 id="org4c3c753"&gt;线程管理&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4c3c753"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeef1519" class="outline-4"&gt;
&lt;h4 id="orgeef1519"&gt;创建和终止线程&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgeef1519"&gt;
&lt;p&gt;
包括以下函数
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_create(thread,attr,start_routine,arg)&lt;/code&gt; 创建线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit(status)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cancel(thread)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_init(attr)&lt;/code&gt; 创建线程属性对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_destroy(attr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;每个线程结束时最后都调用 &lt;code&gt;pthread_exit&lt;/code&gt; 返回&lt;/li&gt;
&lt;li&gt;最好主函数也用 &lt;code&gt;pthread_exit&lt;/code&gt; 返回&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf48aba4" class="outline-4"&gt;
&lt;h4 id="orgf48aba4"&gt;合并和检测线程&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf48aba4"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_join (threadid,status)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_detach (threadid)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_setdetachstate (attr,detachstate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_getdetachstate (attr,detachstate)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;如果线程需要被 &lt;code&gt;join&lt;/code&gt; 最好显式设置 &lt;code&gt;joinable&lt;/code&gt; 属性，因为不是所有实现都默认加这个属性&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3cf123e" class="outline-4"&gt;
&lt;h4 id="org3cf123e"&gt;栈管理&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3cf123e"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_getstacksize (attr, stacksize)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_setstacksize (attr, stacksize)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_getstackaddr (attr, stackaddr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_attr_setstackaddr (attr, stackaddr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;线程的栈大小是实现相关的，所以为了程序可移植，最好自己设置栈大小&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc96ca10" class="outline-4"&gt;
&lt;h4 id="orgc96ca10"&gt;其它&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc96ca10"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_self ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_equal (thread1,thread2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_once (once_control, init_routine)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbbccbab" class="outline-3"&gt;
&lt;h3 id="orgbbccbab"&gt;互斥锁&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbbccbab"&gt;
&lt;p&gt;
典型的使用锁的过程是
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建并初始化锁变量&lt;/li&gt;
&lt;li&gt;几个线程尝试加锁&lt;/li&gt;
&lt;li&gt;只有一个会成功并获得锁&lt;/li&gt;
&lt;li&gt;获得锁的线程进行一些操作&lt;/li&gt;
&lt;li&gt;释放锁&lt;/li&gt;
&lt;li&gt;另一个线程尝试获得锁&lt;/li&gt;
&lt;li&gt;最终锁被销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org963ebdd" class="outline-4"&gt;
&lt;h4 id="org963ebdd"&gt;创建和销毁锁&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org963ebdd"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex_init (mutex,attr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex_destroy (mutex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutexattr_init (attr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutexattr_destroy (attr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建锁变量可以用 &lt;code&gt;pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;&lt;/code&gt;, 也可以用 &lt;code&gt;pthread_mutex_init()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4beb3bb" class="outline-4"&gt;
&lt;h4 id="org4beb3bb"&gt;加锁和解锁&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4beb3bb"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex_lock (mutex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex_trylock (mutex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex_unlock (mutex)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b0c976" class="outline-3"&gt;
&lt;h3 id="org9b0c976"&gt;条件变量&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9b0c976"&gt;
&lt;p&gt;
条件变量也是用于线程间同步的机制，与加锁的共享内存不同，条件变量用于传递消息。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd6945a8" class="outline-4"&gt;
&lt;h4 id="orgd6945a8"&gt;创建和销毁条件变量&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd6945a8"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_init (condition,attr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_destroy (condition)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_condattr_init (attr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_condattr_destroy (attr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建条件变量可以用 &lt;code&gt;pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER;&lt;/code&gt; 也可以用 &lt;code&gt;pthread_cond_init()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgafecca8" class="outline-4"&gt;
&lt;h4 id="orgafecca8"&gt;等待和通信&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgafecca8"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_wait (condition,mutex)&lt;/code&gt; 阻止线程直到某个条件被通信过来，应该在加锁时使用，会在等待时自动释放锁，当获得信号时又会把锁加回来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_signal (condition)&lt;/code&gt; 用来向其它等待中的线程传递信号，应该在加锁时使用，在操作后传信号，最后解锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_broadcast (condition)&lt;/code&gt; 用来向多个线程传递信号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;等待锁时应该使用 &lt;code&gt;while&lt;/code&gt; 循环判断而不是 &lt;code&gt;if&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>C</category><category>multithreading</category><category>parallel</category><category>pthread</category><guid>https://chimez.github.io/posts/pthread/</guid><pubDate>Thu, 01 Jul 2021 13:24:50 GMT</pubDate></item><item><title>ck: Concurrency Kit</title><link>https://chimez.github.io/posts/ck-concurrency-kit/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org504d378" class="outline-2"&gt;
&lt;h2 id="org504d378"&gt;ck: Concurrency Kit&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org504d378"&gt;
&lt;p&gt;
&lt;a href="https://github.com/concurrencykit/ck"&gt;ck&lt;/a&gt; 是一个c语言的高并发数据结构库，内存安全并且无阻塞。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org31a9b28" class="outline-3"&gt;
&lt;h3 id="org31a9b28"&gt;ck&lt;sub&gt;ht.h&lt;/sub&gt;: HashTable&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org31a9b28"&gt;
&lt;p&gt;
哈希表包括在头文件 &lt;code&gt;ck_ht.h&lt;/code&gt; 中，主要的数据类型有
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;ck_ht_t&lt;/code&gt; 哈希表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ck_ht_entry_t&lt;/code&gt; 哈希表中的键, 是用来读写哈希表的中间变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ck_ht_hash_t&lt;/code&gt; 键的哈希值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ck_ht_iterator_t&lt;/code&gt; 用来遍历哈希表的迭代器&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org07a09d0" class="outline-4"&gt;
&lt;h4 id="org07a09d0"&gt;初始化哈希表&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org07a09d0"&gt;
&lt;p&gt;
函数 &lt;code&gt;ck_hs_init&lt;/code&gt;
参数说明：
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;ck_hs_t *&lt;/code&gt; 哈希表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned int&lt;/code&gt; 哈希表的模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ck_hs_hash_cb_t *&lt;/code&gt; 哈希算法，传 &lt;code&gt;NULL&lt;/code&gt; 使用默认算法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct ck_malloc *&lt;/code&gt; 内存分配器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned long&lt;/code&gt; 初始容量，只是建议值，内部实现可大可小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsigned long&lt;/code&gt; 哈希算法的随机数种子&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;ck_ht_t&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CK_HT_MODE_BYTESTRING&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 设置内存分配器 */&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
    &lt;span class="n"&gt;ht_malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
    &lt;span class="n"&gt;ht_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

	&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;ck_malloc&lt;/span&gt; &lt;span class="n"&gt;my_allocator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ht_malloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ht_free&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="cm"&gt;/* 初始化哈希表 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ck_ht_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ht_hash_wrapper&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;my_allocator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6602834&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ck_ht_init"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* 删除哈希表 */&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org461396c" class="outline-4"&gt;
&lt;h4 id="org461396c"&gt;读写哈希表&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org461396c"&gt;
&lt;p&gt;
基本的逻辑是
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_hash&lt;/code&gt; 计算键的哈希值&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_entry_set&lt;/code&gt; 为写数据准备键值对，或使用 &lt;code&gt;ck_ht_entry_key_set&lt;/code&gt; 为读数据准备键值对&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_put_spmc&lt;/code&gt; 创建新键值对，使用 &lt;code&gt;ck_ht_get_spmc&lt;/code&gt; 读取键值对，使用 &lt;code&gt;ck_ht_set_spmc&lt;/code&gt; 更新值&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_entry_value&lt;/code&gt; 获取读到的值&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;ck_ht_t&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_entry_t&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_hash_t&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 创建新值 */&lt;/span&gt;
    &lt;span class="cm"&gt;/* 注意这里的 key_len 是 bytes 长度，也就是数组长度*sizeof(数组类型) */&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_entry_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_put_spmc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* 读取 */&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_entry_key_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_put_spmc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ck_ht_entry_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* 更新 */&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_entry_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ck_ht_put_spmc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val_old&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ck_ht_entry_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf2e884f" class="outline-4"&gt;
&lt;h4 id="orgf2e884f"&gt;遍历哈希表&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf2e884f"&gt;
&lt;p&gt;
基本步骤
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_iterator_init&lt;/code&gt; 初始化迭代器&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ck_ht_next&lt;/code&gt; 迭代&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
使用 &lt;code&gt;ck_ht_entry_key&lt;/code&gt; 和 &lt;code&gt;ck_ht_entry_value&lt;/code&gt; 读取键值
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;       &lt;span class="n"&gt;ck_ht_t&lt;/span&gt; &lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;ck_ht_iterator_t&lt;/span&gt; &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CK_HT_ITERATOR_INITIALIZER&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;ck_ht_entry_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

       &lt;span class="n"&gt;ck_ht_iterator_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ck_ht_next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ht&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	   &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ck_ht_entry_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	   &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ck_ht_entry_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>C</category><category>concurrency</category><category>hashmap</category><guid>https://chimez.github.io/posts/ck-concurrency-kit/</guid><pubDate>Sun, 27 Jun 2021 14:09:24 GMT</pubDate></item><item><title>greatest</title><link>https://chimez.github.io/posts/greatest/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org72c7358" class="outline-2"&gt;
&lt;h2 id="org72c7358"&gt;greatest: c 的单元测试&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org72c7358"&gt;
&lt;p&gt;
&lt;a href="https://github.com/silentbicycle/greatest"&gt;greatest&lt;/a&gt; 是 c 的一个单个头文件库，用于写单元测试
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org97aaa41" class="outline-3"&gt;
&lt;h3 id="org97aaa41"&gt;基本使用&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org97aaa41"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;"greatest.h"&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* A test runs various assertions, then calls PASS(), FAIL(), or SKIP(). */&lt;/span&gt;
&lt;span class="n"&gt;TEST&lt;/span&gt; &lt;span class="nf"&gt;x_should_equal_1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="cm"&gt;/* Compare, with an automatic "1 != x" failure message */&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT_EQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Compare, with a custom failure message */&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT_EQm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Yikes, x doesn't equal 1"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Compare, and if they differ, print both values,&lt;/span&gt;
&lt;span class="cm"&gt;     * formatted like `printf("Expected: %d\nGot: %d\n", 1, x);` */&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT_EQ_FMT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%d"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PASS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Suites can group multiple tests with common setup. */&lt;/span&gt;
&lt;span class="n"&gt;SUITE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;the_suite&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;RUN_TEST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x_should_equal_1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Add definitions that need to be in the test runner's main file. */&lt;/span&gt;
&lt;span class="n"&gt;GREATEST_MAIN_DEFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GREATEST_MAIN_BEGIN&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="cm"&gt;/* command-line options, initialization. */&lt;/span&gt;

    &lt;span class="cm"&gt;/* Individual tests can be run directly in main, outside of suites. */&lt;/span&gt;
    &lt;span class="cm"&gt;/* RUN_TEST(x_should_equal_1); */&lt;/span&gt;

    &lt;span class="cm"&gt;/* Tests can also be gathered into test suites. */&lt;/span&gt;
    &lt;span class="n"&gt;RUN_SUITE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;the_suite&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;GREATEST_MAIN_END&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="cm"&gt;/* display results */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>C</category><category>unittest</category><guid>https://chimez.github.io/posts/greatest/</guid><pubDate>Sun, 27 Jun 2021 07:47:29 GMT</pubDate></item><item><title>joblib</title><link>https://chimez.github.io/posts/joblib/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org53933da" class="outline-2"&gt;
&lt;h2 id="org53933da"&gt;joblib: 简单的并行&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org53933da"&gt;
&lt;p&gt;
&lt;a href="https://joblib.readthedocs.io/"&gt;joblib&lt;/a&gt;是一个易用的，无依赖的 python 库，主要用来很方便的做并行。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5bfe6be" class="outline-3"&gt;
&lt;h3 id="org5bfe6be"&gt;简单的并行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5bfe6be"&gt;
&lt;p&gt;
对一个 &lt;code&gt;for&lt;/code&gt; 循环并行化，基本上只需要两个函数 &lt;code&gt;Parallel&lt;/code&gt; 和 &lt;code&gt;delayed&lt;/code&gt; ，用 &lt;code&gt;delayed&lt;/code&gt; 包裹要并行的函数，并用列表推导式生成所有参数，再把这些东西扔给 &lt;code&gt;Parallel&lt;/code&gt; 函数，返回的就是并行后的结果了。
&lt;/p&gt;

&lt;p&gt;
基本上相当于 &lt;code&gt;multiprocessing.Pool.map&lt;/code&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;joblib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Parallel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delayed&lt;/span&gt;
   &lt;span class="n"&gt;Parallel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_jobs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;delayed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;Parallel&lt;/code&gt; 函数的参数用来指定并行的后端 &lt;code&gt;backend&lt;/code&gt; 、每批次执行的任务数、并行线程数等等
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org8d5c47a" class="outline-2"&gt;
&lt;h2 id="org8d5c47a"&gt;Tips&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8d5c47a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8294d20" class="outline-3"&gt;
&lt;h3 id="org8294d20"&gt;读取时避免锁&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8294d20"&gt;
&lt;p&gt;
使用 &lt;code&gt;multiprocessing.shared_memory&lt;/code&gt; 创建共享内存，并把内存地址名作为参数传递
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>parallel</category><category>python</category><guid>https://chimez.github.io/posts/joblib/</guid><pubDate>Sun, 06 Jun 2021 05:34:10 GMT</pubDate></item><item><title>LAPACK</title><link>https://chimez.github.io/posts/lapack/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org343cbe4" class="outline-2"&gt;
&lt;h2 id="org343cbe4"&gt;LAPACK&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org343cbe4"&gt;
&lt;p&gt;
主页在 &lt;a href="https://www.netlib.org/lapack/"&gt;https://www.netlib.org/lapack/&lt;/a&gt;, 文档在 &lt;a href="https://www.netlib.org/lapack/explore-html/"&gt;https://www.netlib.org/lapack/explore-html/&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
安装说明
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;liblapack&lt;/code&gt; 是本体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;liblapacke&lt;/code&gt; 是 c 的绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6599002" class="outline-3"&gt;
&lt;h3 id="org6599002"&gt;dsyevd: 实对称矩阵本征值&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6599002"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga74d5b5" class="outline-4"&gt;
&lt;h4 id="orga74d5b5"&gt;参数说明&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga74d5b5"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;jobz&lt;/code&gt; 计算任务类型， &lt;code&gt;jobz = "N"&lt;/code&gt; 只计算本征值， &lt;code&gt;jobz = "V"&lt;/code&gt; 计算本征值和本征矢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UPLO&lt;/code&gt; 矩阵的存储方式, &lt;code&gt;UPLO = "U"&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 中存了上三角矩阵， &lt;code&gt;UPLO = "L"&lt;/code&gt; 下三角矩阵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt; 矩阵维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 输入矩阵 &lt;code&gt;LDA * N&lt;/code&gt; 维，计算后会被破坏，或者保存为本征矢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LDA&lt;/code&gt; 矩阵维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; 本征值向量 &lt;code&gt;N&lt;/code&gt; 维，升序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WORK&lt;/code&gt; 工作向量，~LWORK~ 维, &lt;code&gt;WORK[0]&lt;/code&gt; 是最优的 &lt;code&gt;LWORK&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LWORK&lt;/code&gt; 工作向量维数， &lt;code&gt;LWORK = -1&lt;/code&gt; 计算最优的 &lt;code&gt;LWORK&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IWORK&lt;/code&gt; 工作向量， &lt;code&gt;LIWORK&lt;/code&gt; 维， &lt;code&gt;IWORK[0]&lt;/code&gt; 是最优的 &lt;code&gt;LIWORK&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIWORK&lt;/code&gt; 工作向量维数， &lt;code&gt;LIWORK = -1&lt;/code&gt; 计算最优的 &lt;code&gt;LIWORK&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INFO&lt;/code&gt; 错误信息， &lt;code&gt;info = 0&lt;/code&gt; 成功&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>BLAS</category><category>C</category><category>LAPACK</category><guid>https://chimez.github.io/posts/lapack/</guid><pubDate>Mon, 10 May 2021 01:46:43 GMT</pubDate></item><item><title>arpack</title><link>https://chimez.github.io/posts/arpack/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org13f1aa7" class="outline-2"&gt;
&lt;h2 id="org13f1aa7"&gt;ARPACK&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org13f1aa7"&gt;
&lt;p&gt;
新版本在 &lt;a href="https://github.com/opencollab/arpack-ng"&gt;arpack-ng&lt;/a&gt; , 文档在 &lt;a href="https://www.caam.rice.edu/software/ARPACK/UG/node135.html"&gt;rice - ARPACK&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org046eb4a" class="outline-3"&gt;
&lt;h3 id="org046eb4a"&gt;函数说明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org046eb4a"&gt;
&lt;p&gt;
头文件 &lt;code&gt;arpack.h&lt;/code&gt; 中的函数有
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;neupd_c&lt;/code&gt; 计算一般矩阵的本征值, &lt;code&gt;&amp;lt;?&amp;gt; = sdcz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;naupd_c&lt;/code&gt; 计算一般矩阵的反向通信接口, &lt;code&gt;&amp;lt;?&amp;gt; = sdcz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;seupd_c&lt;/code&gt; 计算厄米矩阵的本征值, &lt;code&gt;&amp;lt;?&amp;gt; = sd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;saupd_c&lt;/code&gt; 计算厄米矩阵的反向通信接口, &lt;code&gt;&amp;lt;?&amp;gt; = sd&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org52af175" class="outline-3"&gt;
&lt;h3 id="org52af175"&gt;&lt;code&gt;XYaupd&lt;/code&gt; 参数说明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org52af175"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;ido&lt;/code&gt;   反向通信标志，第一次运行 &lt;code&gt;ido=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bmat&lt;/code&gt;  问题类型标志，标准本征值问题 &lt;code&gt;bmat="I"&lt;/code&gt; , 扩展本征值问题 &lt;code&gt;bmat="G"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;  矩阵维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;which&lt;/code&gt; Ritz值的位置 &lt;code&gt;which="LA", "SA", "LM", "SM", "BE"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nev&lt;/code&gt; 计算本征值的个数 &lt;code&gt;0 &amp;lt; nev &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tol&lt;/code&gt; 浮点精度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resid&lt;/code&gt; 残差向量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ncv&lt;/code&gt; Lanczos 向量个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt; Lanczos 向量， &lt;code&gt;ncv&lt;/code&gt; 列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldv&lt;/code&gt; Lanczos 向量的首列长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam&lt;/code&gt; &lt;code&gt;int[11]&lt;/code&gt; 的数组，保存了 11 个设置参数
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;iparam[0]=ishift&lt;/code&gt; 选择隐式移动的方法， &lt;code&gt;ishift=0&lt;/code&gt; 由用户指定， &lt;code&gt;ishift=1&lt;/code&gt; 由约化三对角矩阵决定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[1]=levec&lt;/code&gt; 没用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[2]=mxiter&lt;/code&gt; 最大 Arnoldi 更新迭代次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[3]=nb&lt;/code&gt; 块大小，只能取 &lt;code&gt;nb=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[4]=nconv&lt;/code&gt; 收敛了的 Ritz 值个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[5]=iupd&lt;/code&gt; 没用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[6]=mode&lt;/code&gt; 指定本征值问题的类型只能取 &lt;code&gt;mode = 1,2,3,4,5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[7]=np&lt;/code&gt; &lt;code&gt;ido=3&lt;/code&gt; 时有用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[8]=numop&lt;/code&gt; OP*x 计算的次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[9]=numob&lt;/code&gt; B*x 计算的次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam[10]=numreo&lt;/code&gt; 重正交化的次数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ipntr&lt;/code&gt; &lt;code&gt;int[11]&lt;/code&gt; 的数组，保存指向 &lt;code&gt;workl&lt;/code&gt;, &lt;code&gt;workd&lt;/code&gt; 中起始位置的指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workd&lt;/code&gt; &lt;code&gt;3*N&lt;/code&gt; 长的数组，算法内部使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workl&lt;/code&gt; &lt;code&gt;lworkl&lt;/code&gt; 长的数组，算法内部使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lworkl&lt;/code&gt; &lt;code&gt;workl&lt;/code&gt; 的长度，至少 &lt;code&gt;ncv**2 + 8*ncv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt; 运行提示和错误信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdd4ac2a" class="outline-3"&gt;
&lt;h3 id="orgdd4ac2a"&gt;&lt;code&gt;XYeupd&lt;/code&gt; 参数说明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdd4ac2a"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;rvec&lt;/code&gt; 指定是否产生本征矢 &lt;code&gt;rvec=true&lt;/code&gt; 产生本征矢， &lt;code&gt;rvec=false&lt;/code&gt; 只产生本征值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;howmny&lt;/code&gt; 指定产生本征矢的个数 &lt;code&gt;howmny="A"&lt;/code&gt; 计算 &lt;code&gt;nev&lt;/code&gt; 个， &lt;code&gt;howmny="P"&lt;/code&gt; 计算 nev Schur 本征矢， &lt;code&gt;howmny="S"&lt;/code&gt; 计算一部分本征值，由 &lt;code&gt;select&lt;/code&gt; 指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; 指定计算的本征矢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dr&lt;/code&gt; Ritz 值的实部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;di&lt;/code&gt; Ritz 值的虚部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z&lt;/code&gt; Ritz 向量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldz&lt;/code&gt; Ritz 向量的首列维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigmar&lt;/code&gt; shift 的实部, iparam[6]=3 or 4 时有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigmai&lt;/code&gt; shift 的虚部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workev&lt;/code&gt; 3*ncv 的内部数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bmat&lt;/code&gt;  以下参数与 &lt;code&gt;XYaupd&lt;/code&gt; 相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;which&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ncv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iparam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ipntr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lworkl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>eigen</category><guid>https://chimez.github.io/posts/arpack/</guid><pubDate>Fri, 07 May 2021 10:48:36 GMT</pubDate></item><item><title>BLAS</title><link>https://chimez.github.io/posts/blas/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-orge468d11" class="outline-2"&gt;
&lt;h2 id="orge468d11"&gt;BLAS&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge468d11"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;MKL 中的 BLAS，参考 &lt;a href="https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/blas-and-sparse-blas-routines/blas-routines/naming-conventions-for-blas-routines.html"&gt;MKL - BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;标准的 BLAS 参考 &lt;a href="https://www.netlib.org/blas/"&gt;netlib - BLAS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfef8337" class="outline-3"&gt;
&lt;h3 id="orgfef8337"&gt;BLAS 的命名规则&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfef8337"&gt;
&lt;p&gt;
BLAS 中的函数名一般规则是 &lt;code&gt;&amp;lt;character&amp;gt;&amp;lt;name&amp;gt;&amp;lt;mode&amp;gt; ()&lt;/code&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;character&amp;gt;&lt;/code&gt; 指明数据类型
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; real, single precision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; complex, single precision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; real, double precision&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z&lt;/code&gt; complex, double precision&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 指明矩阵类型 BLAS 2 and 3
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;ge&lt;/code&gt; general matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gb&lt;/code&gt; general band matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sy&lt;/code&gt; symmetric matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sp&lt;/code&gt; symmetric matrix (packed storage)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sb&lt;/code&gt; symmetric band matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;he&lt;/code&gt; hermitian matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hp&lt;/code&gt; hermitian matrix (packed storage)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hb&lt;/code&gt; hermitian band matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tr&lt;/code&gt; triangular matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tp&lt;/code&gt; triangular matrix (packed storage)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb&lt;/code&gt; triangular band matrix&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;mod&amp;gt;&lt;/code&gt; 指明操作的细节
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; conjugated vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; unconjugated vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; Givens rotation construction&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; modified Givens rotation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mg&lt;/code&gt; modified Givens rotation construction&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv&lt;/code&gt; matrix-vector product&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sv&lt;/code&gt; solving a system of linear equations with a single unknown vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; rank-1 update of matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r2&lt;/code&gt; rank-2 update of matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm&lt;/code&gt; matrix-matrix product&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sm&lt;/code&gt; solving a system of linear equations with multiple unkonwn vectors&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rk&lt;/code&gt; rank-k update of matrix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r2k&lt;/code&gt; rank-2k update of a matrix&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6b7b696" class="outline-3"&gt;
&lt;h3 id="org6b7b696"&gt;CBLAS 约定&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6b7b696"&gt;
&lt;p&gt;
CBLAS 是 BLAS 的 c 接口， BLAS 是 fortran 标准。
&lt;/p&gt;

&lt;p&gt;
CBLAS 函数都遵循以下约定
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;输入参数是 &lt;code&gt;const&lt;/code&gt; 指针&lt;/li&gt;
&lt;li&gt;非复数标量输入参数传值&lt;/li&gt;
&lt;li&gt;复标量参数传 &lt;code&gt;void&lt;/code&gt; 指针&lt;/li&gt;
&lt;li&gt;数组参数传地址&lt;/li&gt;
&lt;li&gt;BLAS 特征参数由适当的枚举类型代替&lt;/li&gt;
&lt;li&gt;level 2 和 level 3 需要一个额外的 &lt;code&gt;CBLAS_LAYOUT&lt;/code&gt; 类型的参数来指定矩阵是行优先 &lt;code&gt;CblasRowMajor&lt;/code&gt; 还是列优先 &lt;code&gt;CblasColMajor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgca95bd0" class="outline-3"&gt;
&lt;h3 id="orgca95bd0"&gt;枚举类型&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgca95bd0"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;CBLAS_LAYOUT&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;CblasRowMajor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;101&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="cm"&gt;/* row-major arrays */&lt;/span&gt;
      &lt;span class="n"&gt;CblasColMajor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;102&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;   &lt;span class="cm"&gt;/* column-major arrays */&lt;/span&gt;

   &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;CBLAS_TRANSPOSE&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;CblasNoTrans&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;111&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="cm"&gt;/* trans='N' */&lt;/span&gt;
      &lt;span class="n"&gt;CblasTrans&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;112&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="cm"&gt;/* trans='T' */&lt;/span&gt;
      &lt;span class="n"&gt;CblasConjTrans&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;113&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  &lt;span class="cm"&gt;/* trans='C' */&lt;/span&gt;

   &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;CBLAS_UPLO&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;CblasUpper&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;121&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;        &lt;span class="cm"&gt;/* uplo ='U' */&lt;/span&gt;
      &lt;span class="n"&gt;CblasLower&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;122&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;       &lt;span class="cm"&gt;/* uplo ='L' */&lt;/span&gt;

   &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;CBLAS_DIAG&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;CblasNonUnit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;131&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="cm"&gt;/* diag ='N' */&lt;/span&gt;
      &lt;span class="n"&gt;CblasUnit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;132&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;        &lt;span class="cm"&gt;/* diag ='U' */&lt;/span&gt;

   &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;CBLAS_SIDE&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;CblasLeft&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;141&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;         &lt;span class="cm"&gt;/* side ='L' */&lt;/span&gt;
      &lt;span class="n"&gt;CblasRight&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;142&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;       &lt;span class="cm"&gt;/* side ='R' */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9304e2e" class="outline-3"&gt;
&lt;h3 id="org9304e2e"&gt;矩阵存储方式&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9304e2e"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;完全存储矩阵 \(A_{ij}_{}\) 在二维数组列存储 &lt;code&gt;a[i + j*lda]&lt;/code&gt; 行存储 &lt;code&gt;a[i*lda + j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;packed storage 可以用更有效的方式存储矩阵&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>BLAS</category><category>C</category><guid>https://chimez.github.io/posts/blas/</guid><pubDate>Fri, 07 May 2021 03:47:35 GMT</pubDate></item><item><title>PETSc</title><link>https://chimez.github.io/posts/petsc/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-org0c787d5" class="outline-2"&gt;
&lt;h2 id="org0c787d5"&gt;PETSc&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0c787d5"&gt;
&lt;p&gt;
&lt;a href="https://www.mcs.anl.gov/petsc/index.html"&gt;PETSc&lt;/a&gt; 是用于开发并行计算程序的基础库，完全建立在 MPI 上。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4eb3186" class="outline-3"&gt;
&lt;h3 id="org4eb3186"&gt;安装与编译&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4eb3186"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;下载 &lt;a href="https://www.mcs.anl.gov/petsc/download/"&gt;源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf1d7fa6" class="outline-3"&gt;
&lt;h3 id="orgf1d7fa6"&gt;基本结构&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf1d7fa6"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org89d7579" class="outline-4"&gt;
&lt;h4 id="org89d7579"&gt;PETSc 模块&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org89d7579"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;index set (IS)：向量的指标&lt;/li&gt;
&lt;li&gt;vectors (Vec)&lt;/li&gt;
&lt;li&gt;matrices (Mat): 稀疏矩阵&lt;/li&gt;
&lt;li&gt;Krylov subspace methods (KSP): 线性方程组求解&lt;/li&gt;
&lt;li&gt;preconditioners (PC): 预条件器和直接求解器&lt;/li&gt;
&lt;li&gt;nonlinear solvers(SNES)&lt;/li&gt;
&lt;li&gt;timesteppers for solving time-dependent PDES(TS): 时间演化求解器&lt;/li&gt;
&lt;li&gt;managing data structures(DM): 管理数据结构&lt;/li&gt;
&lt;li&gt;scalable optimization algorithms(Tao)&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6fd6c2e" class="outline-4"&gt;
&lt;h4 id="org6fd6c2e"&gt;环境变量&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6fd6c2e"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;所有 PETSc 程序都依赖环境变量 &lt;code&gt;$PETSC_DIR&lt;/code&gt; 找到 PETSc 的目录&lt;/li&gt;
&lt;li&gt;还需要环境变量 &lt;code&gt;$PETSC_ARCH&lt;/code&gt; 找到安装路径&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0eaa212" class="outline-4"&gt;
&lt;h4 id="org0eaa212"&gt;命令行&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0eaa212"&gt;
&lt;p&gt;
PETSc 程序需要用 MPI 执行，通过 &lt;code&gt;mpiexec&lt;/code&gt; 或者 PETSc 提供的脚本 &lt;code&gt;$PETSC_DIR/lib/petsc/bin/petscmpiexec&lt;/code&gt; 
&lt;/p&gt;

&lt;p&gt;
常用的命令行选项
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;-help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-log_view&lt;/code&gt; 显示性能摘要&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-fp_trap&lt;/code&gt; 浮点异常时退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-malloc_dump&lt;/code&gt; 内存追踪&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-malloc_debug&lt;/code&gt; 内存debug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-start_in_debugger [noxterm, gdb, lldb]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-on_error_attach_debugger&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-info&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org54036a4" class="outline-4"&gt;
&lt;h4 id="org54036a4"&gt;主函数&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org54036a4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;PETSc 主函数需要调用 &lt;code&gt;PetscInitialize()&lt;/code&gt; 作为开始，来初始化 PETSc 和 MPI&lt;/li&gt;
&lt;li&gt;程序退出时调用 &lt;code&gt;PetscFinalize()&lt;/code&gt;, 来结束 PETSc 和 MPI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
示例如下：
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;"petsc.h"&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 自定义帮助信息 */&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Solves a tridiagonal linear system with KSP.&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

	&lt;span class="cm"&gt;/* 初始化 */&lt;/span&gt;
	&lt;span class="n"&gt;PetscErrorCode&lt;/span&gt; &lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;PetscMPIInt&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscInitialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MPI_Comm_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CHKERRMPI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	    &lt;span class="n"&gt;SETERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PETSC_ERR_WRONG_MPI_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"This is a uniprocessor example only!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="cm"&gt;/* 主程序 &lt;/span&gt;
&lt;span class="cm"&gt;	 * ......&lt;/span&gt;
&lt;span class="cm"&gt;	 */&lt;/span&gt;

	&lt;span class="cm"&gt;/* 退出 */&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscFinalize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org47b91a7" class="outline-4"&gt;
&lt;h4 id="org47b91a7"&gt;错误处理&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org47b91a7"&gt;
&lt;p&gt;
所有 PETSc 函数都返回整数值 &lt;code&gt;ierr&lt;/code&gt; 作为消息，使用 &lt;code&gt;CHECKRRQ(ierr)&lt;/code&gt; 宏来处理错误。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org75c8bc4" class="outline-3"&gt;
&lt;h3 id="org75c8bc4"&gt;向量和并行数据&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org75c8bc4"&gt;
&lt;p&gt;
向量是 PETSc 最基本的结构，用于保存计算结果等
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfbc8697" class="outline-4"&gt;
&lt;h4 id="orgfbc8697"&gt;创建和组装向量&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgfbc8697"&gt;
&lt;p&gt;
PETSc 提供两种向量：顺序(Seq) 和并行(MPI)
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;VecCreateSeq(PETSC_COMM_SELF,PetscInt m,Vec *x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建顺序向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecCreateMPI(MPI_Comm comm,PetscInt m,PetscInt M,Vec *x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建并行向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecCreate(MPI_Comm comm,Vec *x);&lt;/code&gt; 
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建向量, 自动选择顺序或并行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MPI_Comm comm&lt;/code&gt; 是 MPI 通信器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecCreateSeqWithArray(PETSC_COMM_SELF,PetscInt bs,PetscInt n,PetscScalar *array,Vec *V);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecCreateMPIWithArray(MPI_Comm comm,PetscInt bs,PetscInt n,PetscInt N,PetscScalar *array,Vec *vv);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;根据输入的数据创建向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecSetSizes(Vec x, PetscInt m, PetscInt M);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置向量的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 是可选的局域大小，可以设为 &lt;code&gt;PETSC_DECIDE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; 是总大小&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecSetType()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecSetFromOptions()&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置向量的类型&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecSet(Vec x,PetscScalar value);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;将向量所有值都设成 &lt;code&gt;value&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecSetValues(Vec x,PetscInt n,PetscInt *indices,PetscScalar *values,INSERT_VALUES);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置向量的部分值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PetscInt n&lt;/code&gt; 要设置的值的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PetscInt *indices&lt;/code&gt; 设置的值的指标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PetscScalar *values&lt;/code&gt; 设置的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InsertMode iota&lt;/code&gt; 设置值的方式：
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;INSERT_VALUES&lt;/code&gt; 代替旧值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_VALUES&lt;/code&gt; 将旧值加上新值&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecAssemblyBegin(Vec x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;开始组装向量, 在 &lt;code&gt;VecSetValues()&lt;/code&gt; 之后调用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecAssemblyEnd(Vec x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;结束组装向量，在 &lt;code&gt;VecAssemblyBegin()&lt;/code&gt; 之后调用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecView(Vec x,PetscViewer v);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;打印输出向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecDuplicate(Vec old, Vec *new);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建一个新的向量，其类型与旧的相同&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecDuplicateVecs(Vec old,PetscInt n,Vec **new);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建多个向量，与原向量类型相同&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;VecDestroy(Vec *x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;销毁向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecDestroyVecs(PetscInt n,Vec **vecs);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;销毁多个向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;Vec&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PetscObjectSetName&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;PetscObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecSetSizes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PETSC_DECIDE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecSetFromOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Vec&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecDuplicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="k"&gt;complex&lt;/span&gt; &lt;span class="n"&gt;vx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecSetValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INSERT_VALUES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecAssemblyBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecAssemblyEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;timespec&lt;/span&gt; &lt;span class="n"&gt;t0_mvm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;timespec_get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t0_mvm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIME_UTC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatMult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc11ca22" class="outline-4"&gt;
&lt;h4 id="orgc11ca22"&gt;基本向量操作&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc11ca22"&gt;
&lt;p&gt;
加减乘除之类的操作，参考&lt;a href="https://petsc.org/release/documentation/manual/vec/#id3"&gt;函数表&lt;/a&gt;
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;VecGetOwnershipRange(Vec vec,PetscInt *low,PetscInt *high);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获取当前局域操作的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;low&lt;/code&gt; 是第一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;high&lt;/code&gt; 是最后一个再 +1&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecGetArray(Vec v,PetscScalar **array);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获取当前局域的数组的所有权&lt;/li&gt;
&lt;li&gt;这个函数直接获得了裸数据的指针&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecRestoreArray(Vec v, PetscScalar **array);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;恢复当前局域的数组的所有权&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecGetArrayRead(Vec v, const PetscScalar **array);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;只读地获取当前局域的数组&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecRestoreArrayRead(Vec v, const PetscScalar **array);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;恢复获取的只读数组的所有权&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecGetLocalSize(Vec v,PetscInt *size);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获取当前局域的大小&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VecGetSize(Vec v,PetscInt *size);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获取向量的总大小&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org271e5e9" class="outline-4"&gt;
&lt;h4 id="org271e5e9"&gt;索引和排序&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org271e5e9"&gt;
&lt;p&gt;
PETSc 提供了一组工具用于处理向量指标的顺序，称作 Application Orderings(AO)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org488a9a6" class="outline-3"&gt;
&lt;h3 id="org488a9a6"&gt;矩阵&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org488a9a6"&gt;
&lt;p&gt;
PETSc 支持多种矩阵类型，包括稠密矩阵、稀疏矩阵等
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b63392" class="outline-4"&gt;
&lt;h4 id="org9b63392"&gt;创建和组装矩阵&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9b63392"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;MatCreate(MPI_Comm comm,Mat *A);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建矩阵&lt;/li&gt;
&lt;li&gt;默认的矩阵类似是 稀疏 AIJ&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MatSetSizes(Mat A,PETSC_DECIDE,PETSC_DECIDE,PetscInt M,PetscInt N);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置矩阵大小&lt;/li&gt;
&lt;li&gt;第二、三个参数是局域的行列大小&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MatSetType(A,MatType matype);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置矩阵类型&lt;/li&gt;
&lt;li&gt;矩阵类型 &lt;code&gt;MatType&lt;/code&gt; 有很多&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MatSetValues(Mat A,PetscInt m,PetscInt *im,PetscInt n,PetscInt *in,PetscScalar *values,INSERT_VALUES);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置矩阵的值&lt;/li&gt;
&lt;li&gt;规则类似 &lt;code&gt;Vec&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MatSetOption(Mat A,MAT_ROW_ORIENTED,PETSC_FALSE);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置加入值的方式，行先或列先等&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;开始组装矩阵，在所有的 &lt;code&gt;MatSetValues()&lt;/code&gt; 调用完成后使用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;完成组装矩阵，在 &lt;code&gt;MatAssemblyBegin()&lt;/code&gt; 之后调用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;code&gt;MatGetOwnershipRange(Mat A,PetscInt *first_row,PetscInt *last_row);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;获取矩阵的一部分&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatSetSizes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PETSC_DECIDE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PETSC_DECIDE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatSetFromOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatSetUp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;PetscScalar&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatSetValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;INSERT_VALUES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatAssemblyBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAT_FINAL_ASSEMBLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatAssemblyEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAT_FINAL_ASSEMBLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;MatView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;PETSC_VIEWER_STDOUT_WORLD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatDestroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CHKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org55be7ae" class="outline-4"&gt;
&lt;h4 id="org55be7ae"&gt;矩阵类型&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org55be7ae"&gt;
&lt;p&gt;
PETSc默认的矩阵类型是 AIJ(也就是 CSR)
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;稀疏矩阵&lt;/li&gt;
&lt;li&gt;Limited-Memory Variable Metric (LMVM) Matrices&lt;/li&gt;
&lt;li&gt;稠密矩阵&lt;/li&gt;
&lt;li&gt;块矩阵&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org473a607" class="outline-4"&gt;
&lt;h4 id="org473a607"&gt;基本矩阵操作&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org473a607"&gt;
&lt;p&gt;
参考&lt;a href="https://petsc.org/release/documentation/manual/mat/#fig-matrixops"&gt;函数表&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6a83f07" class="outline-4"&gt;
&lt;h4 id="org6a83f07"&gt;无矩阵的矩阵&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6a83f07"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;MatCreateShell(MPI_Comm comm,PetscInt m,PetscInt n,PetscInt M,PetscInt N,void *ctx,Mat *mat);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;创建矩阵的结构，无需添加矩阵元&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M, N&lt;/code&gt; 是矩阵总维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m, n&lt;/code&gt; 是局域维数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctx&lt;/code&gt; 是用户定义的矩阵操作&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MatShellSetOperation(Mat mat,MatOperation MATOP_MULT, (void(*)(void)) PetscErrorCode (*UserMult)(Mat,Vec,Vec));&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;注册用户定义的矩阵运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MATOP_MULT&lt;/code&gt; 指的是矩阵乘向量&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cm"&gt;/* 定义每个矩阵都需要用到的一些数据 */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;A_data&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="n"&gt;A_data_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* 自定义的矩阵乘向量运算函数, y = A x */&lt;/span&gt;
    &lt;span class="n"&gt;PetscErrorCode&lt;/span&gt;
    &lt;span class="nf"&gt;A_MatVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vec&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vec&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

	&lt;span class="cm"&gt;/* 获取数据 */&lt;/span&gt;
	&lt;span class="n"&gt;A_data_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;A_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;PetscErrorCode&lt;/span&gt; &lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;MatShellGetContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


	&lt;span class="cm"&gt;/* 获得本地的 x 向量数据 */&lt;/span&gt;
	&lt;span class="n"&gt;PetscInt&lt;/span&gt; &lt;span class="n"&gt;x_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x_end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecGetOwnershipRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x_end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;PetscScalar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x_arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecGetArrayRead&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x_arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="cm"&gt;/* y 向量要先置零 */&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="cm"&gt;/* 设置计算后 y 的值 */&lt;/span&gt;
	&lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="n"&gt;PetscScalar&lt;/span&gt; &lt;span class="n"&gt;new_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecSetValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ADD_VALUES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	    &lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecAssemblyBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecAssemblyEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

	&lt;span class="cm"&gt;/* 结束计算要返还 x 的所有权 */&lt;/span&gt;
	&lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VecRestoreArrayRead&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x_arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="cm"&gt;/* 创建无矩阵的矩阵 A，必须设置每个局域块 A 的大小 */&lt;/span&gt;
    &lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;A_data_t&lt;/span&gt; &lt;span class="n"&gt;A_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatCreateShell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PETSC_COMM_WORLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_local_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_local_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* 为 A 绑定矩阵乘向量运算 */&lt;/span&gt;
    &lt;span class="n"&gt;ierr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatShellSetOperation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Afree&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MATOP_MULT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="n"&gt;A_MatVec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CAKERRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ierr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd455f49" class="outline-3"&gt;
&lt;h3 id="orgd455f49"&gt;线性求解器&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd455f49"&gt;
&lt;p&gt;
使用线性求解器 &lt;code&gt;KSP&lt;/code&gt; 解线性方程 \(Ax=b\)
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;KSPCreate(MPI_Comm comm,KSP *ksp);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;初始化 KSP&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KSPSetOperators(KSP ksp,Mat Amat,Mat Pmat);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置矩阵&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KSPSetFromOptions(KSP ksp);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;设置求解器选项&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KSPSolve(KSP ksp,Vec b,Vec x);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;运行求解器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KSPDestroy(KSP ksp);&lt;/code&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;运算结束销毁求解器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org9dadbeb" class="outline-2"&gt;
&lt;h2 id="org9dadbeb"&gt;其它问题&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9dadbeb"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org491e88e" class="outline-3"&gt;
&lt;h3 id="org491e88e"&gt;复数支持&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org491e88e"&gt;
&lt;p&gt;
只能通过编译选项 &lt;code&gt;--with-scalar-type=complex&lt;/code&gt; 将 &lt;code&gt;PetscScalar&lt;/code&gt; 设成复数
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga5a99e8" class="outline-3"&gt;
&lt;h3 id="orga5a99e8"&gt;编译选项&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga5a99e8"&gt;
&lt;p&gt;
&lt;a href="https://www.mcs.anl.gov/petsc/documentation/installation.html"&gt;参考&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
debug 模式：
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   ./configure PETSC_ARCH=arch-complex-debug --with-scalar-type=complex
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
release 模式:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   ./configure PETSC_ARCH=arch-complex-release --with-cc=gcc --with-cxx=g++ --with-fc=gfortran --with-debugging=0 COPTFLAGS='-O3 -march=native -mtune=native' CXXOPTFLAGS='-O3 -march=native -mtune=native' FOPTFLAGS='-O3 -march=native -mtune=native' --with-scalar-type=complex --download-mpich
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>C</category><category>HPC</category><category>mpi</category><category>petsc</category><guid>https://chimez.github.io/posts/petsc/</guid><pubDate>Wed, 21 Apr 2021 07:39:14 GMT</pubDate></item><item><title>PyTables</title><link>https://chimez.github.io/posts/pytables/</link><dc:creator>chimez</dc:creator><description>&lt;div id="outline-container-orge63fc38" class="outline-2"&gt;
&lt;h2 id="orge63fc38"&gt;PyTables: 分层数据集&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge63fc38"&gt;
&lt;p&gt;
&lt;a href="https://www.pytables.org"&gt;PyTables&lt;/a&gt; 是基于 HDF5 格式构建的数据集，比 pandas 更底层，比 h5py 更高层。适合用在存储比 csv 表格更复杂更大的数据，同时又不想自己实现一些基本的数据操作的情况中，并且经过简单的处理就能用 pandas 进行进一步数据分析。
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgca3ec8c" class="outline-3"&gt;
&lt;h3 id="orgca3ec8c"&gt;安装&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgca3ec8c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   # 使用 conda
   conda install pytables
   # 或者 pip
   python3 -m pip install tables
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
测试
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;tables&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;tb&lt;/span&gt;

   &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org65428e7" class="outline-3"&gt;
&lt;h3 id="org65428e7"&gt;基本使用&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org65428e7"&gt;
&lt;p&gt;
pytables 的基本逻辑是
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7f38529" class="outline-4"&gt;
&lt;h4 id="org7f38529"&gt;创建一个 HDF5 文件&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7f38529"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"filename.h5"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"w"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"file title"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filters&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;complevel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# 别忘了还要关闭它&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6ae6a0b" class="outline-4"&gt;
&lt;h4 id="org6ae6a0b"&gt;在文件中创建任意层的数据集&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6ae6a0b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"/parent/group"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"group_name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"group title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf749030" class="outline-4"&gt;
&lt;h4 id="orgf749030"&gt;在数据集中创建若干个数据表&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgf749030"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# 需要创建对数据的描述&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;data_description&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsDescription&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringCol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;idn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Int64Col&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
	&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;sub_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsDescription&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringCol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	    &lt;span class="n"&gt;id2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Float64Col&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# 然后创建空的数据表       &lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"table_name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data_description&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# 在里面循环添加记录&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;
	&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"idn"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
	&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"sub_data"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'asd_&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
	&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# 最后刷新一下缓存，确保数据都写入到磁盘&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org62aa681" class="outline-2"&gt;
&lt;h2 id="org62aa681"&gt;遇到的问题&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org62aa681"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7ea187c" class="outline-3"&gt;
&lt;h3 id="org7ea187c"&gt;在不支持 &lt;code&gt;flock&lt;/code&gt; 的集群上运行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7ea187c"&gt;
&lt;p&gt;
需要设置环境变量
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   export HDF5_USE_FILE_LOCKING=FALSE
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>python</category><guid>https://chimez.github.io/posts/pytables/</guid><pubDate>Mon, 01 Mar 2021 03:23:19 GMT</pubDate></item></channel></rss>