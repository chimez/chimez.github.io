<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-27 Sun 17:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>clojurescript</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">clojurescript</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org463eb32">1. ClojureScript 笔记</a>
<ul>
<li><a href="#orgff5e285">1.1. ClojureScript基本流程</a>
<ul>
<li><a href="#org1fd4cdc">1.1.1. 安装</a></li>
<li><a href="#org5b82973">1.1.2. 项目目录结构</a></li>
<li><a href="#orgfc35977">1.1.3. 编译方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org92aaa86">2. 踩坑记录</a>
<ul>
<li><a href="#orgde4919b">2.1. 如何引入 js 库</a>
<ul>
<li><a href="#org31a6afc">2.1.1. 编译到浏览器</a></li>
<li><a href="#orgbed810c">2.1.2. 编译到 nodejs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org364937f">3. cljs-ajax</a>
<ul>
<li><a href="#orga329f5e">3.1. 安装与引用</a></li>
<li><a href="#org4e0fdf9">3.2. 基本使用</a>
<ul>
<li><a href="#org61e63e2">3.2.1. 消息处理</a></li>
<li><a href="#org0749737">3.2.2. 基本GET</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdc0a027">4. re-frame</a>
<ul>
<li><a href="#org035a05b">4.1. 安装与原理</a>
<ul>
<li><a href="#org96cbb98">4.1.1. 加入依赖</a></li>
<li><a href="#orgc4f315c">4.1.2. 设计思想</a></li>
</ul>
</li>
<li><a href="#org09fb6fb">4.2. 基本使用</a>
<ul>
<li><a href="#orgba8c32b">4.2.1. app-db应用状态设计</a></li>
<li><a href="#orgdbeb429">4.2.2. 第一步：定义事件</a></li>
<li><a href="#org35febb8">4.2.3. 第二步：为每个事件编写并注册事件处理函数</a></li>
<li><a href="#org7908cc3">4.2.4. 第三步：效应处理</a></li>
<li><a href="#org117b003">4.2.5. 第四步：订阅处理/查询函数</a></li>
<li><a href="#org70b1bb0">4.2.6. 第五步：视图函数，Reagent</a></li>
<li><a href="#org7123702">4.2.7. 第六步：DOM与运行循环</a></li>
</ul>
</li>
<li><a href="#orga10762a">4.3. 其他事项</a>
<ul>
<li><a href="#org65946f5">4.3.1. 推荐的项目结构</a></li>
<li><a href="#org177b5c5">4.3.2. 拦截器, interceptors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4d53cdd">5. reagent</a>
<ul>
<li><a href="#org4464bdc">5.1. 安装与配置</a></li>
<li><a href="#org09fb2c0">5.2. 基本语法</a>
<ul>
<li><a href="#orgc90d7c9">5.2.1. 组件</a></li>
<li><a href="#org673f8d1">5.2.2. DOM渲染</a></li>
<li><a href="#orgcda93de">5.2.3. 页面状态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcb226a0">6. secretary</a>
<ul>
<li><a href="#org6e6e01d">6.1. 安装与引用</a>
<ul>
<li><a href="#orge4dcc08">6.1.1. 依赖</a></li>
<li><a href="#orge355ca5">6.1.2. 引用</a></li>
</ul>
</li>
<li><a href="#org8b9bc34">6.2. 基本使用</a>
<ul>
<li><a href="#org6dd0bc2">6.2.1. html</a></li>
<li><a href="#org2c02992">6.2.2. 源文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb1dff13">7. shadow-cljs</a>
<ul>
<li><a href="#orge82e70c">7.1. 安装</a></li>
<li><a href="#orgd00543e">7.2. 编译</a>
<ul>
<li><a href="#orgeb98f73">7.2.1. 配置</a></li>
<li><a href="#org7f0aace">7.2.2. 命令</a></li>
<li><a href="#org7046a32">7.2.3. 编译目标</a></li>
<li><a href="#org4d6cd6d">7.2.4. 使用npm模块</a></li>
</ul>
</li>
<li><a href="#org17e6341">7.3. 注意事项与技巧</a>
<ul>
<li><a href="#org1d90999">7.3.1. om 与 reagent</a></li>
<li><a href="#org9f9e3a7">7.3.2. 加载后自动刷新</a></li>
<li><a href="#org28ca147">7.3.3. 开启控制台调试输出</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-org463eb32" class="outline-2">
<h2 id="org463eb32"><span class="section-number-2">1</span> ClojureScript 笔记</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgff5e285" class="outline-3">
<h3 id="orgff5e285"><span class="section-number-3">1.1</span> ClojureScript基本流程</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org1fd4cdc" class="outline-4">
<h4 id="org1fd4cdc"><span class="section-number-4">1.1.1</span> 安装</h4>
<div class="outline-text-4" id="text-1-1-1">
<ol class="org-ol">
<li>不需要安装什么东西，只需要一个cljs.jar文件即可</li>
<li>java版本&gt;8</li>
</ol>
</div>
</div>

<div id="outline-container-org5b82973" class="outline-4">
<h4 id="org5b82973"><span class="section-number-4">1.1.2</span> 项目目录结构</h4>
<div class="outline-text-4" id="text-1-1-2">
<pre class="example">
  源文件：/src/core.cljs

    (ns hello-world.core) ;先声明名字空间
    (enable-console-print!) ;启用控制台输出
    (println "Hello world!")  ;在控制台里输出文字
</pre>
</div>
</div>

<div id="outline-container-orgfc35977" class="outline-4">
<h4 id="orgfc35977"><span class="section-number-4">1.1.3</span> 编译方法</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<ol class="org-ol">
<li><a id="org15b3827"></a>基本编译<br />
<div class="outline-text-5" id="text-1-1-3-1">
<p>
在项目目录里创建文件 <code>build.clj</code> 
</p>
<pre class="example">
  (require 'cljs.build.api)
    (cljs.build.api/build "src" {:output-to "out/main.js"})')

</pre>
<p>
执行编译命令:
</p>
<pre class="example">
Linux:
  java -cp cljs.jar:src clojure.main build.clj 

    Windows:
    java -cp "cljs.jar;src" clojure.main build.clj
</pre>

<p>
注意linux里是冒号无引号，windows里是分号有引号
</p>

<pre class="example">
  &lt;html&gt;
    &lt;body&gt;
    &lt;script type="text/javascript" src="out/goog/base.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="out/main.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
    goog.require("hello_world.core");
  // Note the underscore "_"!
  &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;


</pre>
<p>
html模板里要引用Google closure library， 编译的文件 并且还要执行js代码
</p>
</div>
</li>

<li><a id="orgba3869c"></a>另一种编译方法：减少模板<br />
<div class="outline-text-5" id="text-1-1-3-2">
<p>
在 <code>build.clj</code> 文件中指定主函数
</p>
<pre class="example">
  (require 'cljs.build.api)

    (cljs.build.api/build "src"
     {:main 'hello-world.core
     :output-to "out/main.js"})')
</pre>
<p>
现在html模板可以写成
</p>
<pre class="example">
  &lt;html&gt;
    &lt;body&gt;
    &lt;script type="text/javascript" src="out/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;


</pre>
<p>
会自动引用包并执行入口函数
</p>
</div>
</li>

<li><a id="org5c1708a"></a>自动编译<br />
<div class="outline-text-5" id="text-1-1-3-3">
<p>
可以实现监测源文件修改并自动编译,创建 <code>watch.clj</code> 文件
</p>

<pre class="example">
  (require 'cljs.build.api)

    (cljs.build.api/watch "src"
     {:main 'hello-world.core
     :output-to "out/main.js"})')
</pre>
<p>
执行自动编译
</p>
<pre class="example">
  java -cp cljs.jar:src clojure.main watch.clj
</pre>
</div>
</li>

<li><a id="org2732b8e"></a>REPL<br />
<div class="outline-text-5" id="text-1-1-3-4">
<p>
在控制台启动REPL的方法，创建文件 <code>repl.clj</code> 
</p>
<pre class="example">
  (require 'cljs.repl)
    (require 'cljs.build.api)
    (require 'cljs.repl.browser)

    (cljs.build.api/build "src"
     {:main 'hello-world.core
     :output-to "out/main.js"
     :browser-repl true
     :verbose true})

    (cljs.repl/repl (cljs.repl.browser/repl-env)
     :watch "src"
     :output-dir "out")')
</pre>

<p>
运行命令
</p>
<pre class="example">
  java -cp cljs.jar:src clojure.main repl.clj

</pre>
<p>
为了增强repl的功能，可以使用rlwrap
</p>

<pre class="example">
  rlwrap java -cp cljs.jar:src clojure.main repl.clj

</pre>

<p>
运行命令之后需要用浏览器连接后端，打开 <a href="http://localhost:9000">http://localhost:9000</a> 
</p>

<p>
自动编译过程的记录： <code>tail -f out/watch.log</code> 
</p>
</div>
</li>

<li><a id="org36877b7"></a>发行编译：压缩到一个文件里<br />
<div class="outline-text-5" id="text-1-1-3-5">
<p>
创建  <code>release.clj</code> 
</p>
<pre class="example">
  (require 'cljs.build.api)

    (cljs.build.api/build "src"
     {:output-to "out/main.js"
     :optimizations :advanced})

    (System/exit 0)')
</pre>

<p>
运行编译： <code>java -cp cljs.jar:src clojure.main release.clj</code> 
</p>


<p>
引入js库的方法
</p>
<pre class="example">

(def electron       (js/require "electron"))
(def remote            (.-remote electron))
(def store-path (.getPath remote.app "userData"))
</pre>

<p>
新建对象的方法
即 <code>let a=new b() = 就相当于 = (def a (b.))</code>  和调用函数不同,点在后面
</p>
<pre class="example">

(def low (js/require "lowdb"))
(def FileSync (js/require "lowdb/adapters/FileSync"))
(def adapter (FileSync. (str store-path "/db.json")))
(def db (low adapter))
(.write (.defaults db (clj-&gt;js {:a "a"})))

</pre>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org92aaa86" class="outline-2">
<h2 id="org92aaa86"><span class="section-number-2">2</span> 踩坑记录</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgde4919b" class="outline-3">
<h3 id="orgde4919b"><span class="section-number-3">2.1</span> 如何引入 js 库</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org31a6afc" class="outline-4">
<h4 id="org31a6afc"><span class="section-number-4">2.1.1</span> 编译到浏览器</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
在 <code>ns</code> 里使用 <code>require</code>
这里使用了 ant.design 的按钮组件作为例子.
</p>
<div class="org-src-container">
<pre class="src src-clojure">      (ns name.space
        (:require [reagent.core :as r]
                  ["antd/lib/button" :as Button]))
      (defn button [] 
        [:&gt; Button "button"])
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbed810c" class="outline-4">
<h4 id="orgbed810c"><span class="section-number-4">2.1.2</span> 编译到 nodejs</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
使用 CommonJS 语法 
这里使用 lowdb 作为例子
</p>
<div class="org-src-container">
<pre class="src src-clojure">      (def low (js/require "lowdb"))
      (def FileSync (js/require "lowdb/adapters/FileSync"))
      (def fs (js/require "fs-extra"))

      (def adapter-levels (FileSync. (str js/__dirname "/json/levels.json")))
      (def db-levels (low adapter-levels))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org364937f" class="outline-2">
<h2 id="org364937f"><span class="section-number-2">3</span> cljs-ajax</h2>
<div class="outline-text-2" id="text-3">
<p>
cljs-ajax为Clojure和ClojureScript提供相同Ajax的接口
</p>
</div>
<div id="outline-container-orga329f5e" class="outline-3">
<h3 id="orga329f5e"><span class="section-number-3">3.1</span> 安装与引用</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-clojure">[cljs-ajax "0.7.3"]
(ns foo
  (:require [ajax.core :as ajax]))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e0fdf9" class="outline-3">
<h3 id="org4e0fdf9"><span class="section-number-3">3.2</span> 基本使用</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org61e63e2" class="outline-4">
<h4 id="org61e63e2"><span class="section-number-4">3.2.1</span> 消息处理</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
在发送消息之后，反馈的消息由 <code>handler</code> 错误由 <code>erroe-handler</code> 捕获并处理，可以直接定义默认的处理函数，也可以为每个请求指定处理函数
消息处理函数只有一个参数
</p>
<pre class="example">
(defn handler [response]
  (.log js/console (str response)))

(defn error-handler [{:keys [status status-text]}]
  (.log js/console (str "something bad happened: " status " " status-text)))
</pre>
</div>
</div>
<div id="outline-container-org0749737" class="outline-4">
<h4 id="org0749737"><span class="section-number-4">3.2.2</span> 基本GET</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
注意地址的写法，本地地址要从 <code>/</code> 开始，不能省略
</p>
<pre class="example">
(ajax/GET "/hello")
(ajax/GET "/index.css" {:handler =(println %)})
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdc0a027" class="outline-2">
<h2 id="orgdc0a027"><span class="section-number-2">4</span> re-frame</h2>
<div class="outline-text-2" id="text-4">
<p>
re-frame是基于reagent的用于创建单页应用的函数式框架
</p>
</div>
<div id="outline-container-org035a05b" class="outline-3">
<h3 id="org035a05b"><span class="section-number-3">4.1</span> 安装与原理</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org96cbb98" class="outline-4">
<h4 id="org96cbb98"><span class="section-number-4">4.1.1</span> 加入依赖</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-clojure">[reagent "0.8.0-alpha2"]
[re-frame "0.10.1"]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4f315c" class="outline-4">
<h4 id="orgc4f315c"><span class="section-number-4">4.1.2</span> 设计思想</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
re-frame采用事件驱动，在主循环里分为六个连续的部分
</p>
<ol class="org-ol">
<li>事件发生：定义组件上能产生的事件并构造事件信息</li>
<li>事件处理：绑定事件和处理函数</li>
<li>效果处理：执行事件处理函数改变应用状态</li>
<li>查询：获取当前状态对应的信息</li>
<li>视图：展示/更新组件，reagent</li>
<li>DOM：由react完成，操作DOM</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org09fb6fb" class="outline-3">
<h3 id="org09fb6fb"><span class="section-number-3">4.2</span> 基本使用</h3>
<div class="outline-text-3" id="text-4-2">
<p>
这里介绍构建单页应用的基本流程，以 <code>example/simple</code> 为例，动态显示一个数字时钟，并可以改变颜色
</p>
</div>
<div id="outline-container-orgba8c32b" class="outline-4">
<h4 id="orgba8c32b"><span class="section-number-4">4.2.1</span> app-db应用状态设计</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
在这个例子中，只有两个状态：要显示的时间和时钟颜色
 <code>app-db</code> 应包括以下内容:
</p>
<div class="org-src-container">
<pre class="src src-clojure">{:time       (js/Date.)  ;; current time for display
 :time-color "=f88"}     ;; the colour in which the time should be shown
</pre>
</div>
<p>
&gt; 在re-frame中，应用状态由框架自己进行管理，并称为app-db，类似一个内存数据库，创建app-db在第二步中进行
</p>
</div>
</div>

<div id="outline-container-orgdbeb429" class="outline-4">
<h4 id="orgdbeb429"><span class="section-number-4">4.2.2</span> 第一步：定义事件</h4>
<div class="outline-text-4" id="text-4-2-2">
</div>
<ol class="org-ol">
<li><a id="org0c96169"></a>事件的数据结构<br />
<div class="outline-text-5" id="text-4-2-2-1">
<p>
在re-frame中事件是一个单纯的数据,不会把回调函数放进去，用向量来表示，第一项是符号，说明事件的类型，之后的东西都是可选的，可以为事件提供详细信息,下面是一些例子：
</p>
<div class="org-src-container">
<pre class="src src-clojure">[:delete-item 42]
[:admit-to-being-satoshi false]
[:dressing/put-pants-on  "velour flares" {:method :left-leg-first :belt false}]
</pre>
</div>
</div>
</li>
<li><a id="org72199ca"></a>dispatch 发送事件<br />
<div class="outline-text-5" id="text-4-2-2-2">
<p>
使用re-frame/dispatch 函数来发送一个事件
</p>
<div class="org-src-container">
<pre class="src src-clojure">   (rf/dispatch [:event-id  value1 value2])

</pre>
</div>
<p>
在任何函数里对dispatch求值就发送了一个事件
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn dispatch-timer-event
  []
  (let [now (js/Date.)]
    (rf/dispatch [:timer now])))  ;; &lt;-- dispatch used

;; call the dispatching function every second
(defonce do-timer (js/setInterval dispatch-timer-event 1000))

</pre>
</div>
</div>
</li>

<li><a id="org8be2cdc"></a>dispatch原理，事件队列的实现<br />
<div class="outline-text-5" id="text-4-2-2-3">
<p>
调用dispatch会把事件放进消息队列里，由router对队列里的事件进行处理，因此事件是异步的
router和事件队列由re-frame内部实现，自己只需要定义事件处理函数并注册它，就可以了
router的功能：
</p>
<ol class="org-ol">
<li>检查事件向量的第一个元素</li>
<li>查询哪个事件处理函数来处理这个事件</li>
<li>调用这个事件处理函数</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org35febb8" class="outline-4">
<h4 id="org35febb8"><span class="section-number-4">4.2.3</span> 第二步：为每个事件编写并注册事件处理函数</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
在这个应用里有三个事件 <code>:intitalize :time-color-change :timer</code> ,所以要写三个事件处理函数
</p>
</div>
<ol class="org-ol">
<li><a id="org6034cc1"></a>事件处理函数<br />
<div class="outline-text-5" id="text-4-2-3-1">
<p>
事件处理函数输入两个参数 <code>coeffects event =即应用状态和事件，返回</code> effects= 即状态要发生的改变,结构如下
</p>
<div class="org-src-container">
<pre class="src src-clojure">(def fun [db event]
  {:a "new a"
   :b "new b"})
</pre>
</div>
</div>
</li>
<li><a id="org44deaf5"></a>注册事件处理函数<br />
<div class="outline-text-5" id="text-4-2-3-2">
<p>
re-frame提供了两个注册函数 <code>reg-event-fx, reg-event-db =，前者处理多个 =coeffects</code> 返回多个= effects= ,后者只处理一个，更简单
 <code>reg-event-db</code> 格式如下
</p>
<div class="org-src-container">
<pre class="src src-clojure">(rf/reg-event-db
  :the-event-id
  the-event-handler-fn)
</pre>
</div>
</div>
</li>

<li><a id="orgb9764ca"></a>例子<br />
<div class="outline-text-5" id="text-4-2-3-3">
<ol class="org-ol">
<li>更新状态使用 <code>-&gt; =宏和</code> assoc= 函数</li>
<li>忽略参数使用下划线</li>
<li>可以对 <code>event</code> 向量直接解构</li>
</ol>

<div class="org-src-container">
<pre class="src src-clojure">(rf/reg-event-db              ;; sets up initial application state
  :initialize
  (fn [_ _]                   ;; the two parameters are not important here, so use _
    {:time (js/Date.)         ;; What it returns becomes the new application state
     :time-color "=f88"}))    ;; so the application state will initially be a map with two keys

(rf/reg-event-db
  :initialize
  (fn [db _]                 ;; we use db this time, so name it
    (-&gt; db
      (assoc :time (js/Date.))
      (assoc :time-color "=f88")))

(rf/reg-event-db                 ;; usage:  (rf/dispatch [:timer a-js-Date])
  :timer
  (fn [db [_ new-time]]          ;; &lt;-- de-structure the event vector
    (assoc db :time new-time)))  ;; compute and return the new application state

(rf/reg-event-db
  :time-color-change            ;; usage:  (rf/dispatch [:time-color-change 34562])
  (fn [db [_ new-color-value]]
    (assoc db :time-color new-color-value)))   ;; compute and return the new application state

</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7908cc3" class="outline-4">
<h4 id="org7908cc3"><span class="section-number-4">4.2.4</span> 第三步：效应处理</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
对于只是更新应用状态的简单的效应，re-frame自动进行处理，不需要写程序。
对于其他副作用，需要编写处理函数。
常见的副作用有：Ajax，数据库，服务器通信等。
</p>
</div>

<ol class="org-ol">
<li><a id="org2a5fe4d"></a>reg-event-fx:可以产生副作用的事件绑定<br />
<div class="outline-text-5" id="text-4-2-4-1">
<p>
与 <code>reg-event-db =相比，</code> -fx= 可以自己指定效应函数，语法为：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(reg-event-fx              ;; -fx registration, not -db registration
  :my-event
  (fn [cofx [_ a]]        ;; 1st argument is coeffects, instead of db
    {:db       (assoc (:db cofx) :flag  a)
     :dispatch [:do-something-else 3]}))   ;; return effects
</pre>
</div>
</div>
</li>

<li><a id="org01edab7"></a>reg-fx：定义效应处理函数<br />
<div class="outline-text-5" id="text-4-2-4-2">
<p>
效应函数只有一个输入值，以db这一内置效应函数为例，语法为：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(reg-fx
  :db
  (fn [value]
    (reset! re-frame.db/app-db value)))
</pre>
</div>

<p>
&gt; 可以看出 <code>reg-event-db</code> 只不过是一种常用的副作用函数
</p>
</div>
</li>

<li><a id="org1d12ada"></a>do-fx:执行一个副作用<br />
<div class="outline-text-5" id="text-4-2-4-3">
<div class="org-src-container">
<pre class="src src-clojure">(reg-event-fx
  :some-id
  [debug (path :right)]     ;; &lt;-- two interceptors, apparently
  (fn [cofx _]
     {})                    ;; &lt;-- imagine returned effects here

[do-fx debug (path :right)]

</pre>
</div>
</div>
</li>

<li><a id="org9531275"></a>reg-cofx与inject-cofx：初始化应用时执行副作用<br />
<div class="outline-text-5" id="text-4-2-4-4">
<p>
<code>reg-cofx =与</code> inject-cofx= 能够在应用刚刚启动时执行副作用
</p>
</div>
</li>
</ol>
</div>


<div id="outline-container-org117b003" class="outline-4">
<h4 id="org117b003"><span class="section-number-4">4.2.5</span> 第四步：订阅处理/查询函数</h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
查询函数的输入值是应用状态，返回值是查询量的值，每一次应用状态发生改变就执行一遍查询函数，由于查询之间的关系，可以创建一个查询树，根是 <code>app-db</code> 叶子是视图组件的数值
使用 <code>re-frame/reg-sub</code> 注册查询函数：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(rf/reg-sub
  :some-query-id  ;; query id (used later in subscribe)
  a-query-fn)     ;; the function which will compute the query

</pre>
</div>
<p>
简单的例子：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(rf/reg-sub
  :time
  (fn [db _]     ;; db is current app state. 2nd unused param is query vector
    (:time db))) ;; return a query computation over the application state

(rf/reg-sub
  :time-color
  (fn [db _]
    (:time-color db)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org70b1bb0" class="outline-4">
<h4 id="org70b1bb0"><span class="section-number-4">4.2.6</span> 第五步：视图函数，Reagent</h4>
<div class="outline-text-4" id="text-4-2-6">
</div>
<ol class="org-ol">
<li><a id="org4014c63"></a>subscribe定义查询量<br />
<div class="outline-text-5" id="text-4-2-6-1">
<p>
只有一个全局的函数来定义在视图中显示量 <code>re-frame/subscribe</code> ，只有一个包含查询量id的向量作为参数，返回值是一个ratom，使用@取出值，（来自Reagent）
语法为：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(rf/subscribe  [query-id some optional query parameters])

</pre>
</div>
<p>
可以将它想象成一个SQL查询
</p>
</div>
</li>
<li><a id="org8348da4"></a>定义视图函数（Reagent组件）<br />
<div class="outline-text-5" id="text-4-2-6-2">
<p>
语法与Reagent相同，只不过是加入了定义查询量的 <code>subscribe =和定义事件的</code> dispatch
例子：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn clock
  []
  [:div.example-clock
   {:style {:color @(rf/subscribe [:time-color])}}
   (-&gt; @(rf/subscribe [:time])
       .toTimeString
       (clojure.string/split " ")
       first)])

(defn color-input
  []
  [:div.color-input
   "Time color: "
   [:input {:type "text"
            :value @(rf/subscribe [:time-color])        ;; subscribe
            :on-change =(rf/dispatch [:time-color-change (-&gt; % .-target .-value)])}]])  ;; &lt;---

</pre>
</div>

<p>
&gt; 由于组件间可以继承通信，所以只需要在几个组件里有 <code>subscribe</code> 就足够了
&gt; 不要在组件中直接访问 <code>app-db =,数据只能通过</code> subscrube= 传递
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7123702" class="outline-4">
<h4 id="org7123702"><span class="section-number-4">4.2.7</span> 第六步：DOM与运行循环</h4>
<div class="outline-text-4" id="text-4-2-7">
<p>
由于DOM是由Reagent实现的，所以只需要触发初始化事件并选一个节点渲染开始就可以了
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn ^:export run
  []
  (rf/dispatch-sync [:initialize]) ;; puts a value into application state
  (reagent/render [ui]             ;; mount the application's ui into '&lt;div id="app" /&gt;'
                  (js/document.getElementById "app")))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga10762a" class="outline-3">
<h3 id="orga10762a"><span class="section-number-3">4.3</span> 其他事项</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org65946f5" class="outline-4">
<h4 id="org65946f5"><span class="section-number-4">4.3.1</span> 推荐的项目结构</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
开发顺序:
</p>
<ol class="org-ol">
<li>设计数据结构, =db.cljs</li>
<li>设计视图, =views.vljs</li>
<li>写事件处理函数, =events.cljs</li>
<li>写数据提取函数, =subs.cljs</li>
</ol>

<p>
#+END<sub>SRC</sub>
src
├── core.cljs   &lt;&#x2014; entry point, plus history
├── db.cljs     &lt;&#x2014; data related  (data layer)
├── subs.cljs   &lt;&#x2014; subscription handlers  (query layer)
├── views.cljs  &lt;&#x2014; reagent  components (view layer)
└── events.cljs &lt;&#x2014; event handlers (control/update layer)
</p>

<p>
#+END<sub>SRC</sub>
</p>
</div>
</div>


<div id="outline-container-org177b5c5" class="outline-4">
<h4 id="org177b5c5"><span class="section-number-4">4.3.2</span> 拦截器, interceptors</h4>
</div>
</div>
</div>
<div id="outline-container-org4d53cdd" class="outline-2">
<h2 id="org4d53cdd"><span class="section-number-2">5</span> reagent</h2>
<div class="outline-text-2" id="text-5">
<p>
reagent是clojurescript上对reagent的一个封装，使用了类似hiccup的语法
</p>
</div>
<div id="outline-container-org4464bdc" class="outline-3">
<h3 id="org4464bdc"><span class="section-number-3">5.1</span> 安装与配置</h3>
<div class="outline-text-3" id="text-5-1">
<ol class="org-ol">
<li>在shadow-cljs配置中加入 =[reagent "0.8.0-alpha2"]</li>
<li>引用 =(ns app.core (:require [reagent.core :as r]))</li>
</ol>
</div>
</div>

<div id="outline-container-org09fb2c0" class="outline-3">
<h3 id="org09fb2c0"><span class="section-number-3">5.2</span> 基本语法</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-orgc90d7c9" class="outline-4">
<h4 id="orgc90d7c9"><span class="section-number-4">5.2.1</span> 组件</h4>
<div class="outline-text-4" id="text-5-2-1">
</div>
<ol class="org-ol">
<li><a id="org82e6a84"></a>组件的定义<br />
<div class="outline-text-5" id="text-5-2-1-1">
<p>
组件在形式上就是一个函数,内部是用方括号嵌套表示的html标签
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn some-component []
  [:div
   [:h3 "I am a component!"]
   [:p.someclass 
    "I have " [:strong "bold"]
    [:span {:style {:color "red"}} " and red"]
    " text."]])
</pre>
</div>
<p>
嵌套标签可以快捷表示
</p>
<div class="org-src-container">
<pre class="src src-clojure">[:div&gt;p&gt;b "Nested Element"]
</pre>
</div>
<p>
class也可以嵌套表示
</p>
<div class="org-src-container">
<pre class="src src-clojure">[:div {:class ["a-class" (when active? "active") "b-class"]}]
</pre>
</div>
</div>
</li>

<li><a id="orga57eb9c"></a>组件的调用和传参<br />
<div class="outline-text-5" id="text-5-2-1-2">
<p>
由于组件就是个函数，所以可以像使用函数那样传递参数，不过用中括号而不是小括号
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn child [name]
  [:p "Hi, I am " name])

(defn childcaller []
  [child "Foo Bar"])
</pre>
</div>
</div>
</li>

<li><a id="org71a62f1"></a>可以用的标签<br />
<div class="outline-text-5" id="text-5-2-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">标签</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:div</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:h1</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:p</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:strong</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:span</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:style</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>:class</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-org673f8d1" class="outline-4">
<h4 id="org673f8d1"><span class="section-number-4">5.2.2</span> DOM渲染</h4>
<div class="outline-text-4" id="text-5-2-2">
</div>
<ol class="org-ol">
<li><a id="orgc7c8b2a"></a>render函数<br />
<div class="outline-text-5" id="text-5-2-2-1">
<p>
使用 <code>reagent/render =函数，第一个参数是调用组件</code> [component]= ,第二个参数是DOM元素
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn mountit []
  (r/render [childcaller]
            (.-body js/document)))
(defn ^:export main [] ) ;使用export可以将函数暴漏出去，可以在页面的js里调用
</pre>
</div>
</div>
</li>

<li><a id="org6fa4949"></a>获取元素的方法<br />
<div class="outline-text-5" id="text-5-2-2-2">
<p>
使用js的document函数
</p>
<div class="org-src-container">
<pre class="src src-clojure">(.-body js/document)  
(.getElementById js/document "app")
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgcda93de" class="outline-4">
<h4 id="orgcda93de"><span class="section-number-4">5.2.3</span> 页面状态</h4>
<div class="outline-text-4" id="text-5-2-3">
</div>
<ol class="org-ol">
<li><a id="orgf1dd057"></a>reagent.core/atom<br />
<div class="outline-text-5" id="text-5-2-3-1">
<p>
使用reagent版的atom表示页面状态
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defonce click-count (r/atom 0)) ;定义一个atom

(defn state-ful-with-atom []
  [:div {:on-click =(swap! click-count inc)}  ;在组件中对atom的值进行更改
   "I have been clicked " @click-count " times."]) ;引用atom的值

</pre>
</div>
</div>
</li>
<li><a id="org9b7cbca"></a>初次定义时进行设置<br />
<div class="outline-text-5" id="text-5-2-3-2">
<div class="org-src-container">
<pre class="src src-clojure">(defn timer-component []
  (let [seconds-elapsed (r/atom 0)]
    (fn []
      (js/setTimeout =(swap! seconds-elapsed inc) 1000)
      [:div
       "Seconds Elapsed: " @seconds-elapsed])))

</pre>
</div>
</div>
</li>

<li><a id="orgd9af614"></a>使用React生命循环反馈<br />
<div class="outline-text-5" id="text-5-2-3-3">
<div class="org-src-container">
<pre class="src src-clojure">(defonce my-html (r/atom ""))

(defn plain-component []
  [:p "My html is " @my-html])

(def component-with-callback
  (with-meta plain-component
    {:component-did-mount
     (fn [this]
       (reset! my-html (.-innerHTML (reagent/dom-node this))))}))
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgcb226a0" class="outline-2">
<h2 id="orgcb226a0"><span class="section-number-2">6</span> secretary</h2>
<div class="outline-text-2" id="text-6">
<p>
secretary是clojurescript的前端路由库，虽然三年没更新过，但是由于前端路由只是Google Closure Histroy的封装，对于一般的应用足够了，实在特殊的话就用直接用原生JS。
</p>
</div>
<div id="outline-container-org6e6e01d" class="outline-3">
<h3 id="org6e6e01d"><span class="section-number-3">6.1</span> 安装与引用</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-orge4dcc08" class="outline-4">
<h4 id="orge4dcc08"><span class="section-number-4">6.1.1</span> 依赖</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
#+END<sub>SRC</sub>
   [secretary "1.2.3"]
#+END<sub>SRC</sub>
</p>
</div>
</div>
<div id="outline-container-orge355ca5" class="outline-4">
<h4 id="orge355ca5"><span class="section-number-4">6.1.2</span> 引用</h4>
<div class="outline-text-4" id="text-6-1-2">
<div class="org-src-container">
<pre class="src src-clojure">(ns app.routes
  (:require [secretary.core :as secretary :refer-macros [defroute]]))

;; 如果需要用原生库
(ns app.routes 
  (:require [secretary.core :as secretary]
            [goog.events :as events])
  (:require-macros [secretary.core :refer [defroute]])
  (:import goog.History
           goog.history.EventType))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8b9bc34" class="outline-3">
<h3 id="org8b9bc34"><span class="section-number-3">6.2</span> 基本使用</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org6dd0bc2" class="outline-4">
<h4 id="org6dd0bc2"><span class="section-number-4">6.2.1</span> html</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
在网页中只需要写出链接地址就可以，剩下的由路由解决
</p>
<div class="org-src-container">
<pre class="src src-html">    &lt;<span style="color: #268bd2;">a</span> <span style="color: #268bd2;">href</span>=<span style="color: #2aa198;">"=/users/jim"</span>&gt;Jim&lt;/<span style="color: #268bd2;">a</span>&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-org2c02992" class="outline-4">
<h4 id="org2c02992"><span class="section-number-4">6.2.2</span> 源文件</h4>
<div class="outline-text-4" id="text-6-2-2">
</div>
<ol class="org-ol">
<li><a id="org172b141"></a>设置显示井号<br />
<div class="outline-text-5" id="text-6-2-2-1">
<div class="org-src-container">
<pre class="src src-clojure">(secretary/set-config! :prefix "=")

</pre>
</div>
</div>
</li>

<li><a id="orgd4dc7a2"></a>定义路由<br />
<div class="outline-text-5" id="text-6-2-2-2">
<p>
要把每一个页面都进行一次定义，写出名字（可选）、绝对地址（可用正则表达式）、要传入的参数
和这个地址要执行的函数
</p>
<div class="org-src-container">
<pre class="src src-clojure">;; /=/users/:id
(defroute user-path "/users/:id" [id]
  (let [message (str "&lt;h1&gt;HELLO USER &lt;small&gt;" id "&lt;/small&gt;!&lt;/h1&gt;")]
    (set-html! application message)))
</pre>
</div>
</div>
</li>

<li><a id="org2bbfca4"></a>设置默认地址（404）<br />
<div class="outline-text-5" id="text-6-2-2-3">
<div class="org-src-container">
<pre class="src src-clojure">;; Catch all
(defroute "*" []
  (set-html! application "&lt;h1&gt;LOL! YOU LOST!&lt;/h1&gt;"))
</pre>
</div>
</div>
</li>

<li><a id="orgbacd671"></a>配置历史<br />
<div class="outline-text-5" id="text-6-2-2-4">
<div class="org-src-container">
<pre class="src src-clojure">;; Quick and dirty history configuration.
(let [h (History.)]
  (goog.events/listen h EventType.NAVIGATE =(secretary/dispatch! (.-token %)))
  (doto h
    (.setEnabled true)))
</pre>
</div>
</div>
</li>

<li><a id="orgadbaf14"></a>设置首页<br />
<div class="outline-text-5" id="text-6-2-2-5">
<div class="org-src-container">
<pre class="src src-clojure">(secretary/dispatch! "/")
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgb1dff13" class="outline-2">
<h2 id="orgb1dff13"><span class="section-number-2">7</span> shadow-cljs</h2>
<div class="outline-text-2" id="text-7">
<p>
shadow-cljs是clojurescript的打包编译工具，类似webpack
</p>
</div>
<div id="outline-container-orge82e70c" class="outline-3">
<h3 id="orge82e70c"><span class="section-number-3">7.1</span> 安装</h3>
<div class="outline-text-3" id="text-7-1">
<ol class="org-ol">
<li>npm全局 <code>npm install -g shadow-cljs</code></li>
<li>目录结构与一般cljs项目相同</li>
</ol>
</div>
</div>

<div id="outline-container-orgd00543e" class="outline-3">
<h3 id="orgd00543e"><span class="section-number-3">7.2</span> 编译</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-orgeb98f73" class="outline-4">
<h4 id="orgeb98f73"><span class="section-number-4">7.2.1</span> 配置</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
文件 <code>shadow-cljs.edn =,或使用</code> shadow-cljs init= 自动生成
</p>
<div class="org-src-container">
<pre class="src src-clojure">{:source-paths ["src"]                                                 ;; 源文件目录
 :dependencies [[binaryage/devtools "0.9.8"]                           ;; 热替换必须依赖
               ]                                                       ;; 依赖
 :http {:host "localhost" :port 8081}                                  ;; 启动项目管理网页
 :builds {:app {:output-dir "public/js"                                ;; 生成文件目录
                :asset-path "js"                                       ;; 资源存储路径，相对于output目录
                :target :browser                                       ;; 编译目标：浏览器
                :modules {:main {:entries [app.core]}}                 ;; 入口文件，这里是src/app/core.cljs
                :devtools {:http-handler shadow.http.push-state/handle ;; 启用内置http server，watch模式必须
                          :http-root "public"                          ;; 设置根目录
                          :autoload true                               ;; 开启热替换
                          :preloads [app.core]                         ;; 加载名字空间
                          :after-load app.core/reload!                 ;; 在加载js后自动刷新页面，见下方设置
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f0aace" class="outline-4">
<h4 id="org7f0aace"><span class="section-number-4">7.2.2</span> 命令</h4>
<div class="outline-text-4" id="text-7-2-2">
<div class="org-src-container">
<pre class="src src-clojure">shadow-cljs compile app         ;; 直接编译
shadow-cljs release app         ;; 编译, 加上代码优化, 比如混淆/清除 dead code
shadow-cljs watch app           ;; 热替换
shadow-cljs cljs-repl app       ;; 有 watch 服务的情况下, 再启动一个连接到浏览器的 REPL
shadow-cljs check app           ;; 进行 release 之前可以做一些检查
shadow-cljs release app --debug ;; 生成 release 的代码, 同时生成 SourceMaps 等用于调试
</pre>
</div>
</div>
</div>

<div id="outline-container-org7046a32" class="outline-4">
<h4 id="org7046a32"><span class="section-number-4">7.2.3</span> 编译目标</h4>
<div class="outline-text-4" id="text-7-2-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">命令</td>
<td class="org-left">目标</td>
<td class="org-left">应用</td>
</tr>

<tr>
<td class="org-left">:browser</td>
<td class="org-left">浏览器使用的代码</td>
<td class="org-left">类似webpack</td>
</tr>

<tr>
<td class="org-left">:nodejs</td>
<td class="org-left">Node.js 开发</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">:node-library</td>
<td class="org-left">可以被 Node.js 调用的模块</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">:npm-module</td>
<td class="org-left">遵循 CommonJS 语法的一个个独立的 js 文件</td>
<td class="org-left">兼容模式，生成的代码可被webpack使用</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4d6cd6d" class="outline-4">
<h4 id="org4d6cd6d"><span class="section-number-4">7.2.4</span> 使用npm模块</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
在 <code>:browser</code> 编译目标里使用npm
</p>
<div class="org-src-container">
<pre class="src src-clojure">(ns app.main
  (:require ["hsl" :as hsl]))

(hsl 200 80 80)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org17e6341" class="outline-3">
<h3 id="org17e6341"><span class="section-number-3">7.3</span> 注意事项与技巧</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org1d90999" class="outline-4">
<h4 id="org1d90999"><span class="section-number-4">7.3.1</span> om 与 reagent</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
不用纠结选择哪个了，om在shadow-cljs中存在bug不能用，只能用reagent
</p>
</div>
</div>

<div id="outline-container-org9f9e3a7" class="outline-4">
<h4 id="org9f9e3a7"><span class="section-number-4">7.3.2</span> 加载后自动刷新</h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
在 <code>app.core</code> 中定义函数
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn reload! [] (.reload js/location))

</pre>
</div>
</div>
</div>

<div id="outline-container-org28ca147" class="outline-4">
<h4 id="org28ca147"><span class="section-number-4">7.3.3</span> 开启控制台调试输出</h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
在 <code>app.core</code> 中加入
</p>
<div class="org-src-container">
<pre class="src src-clojure">(enable-console-print!)
(println "some thing")

</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-09-27 Sun 17:23</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
