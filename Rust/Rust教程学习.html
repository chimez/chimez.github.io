<!doctype html>
<html lang="zh-cn">
	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

		<!-- Template -->
		<link rel="Stylesheet" type="text/css" href="../css/main.css" />
		<title>Rust教程学习</title>
	</head>

	<body>
		<div class="container">

			<nav class="navbar navbar-expand-lg sticky-top navbar-light bg-light">
				<a class="navbar-brand" href="../index.html">Chimez</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>

				<div class="collapse navbar-collapse" id="navbarTogglerDemo02">
					<ul class="navbar-nav mr-auto mt-2 mt-lg-0">
						<li class="nav-item active">
							<a class="nav-link" href="../articles_index.html">文章列表 <span class="sr-only">(current)</span></a>
					</ul>
					<form class="form-inline my-2 my-lg-0">
						<input class="form-control mr-sm-2" type="search" placeholder="Search">
						<button class="btn btn-outline-success my-2 my-sm-0" type="button">Search</button>
					</form>
				</div>
			</nav>

			<div class="row">
				
<p>
<div class="col-md-3 article-toc d-none d-md-block">
</p>
<div id="Contents" class="toc"><h1 id="Contents">Contents</h1></div>
<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念">Rust教程学习:基本概念</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-基本程序结构">基本程序结构</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-基本程序结构-主函数:程序运行的入口">主函数:程序运行的入口</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-基本程序结构-引入外部类型">引入外部类型</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-基本程序结构-引入外部依赖">引入外部依赖</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-变量与常量">变量与常量</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-变量与常量-创建变量">创建变量</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-变量与常量-创建常量">创建常量</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-变量与常量-变量的隐藏(shadow)">变量的隐藏(shadow)</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-变量与常量-引用&amp;">引用&amp;</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型">数据类型</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-类型操作">类型操作</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-类型操作-默认类型参数">默认类型参数</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-原生类型">原生类型</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-原生类型-字面量数据类型">字面量数据类型</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-原生类型-元组">元组</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-原生类型-数组array">数组array</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-原生类型-slice">slice</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-结构体(struct)">结构体(struct)</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-结构体(struct)-结构体的定义与引用">结构体的定义与引用</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-结构体(struct)-结构体简化初始化写法">结构体简化初始化写法</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-结构体(struct)-结构体更新语法">结构体更新语法</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-结构体(struct)-无字段名的结构体">无字段名的结构体</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-枚举enum">枚举enum</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-枚举enum-定义枚举">定义枚举</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-枚举enum-空值枚举Option&lt;T&gt;">空值枚举Option&lt;T&gt;</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-通用集合类型">通用集合类型</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-通用集合类型-向量(vector)">向量(vector)</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-通用集合类型-字符串(String)">字符串(String)</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-数据类型-通用集合类型-哈希(hash map)">哈希(hash map)</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法">函数与方法</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-函数定义">函数定义</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-函数调用">函数调用</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-发散函数">发散函数</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-方法">方法</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-方法-定义方法">定义方法</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-方法-关联函数::">关联函数::</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-函数与方法-错误处理类型Result">错误处理类型Result</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑">逻辑</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-match:分支匹配">match:分支匹配</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-if let:单支匹配">if let:单支匹配</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-模式:用于值的匹配">模式:用于值的匹配</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-模式:用于值的匹配-使用模式的位置">使用模式的位置</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-模式:用于值的匹配-匹配语法">匹配语法</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-loop:无限循环">loop:无限循环</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-break:跳出循环">break:跳出循环</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-continue:到标签循环">continue:到标签循环</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-if:条件判断">if:条件判断</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-while:条件为真时循环">while:条件为真时循环</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-for:遍历列表">for:遍历列表</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-错误处理">错误处理</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-错误处理-panic!:不可恢复错误(bug)">panic!:不可恢复错误(bug)</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-错误处理-Result:可恢复错误">Result:可恢复错误</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-错误处理-当错误时进行panic!">当错误时进行panic!</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-逻辑-错误处理-传播错误:让调用者知道错误是什么">传播错误:让调用者知道错误是什么</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)">所有权(ownership)</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-所有权概念">所有权概念</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-引用(reference)">引用(reference)</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期">生命周期</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期注解">生命周期注解</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期-方法生命周期">方法生命周期</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期-静态生命周期">静态生命周期</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期子类型">生命周期子类型</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期约束">生命周期约束</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-模块">模块</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-模块-定义库项目与模块">定义库项目与模块</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-模块-公有与私有">公有与私有</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-模块-引入到作用域">引入到作用域</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型">泛型</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-定义与使用泛型">定义与使用泛型</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口">trait:不同类型的共同方法实现接口</a>

<ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-声明trait">声明trait</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-实现trait">实现trait</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-应用trait">应用trait</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-trait继承">trait继承</a>

</ul>
<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-关联类型">关联类型</a>

<li>
<a href="Rust教程学习.html#Rust教程学习:基本概念-泛型-运算符重载">运算符重载</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#进阶知识">进阶知识</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-测试">测试</a>

<li>
<a href="Rust教程学习.html#进阶知识-函数式">函数式</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-函数式-闭包:匿名函数">闭包:匿名函数</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-函数式-闭包:匿名函数-基本语法">基本语法</a>

<li>
<a href="Rust教程学习.html#进阶知识-函数式-闭包:匿名函数-闭包的泛型trait">闭包的泛型trait</a>

<li>
<a href="Rust教程学习.html#进阶知识-函数式-闭包:匿名函数-move:闭包获得所有权">move:闭包获得所有权</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#进阶知识-迭代器">迭代器</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-迭代器-使用迭代器">使用迭代器</a>

<li>
<a href="Rust教程学习.html#进阶知识-迭代器-自定义迭代器">自定义迭代器</a>

</ul>
<li>
<a href="Rust教程学习.html#进阶知识-智能指针">智能指针</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-智能指针-Box&lt;T&gt;:堆上存储数据">Box&lt;T&gt;:堆上存储数据</a>

<li>
<a href="Rust教程学习.html#进阶知识-智能指针-自定义智能指针">自定义智能指针</a>

<li>
<a href="Rust教程学习.html#进阶知识-智能指针-Rc&lt;T&gt;:单线程引用计数指针">Rc&lt;T&gt;:单线程引用计数指针</a>

<li>
<a href="Rust教程学习.html#进阶知识-智能指针-RefCell&lt;T&gt;:内部可变模式">RefCell&lt;T&gt;:内部可变模式</a>

<li>
<a href="Rust教程学习.html#进阶知识-智能指针-Weak&lt;T&gt;:弱引用计数指针">Weak&lt;T&gt;:弱引用计数指针</a>

</ul>
<li>
<a href="Rust教程学习.html#进阶知识-并发与并行">并发与并行</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-并发与并行-线程">线程</a>

<li>
<a href="Rust教程学习.html#进阶知识-并发与并行-线程通信">线程通信</a>

<li>
<a href="Rust教程学习.html#进阶知识-并发与并行-共享状态">共享状态</a>

<li>
<a href="Rust教程学习.html#进阶知识-并发与并行-Rust语言内的并发trait">Rust语言内的并发trait</a>

</ul>
<li>
<a href="Rust教程学习.html#进阶知识-面向对象">面向对象</a>

<li>
<a href="Rust教程学习.html#进阶知识-属性">属性</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-属性-derive:自动实现一些泛型方法">derive:自动实现一些泛型方法</a>

<li>
<a href="Rust教程学习.html#进阶知识-属性-过程宏">过程宏</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-属性-过程宏-创建过程宏">创建过程宏</a>

<li>
<a href="Rust教程学习.html#进阶知识-属性-过程宏-使用过程宏">使用过程宏</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#进阶知识-宏">宏</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-宏-语法">语法</a>

<li>
<a href="Rust教程学习.html#进阶知识-宏-指示符">指示符</a>

</ul>
<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust">不安全的Rust</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-裸指针">裸指针</a>

<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-unsafe">unsafe</a>

<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-创建安全抽象">创建安全抽象</a>

<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-ffi:与C交互">ffi:与C交互</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-ffi:与C交互-调用外部函数">调用外部函数</a>

<li>
<a href="Rust教程学习.html#进阶知识-不安全的Rust-ffi:与C交互-导出接口到C">导出接口到C</a>

</ul>
</ul>
<li>
<a href="Rust教程学习.html#进阶知识-高级函数">高级函数</a>

<ul>
<li>
<a href="Rust教程学习.html#进阶知识-高级函数-fn(T):函数指针">fn(T):函数指针</a>

<li>
<a href="Rust教程学习.html#进阶知识-高级函数-返回闭包">返回闭包</a>

</ul>
</ul>
</ul>

<p>
</div>
<div class="col-md-9 article-main">
</p>
<div id="Rust教程学习:基本概念"><h1 id="Rust教程学习:基本概念">Rust教程学习:基本概念</h1></div>
<div id="Rust教程学习:基本概念-基本程序结构"><h2 id="基本程序结构">基本程序结构</h2></div>
<div id="Rust教程学习:基本概念-基本程序结构-主函数:程序运行的入口"><h3 id="主函数:程序运行的入口">主函数:程序运行的入口</h3></div>
<pre class="rust">
fn main(){
}
</pre>
<div id="Rust教程学习:基本概念-基本程序结构-引入外部类型"><h3 id="引入外部类型">引入外部类型</h3></div>
<p>
在源文件的开头
</p>
<pre class="rust">
use std::io
...
io::stdin()
</pre>
<div id="Rust教程学习:基本概念-基本程序结构-引入外部依赖"><h3 id="引入外部依赖">引入外部依赖</h3></div>
<pre class="rust">
extern crate rand
use rand::io

</pre>
<div id="Rust教程学习:基本概念-变量与常量"><h2 id="变量与常量">变量与常量</h2></div>
<div id="Rust教程学习:基本概念-变量与常量-创建变量"><h3 id="创建变量">创建变量</h3></div>
<pre class="rust">
let foo = 5; //默认不可变
let mut bar = 5; //声明可变
</pre>
<div id="Rust教程学习:基本概念-变量与常量-创建常量"><h3 id="创建常量">创建常量</h3></div>
<ul>
<li>
按照规则常量全大写,而且常量不可变

<li>
<code>const</code>常量会在编译时内联,内存地址不定

<li>
<code>static</code>常量编译时固定指针,内存地址固定

<li>
<code>const</code>常量绝对不可变

<li>
<code>static mut</code>可变,但要用<code>unsafe</code>
<pre class="rust">
const MA_B: u32 = 100;
static N: i32 = 5;
</pre>

</ul>
<div id="Rust教程学习:基本概念-变量与常量-变量的隐藏(shadow)"><h3 id="变量的隐藏(shadow)">变量的隐藏(shadow)</h3></div>
<p>
对同一个变量名重新定义时,不会出错只会使第一个变量被后来的隐藏,如果使用<code>:</code>声明类型,则不同类型可以共用同一个变量名
</p>
<div id="Rust教程学习:基本概念-变量与常量-引用&amp;"><h3 id="引用&amp;">引用&amp;</h3></div>
<pre class="rust">
&amp;foo //默认不可变
&amp;mut bar //声明可变
</pre>
<div id="Rust教程学习:基本概念-数据类型"><h2 id="数据类型">数据类型</h2></div>
<div id="Rust教程学习:基本概念-数据类型-类型操作"><h3 id="类型操作">类型操作</h3></div>
<table>
<tr>
<td>
<code>type a=i32</code>
</td>
<td>
类型别名
</td>
</tr>
<tr>
<td>
<code>强制转换</code>
</td>
<td>
无显示语法,在调用参数,定义变量和返回参数时自动进行
</td>
</tr>
<tr>
<td>
<code>let y = x as i64;</code>
</td>
<td>
安全类型转换,安全的意思是如果编译器认为这个转换不安全就不给你编译
</td>
</tr>
<tr>
<td>
<code>mem::transmute::&lt;[u8; 4], u32&gt;(a);</code>
</td>
<td>
不安全的强制转换,需要<code>unsafe</code>
</td>
</tr>
<tr>
<td>
<code>trait A{type N}</code>
</td>
<td>
关联类型,用<code>type</code>可以声明一个抽象的类型,等到后面实现具体方法时再进行实现
</td>
</tr>
<tr>
<td>
<code>struct Foo&lt;T: ?Sized&gt; {}</code>
</td>
<td>
不定长类型,动态大小类型
</td>
</tr>
<tr>
<td>
<code>A&lt;RHS=B&gt;</code>
</td>
<td>
默认类型参数
</td>
</tr>
<tr>
<td>
<code>A&lt;!&gt;</code>
</td>
<td>
发散类型,或者叫任意类型
</td>
</tr>
</table>

<div id="Rust教程学习:基本概念-数据类型-类型操作-默认类型参数"><h4 id="默认类型参数">默认类型参数</h4></div>
<pre class="rust">

trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
</pre>
<div id="Rust教程学习:基本概念-数据类型-原生类型"><h3 id="原生类型">原生类型</h3></div>
<div id="Rust教程学习:基本概念-数据类型-原生类型-字面量数据类型"><h4 id="字面量数据类型">字面量数据类型</h4></div>
<table>
<tr>
<td>
<code>i32</code>
</td>
<td>
32位有符号数,9i32
</td>
</tr>
<tr>
<td>
<code>u32</code>
</td>
<td>
32位无符号数,-8u32
</td>
</tr>
<tr>
<td>
<code>f64</code>
</td>
<td>
64位双精度浮点数,3.4f64
</td>
</tr>
<tr>
<td>
<code>bool</code>
</td>
<td>
布尔类型,'false'
</td>
</tr>
<tr>
<td>
<code>char</code>
</td>
<td>
utf8字符,'三'
</td>
</tr>
</table>

<div id="Rust教程学习:基本概念-数据类型-原生类型-元组"><h4 id="元组">元组</h4></div>
<pre class="rust">
let tup: (i32, f64, u8) = (500 ,5, 1) //定义
let (x, y, z) = tup	//解构
tup.0 //直接访问
</pre>
<div id="Rust教程学习:基本概念-数据类型-原生类型-数组array"><h4 id="数组array">数组array</h4></div>
<p>
长度不可变,每个元素类型必须相同,当引用越界时会产生运行时错误,而不会访问外部内存
</p>
<pre class="rust">
let a = [1,2,3];//声明
a[0]//引用
&amp;a[0..1]//slide引用
</pre>

<div id="Rust教程学习:基本概念-数据类型-原生类型-slice"><h4 id="slice">slice</h4></div>
<p>
获得字符串/数组的一部分,只是引用,如果不加引用将得到所有权,会出错
</p>
<pre class="rust">
&amp;str
&amp;"ssss"[0..2]
</pre>

<div id="Rust教程学习:基本概念-数据类型-结构体(struct)"><h3 id="结构体(struct)">结构体(struct)</h3></div>
<div id="Rust教程学习:基本概念-数据类型-结构体(struct)-结构体的定义与引用"><h4 id="结构体的定义与引用">结构体的定义与引用</h4></div>
<pre class="rust">
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};


user1.email = String::from("anotheremail@example.com");
</pre>
<div id="Rust教程学习:基本概念-数据类型-结构体(struct)-结构体简化初始化写法"><h4 id="结构体简化初始化写法">结构体简化初始化写法</h4></div>
<p>
当变量名与结构体字段同名时可用
</p>

<pre class="rust">
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
</pre>
<div id="Rust教程学习:基本概念-数据类型-结构体(struct)-结构体更新语法"><h4 id="结构体更新语法">结构体更新语法</h4></div>
<p>
可以从一个旧的结构体继承大部分数据
</p>
<pre class="rust">
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
</pre>

<div id="Rust教程学习:基本概念-数据类型-结构体(struct)-无字段名的结构体"><h4 id="无字段名的结构体">无字段名的结构体</h4></div>
<pre class="rust">

struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</pre>

<div id="Rust教程学习:基本概念-数据类型-枚举enum"><h3 id="枚举enum">枚举enum</h3></div>
<div id="Rust教程学习:基本概念-数据类型-枚举enum-定义枚举"><h4 id="定义枚举">定义枚举</h4></div>
<p>
枚举列出了所有可能的取值
</p>
<pre class="rust">

enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
</pre>
<div id="Rust教程学习:基本概念-数据类型-枚举enum-空值枚举Option&lt;T&gt;"><h4 id="空值枚举Option&lt;T&gt;">空值枚举Option&lt;T&gt;</h4></div>
<p>
一个量要么是某类型的,要么什么都不是
</p>
<pre class="rust">

enum Option&lt;T&gt; {
    Some(T),
    None,
};
</pre>

<div id="Rust教程学习:基本概念-数据类型-通用集合类型"><h3 id="通用集合类型">通用集合类型</h3></div>
<div id="Rust教程学习:基本概念-数据类型-通用集合类型-向量(vector)"><h4 id="向量(vector)">向量(vector)</h4></div>
<table>
<tr>
<td>
<code>let v: Vec&lt;i32&gt; = Vec::new();</code>
</td>
<td>
新建空的向量
</td>
</tr>
<tr>
<td>
<code>let v = vec![1, 2, 3];</code>
</td>
<td>
新建带初值的向量
</td>
</tr>
<tr>
<td>
<code>v.push(5);</code>
</td>
<td>
添加元素(要求是可变的)
</td>
</tr>
<tr>
<td>
<code>let third: &amp;i32 = &amp;v[2];</code>
</td>
<td>
引用序号,越界将崩溃
</td>
</tr>
<tr>
<td>
<code>let third: Option&lt;&amp;i32&gt; = v.get(2);</code>
</td>
<td>
引用序号,越界错误处理
</td>
</tr>
<tr>
<td>
<code>for i in &amp;v {}</code>
</td>
<td>
遍历向量
</td>
</tr>
</table>

<div id="Rust教程学习:基本概念-数据类型-通用集合类型-字符串(String)"><h4 id="字符串(String)">字符串(String)</h4></div>

<table>
<tr>
<td>
<code>let mut s = String::new();</code>
</td>
<td>
新建空字符串
</td>
</tr>
<tr>
<td>
<code>let s = String::from("initial contents");</code>
</td>
<td>
新建初值字符串
</td>
</tr>
<tr>
<td>
<code>s.push_str("bar");</code>
</td>
<td>
追加字符串
</td>
</tr>
<tr>
<td>
<code>s.push('l');</code>
</td>
<td>
追加字符
</td>
</tr>
<tr>
<td>
<code>let s3 = s1 + &amp;s2;</code>
</td>
<td>
字符串连接
</td>
</tr>
<tr>
<td>
<code>let s = format!("{}-{}-{}", s1, s2, s3);</code>
</td>
<td>
复杂字符串连接
</td>
</tr>
<tr>
<td>
<code>for c in "नमस्ते".chars() {}</code>
</td>
<td>
字符串遍历
</td>
</tr>
</table>

<div id="Rust教程学习:基本概念-数据类型-通用集合类型-哈希(hash map)"><h4 id="哈希(hash map)">哈希(hash map)</h4></div>

<table>
<tr>
<td>
<code>use std::collections::HashMap;</code>
</td>
<td>
必须先从标准库引入HashMap
</td>
</tr>
<tr>
<td>
<code>let mut scores = HashMap::new();</code>
</td>
<td>
新建空map,不存在初始化宏
</td>
</tr>
<tr>
<td>
<code>scores.insert(String::from("Blue"), 10);</code>
</td>
<td>
插入新项,或覆盖旧的
</td>
</tr>
<tr>
<td>
<code>let score = scores.get(&amp;team_name);</code>
</td>
<td>
获得键值
</td>
</tr>
<tr>
<td>
<code>for (key, value) in &amp;scores {}</code>
</td>
<td>
遍历map
</td>
</tr>
<tr>
<td>
<code>scores.entry(String::from("Yellow")).or_insert(50);</code>
</td>
<td>
只插入新的,不会覆盖
</td>
</tr>
</table>

<div id="Rust教程学习:基本概念-函数与方法"><h2 id="函数与方法">函数与方法</h2></div>
<div id="Rust教程学习:基本概念-函数与方法-函数定义"><h3 id="函数定义">函数定义</h3></div>
<ul>
<li>
在源文件的任何地方都可以定义函数,不需要在开头声明,函数参数和返回值必须指定类型

<li>
不加分号的语句会产生返回值

</ul>

<pre class="rust">
fn foo(x:i32) -&gt; i32{
	x
}
</pre>
<div id="Rust教程学习:基本概念-函数与方法-函数调用"><h3 id="函数调用">函数调用</h3></div>
<ul>
<li>
函数名加括号是一般的调用方法<code>f()</code>

<li>
对象方法调用用点<code>a.f()</code>

<li>
关联函数(静态方法)调用用两冒号<code>a::f()</code>

<li>
指定泛型方法调用用尖括号语法<code>&lt;type as trait&gt;::f()</code>

</ul>
<div id="Rust教程学习:基本概念-函数与方法-发散函数"><h3 id="发散函数">发散函数</h3></div>
<p>
可以定义无返回值的函数,因为无返回值也可以认为是任何返回值的
</p>
<pre class="rust">
fn diverges() -&gt; ! {
   panic!("This function never returns!");
}
let x: i32 = diverges();
let x: String = diverges();

</pre>
<div id="Rust教程学习:基本概念-函数与方法-方法"><h3 id="方法">方法</h3></div>
<div id="Rust教程学习:基本概念-函数与方法-方法-定义方法"><h4 id="定义方法">定义方法</h4></div>
<p>
方法是结构体的专有函数,先定义结构体再定义方法,方法的第一个参数总是<code>&amp;self</code>
</p>
<pre class="rust">
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

r.area()
</pre>
<div id="Rust教程学习:基本概念-函数与方法-方法-关联函数::"><h4 id="关联函数::">关联函数::</h4></div>
<p>
关联函数是<code>&amp;self</code>不作为参数的函数,静态方法
</p>
<pre class="rust">
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
io::stdin() //两冒号表示与类型有关的函数,关联函数,静态方法
</pre>
<div id="Rust教程学习:基本概念-函数与方法-错误处理类型Result"><h3 id="错误处理类型Result">错误处理类型Result</h3></div>
<p>
标准库中很多函数的返回值都是<code>s::Result</code>类型,可取的成员有<code>Ok</code>,<code>Err</code>,方法<code>expect()</code>导致程序崩溃并输出字符串
</p>
<pre class="rust">
io::Result.expect("s")
</pre>

<div id="Rust教程学习:基本概念-逻辑"><h2 id="逻辑">逻辑</h2></div>
<div id="Rust教程学习:基本概念-逻辑-match:分支匹配"><h3 id="match:分支匹配">match:分支匹配</h3></div>
<p>
对于枚举类型进行匹配,表达式的值与每个分支相匹配,必须穷尽所有可能全都列出来,用<code>_</code>表示默认匹配
</p>
<pre class="rust">
match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
		_ =&gt; None
};
}
</pre>

<div id="Rust教程学习:基本概念-逻辑-if let:单支匹配"><h3 id="if let:单支匹配">if let:单支匹配</h3></div>
<p>
当对枚举进行分支匹配时,只想考虑一种情况,使用这个
</p>
<pre class="rust">

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
</pre>

<div id="Rust教程学习:基本概念-逻辑-模式:用于值的匹配"><h3 id="模式:用于值的匹配">模式:用于值的匹配</h3></div>
<div id="Rust教程学习:基本概念-逻辑-模式:用于值的匹配-使用模式的位置"><h4 id="使用模式的位置">使用模式的位置</h4></div>
<ul>
<li>
<code>match</code>

<li>
<code>if let</code>

<li>
<code>while let</code>

<li>
<code>for</code>

<li>
<code>let</code>

<li>
函数参数

</ul>
<p>
注意所谓的refutable,也就是<code>let</code>与<code>if let</code>的区别,一个能处理匹配失效,一个不能
</p>
<div id="Rust教程学习:基本概念-逻辑-模式:用于值的匹配-匹配语法"><h4 id="匹配语法">匹配语法</h4></div>
<pre class="rust">
	match x {
	1 =&gt; println!("s")	//直接匹配单个值
	2 | 3 =&gt; println!("s") //竖线是或
	4 ... 10 =&gt; println!("s") //三个点用来匹配范围
	'a' ... 'j' =&gt; println("s") //字符也可以匹配范围
	_ =&gt; println!("s")	//匹配其他值
	Some(_) =&gt; println!("s")//下划线可以忽略部分值
	Some(ref a) =&gt; println!("s")//使用ref匹配引用,防止获得所有权
	Some(n) if n==2 =&gt; println!("s") //使用if进行有条件的匹配
	id @ 3 .. 7 =&gt; println!(id)//使用@绑定匹配值,在匹配后还能用这个值
	}
	
let {x,y} = {x:1, y:2}	//第一种匹配方式
x==1;y==2;
let {x:a, y:b} = {x:1, y:2}//指定名字的匹配方式
a==1;b==2;
let {x:_, y:b} = {x:1, y:2}//下划线忽略值
b==2;
let {x:a, ..} = {x:1, y:2}//两点忽略剩余值
a==1;

</pre>

<div id="Rust教程学习:基本概念-逻辑-loop:无限循环"><h3 id="loop:无限循环">loop:无限循环</h3></div>
<pre class="rust">
loop{

}
</pre>
<div id="Rust教程学习:基本概念-逻辑-break:跳出循环"><h3 id="break:跳出循环">break:跳出循环</h3></div>

<div id="Rust教程学习:基本概念-逻辑-continue:到标签循环"><h3 id="continue:到标签循环">continue:到标签循环</h3></div>
<p>
和goto很像
</p>
<pre class="rust">
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
 替换字符串       if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}
</pre>
<div id="Rust教程学习:基本概念-逻辑-if:条件判断"><h3 id="if:条件判断">if:条件判断</h3></div>
<p>
在rust中要求必须是bool类型进行判断,不会对表达式进行类型转换
</p>
<pre class="rust">
if 1==2{
1
}else if 1&lt;2{
2
}else {
3
}
</pre>
<div id="Rust教程学习:基本概念-逻辑-while:条件为真时循环"><h3 id="while:条件为真时循环">while:条件为真时循环</h3></div>
<pre class="rust">
while c{

}
</pre>
<div id="Rust教程学习:基本概念-逻辑-for:遍历列表"><h3 id="for:遍历列表">for:遍历列表</h3></div>
<ul>
<li>
惰性列表要展开才能循环<code>.rev()</code>

<li>
想同时得到循环序号和内容用<code>.enumerate()</code>
<pre class="rust">
for number in (1..4).rev() {
        println!("{}!", number);
    }
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}

</pre>

</ul>

<div id="Rust教程学习:基本概念-逻辑-错误处理"><h3 id="错误处理">错误处理</h3></div>
<div id="Rust教程学习:基本概念-逻辑-错误处理-panic!:不可恢复错误(bug)"><h4 id="panic!:不可恢复错误(bug)">panic!:不可恢复错误(bug)</h4></div>
<p>
在项目设置文件中可以设置清理内存的方式,由系统清理内存可以减小编译后的体积
</p>
<pre class="rust">
fn main() {
    panic!("crash and burn");
}
</pre>
<div id="Rust教程学习:基本概念-逻辑-错误处理-Result:可恢复错误"><h4 id="Result:可恢复错误">Result:可恢复错误</h4></div>
<p>
即理由match枚举进行错误处理
</p>
<pre class="rust">

</pre>
<div id="Rust教程学习:基本概念-逻辑-错误处理-当错误时进行panic!"><h4 id="当错误时进行panic!">当错误时进行panic!</h4></div>
<pre class="rust">

    let f = File::open("hello.txt").unwrap();
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
</pre>
<div id="Rust教程学习:基本概念-逻辑-错误处理-传播错误:让调用者知道错误是什么"><h4 id="传播错误:让调用者知道错误是什么">传播错误:让调用者知道错误是什么</h4></div>
<pre class="rust">
let mut f = File::open("hello.txt")?;
</pre>
<div id="Rust教程学习:基本概念-所有权(ownership)"><h2 id="所有权(ownership)">所有权(ownership)</h2></div>
<div id="Rust教程学习:基本概念-所有权(ownership)-所有权概念"><h3 id="所有权概念">所有权概念</h3></div>
<ul>
<li>
当变量离开作用域时,自动调用<code>drop()</code>,删除变量

<li>
重新赋值let a=b时,在堆上的变量不会被拷贝,而栈上的量会新复制一个,对于指针,会进行移动,也就是复制一个指针,再把原来的删了,这样保证只有一个指针能指向内容.

<li>
当真的想进行深拷贝时,要显式调用<code>clone()</code>

<li>
所有权:当值赋给变量时进行移动,当离开作用域时释放掉

<li>
向闭包移动所有权用<code>move</code>标记

</ul>
<div id="Rust教程学习:基本概念-所有权(ownership)-引用(reference)"><h3 id="引用(reference)">引用(reference)</h3></div>
<ul>
<li>
当只需要值不需要所有权时传引用<code>&amp;a</code>,且可变引用只能有一个,不可变引用可以有很多,可变引用和不可变引用也只能同时有一个

<li>
引用相当于先获得所有权,干一些事情,之后再把所有权还回去的过程
<pre class="rust">
fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    42
}
</pre>

</ul>

<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期"><h3 id="生命周期">生命周期</h3></div>
<p>
生命周期主要是为了防止空指针和野指针,编译时检查引用变量的生命周期和所在区域的生命周期大小
</p>
<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期注解"><h4 id="生命周期注解">生命周期注解</h4></div>
<p>
多个同时出现的生命周期注解,为了提示函数传入值的生命周期关系,当函数返回值与输入值存在生命周期关系时可用
</p>
<pre class="rust">
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</pre>
<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期-方法生命周期"><h4 id="方法生命周期">方法生命周期</h4></div>
<pre class="rust">

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {}
</pre>
<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期-静态生命周期"><h4 id="静态生命周期">静态生命周期</h4></div>
<pre class="rust">

let s: &amp;'static str = "I have a static lifetime.";
</pre>

<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期子类型"><h4 id="生命周期子类型">生命周期子类型</h4></div>
<p>
也就是限定a的周期比b长的情况<code>b:a</code>
</p>
<pre class="rust">

struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
</pre>
<div id="Rust教程学习:基本概念-所有权(ownership)-生命周期-生命周期约束"><h4 id="生命周期约束">生命周期约束</h4></div>
<p>
也就是规定泛型的生命周期
</p>
<pre class="rust">

struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
</pre>

<div id="Rust教程学习:基本概念-模块"><h2 id="模块">模块</h2></div>
<div id="Rust教程学习:基本概念-模块-定义库项目与模块"><h3 id="定义库项目与模块">定义库项目与模块</h3></div>
<p>
在cargo中新建的项目默认就是库项目crate,只有声明<code>--bin</code>才会创建应用项目
</p>
<pre class="rust">
//src/lib.rc
pub mod a;

//src/a/mod.rc
pub fn aa(){}
mod b{
	mod c{}
}
mod e;

//src/a/e.rc
fn e(){}
</pre>
<div id="Rust教程学习:基本概念-模块-公有与私有"><h3 id="公有与私有">公有与私有</h3></div>
<p>
只有声明公有才能被外部调用,而且函数及其父模块都要是公有的才行
</p>

<div id="Rust教程学习:基本概念-模块-引入到作用域"><h3 id="引入到作用域">引入到作用域</h3></div>
<ul>
<li>
使用<code>use</code>,类似python的<code>from .. import ..</code>;

<li>
可以引入所有函数<code>use a::*</code>

<li>
在模块中可以引入上一级的模块<code>use supper::a</code>
<pre class="rust">
pub mod a {
    pub mod series {
				use supper::series;
        pub mod of {
            pub fn nested_modules() {}
						pub fn s(){}
        }
    }
}
enum b{e,c}
use a::series::of::nested_modules;
use e::* 
use a::series::of::{nested_modules,s};

fn main() {
    nested_modules();	
		e;
}
</pre>

</ul>
<div id="Rust教程学习:基本概念-泛型"><h2 id="泛型">泛型</h2></div>
<div id="Rust教程学习:基本概念-泛型-定义与使用泛型"><h3 id="定义与使用泛型">定义与使用泛型</h3></div>
<table>
<tr>
<td>
<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {}</code>
</td>
<td>
定义泛型函数
</td>
</tr>
<tr>
<td>
<code>struct Point&lt;T&gt; {}</code>
</td>
<td>
定义泛型结构体
</td>
</tr>
<tr>
<td>
<code>enum Result&lt;T, E&gt; {}</code>
</td>
<td>
定义泛型枚举
</td>
</tr>
<tr>
<td>
<code>impl&lt;T&gt; Point&lt;T&gt; {}</code>
</td>
<td>
定义泛型方法
</td>
</tr>
<tr>
<td>
<code>impl Point&lt;f32&gt; {}</code>
</td>
<td>
为某种类型专门定义方法
</td>
</tr>
</table>

<pre class="rust">
use std::fmt::Debug;
#[derive(Debug)]
pub struct A&lt;T&gt;{
    pub s:T,
}
/// 对特定类型实现泛型函数
impl A&lt;String&gt; {
    pub fn new(s:String) -&gt; A&lt;String&gt;{
        A::&lt;String&gt;{//注意这里的两冒号
            s,
        }
    }
}
/// 定义泛型trait
trait B&lt;T,U&gt; {
    /// 默认实现
    fn b(&amp;self,t:T,k:U) 
        where T:Debug,U:Debug{
        println!("{:?},{:?}",t,k)
    }
    /// 无实现,只声明
    fn c(T,U) where T:Debug,U:Debug;
}
/// 对特定类型实现trait
impl&lt;T,U&gt; B&lt;T,U&gt; for A&lt;T&gt;{
    fn c(t:T,d:U)where T:Debug,U:Debug{
        println!("{:?},{:?}",d,t);
    }
}

let a = A::new("S".to_string());
println!("{:?}", a);
a.b("s".to_string(),"d");
A::c("S".to_string(),"d")
</pre>

<div id="Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口"><h3 id="trait:不同类型的共同方法实现接口">trait:不同类型的共同方法实现接口</h3></div>
<div id="Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-声明trait"><h4 id="声明trait">声明trait</h4></div>
<pre class="rust">
pub trait Summarizable : Foo { //继承另一个方法
    fn summary(&amp;self) -&gt; String;	//无默认实现的方法
		fn a(&amp;self) -&gt; str{...}	//有默认实现的方法
}
</pre>
<div id="Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-实现trait"><h4 id="实现trait">实现trait</h4></div>
<pre class="rust">
impl Summarizable for NewsArticle {}//采用默认实现
impl Summarizable for Tweet {...}//不采用默认实现
</pre>
<div id="Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-应用trait"><h4 id="应用trait">应用trait</h4></div>
<p>
定义必须实现了某些方法的类型的泛型函数
</p>
<pre class="rust">
// 第一种指定trait的方法
fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {}

// 用where语法指定trait
fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{}

</pre>

<div id="Rust教程学习:基本概念-泛型-trait:不同类型的共同方法实现接口-trait继承"><h4 id="trait继承">trait继承</h4></div>
<pre class"rust">
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
</pre>
<div id="Rust教程学习:基本概念-泛型-关联类型"><h3 id="关联类型">关联类型</h3></div>
<p>
和泛型差不多,但某些时候写起来更清晰
</p>
<pre class="rust">

trait GGraph&lt;Node, Edge&gt; {
    // methods would go here
}
fn distance&lt;N, E, G: GGraph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {
}
trait AGraph {
    type Node;
    type Edge;

    // methods would go here
}
fn distance&lt;G: AGraph&gt;(graph: &amp;G, start: &amp;G::Node, end: &amp;G::Node) -&gt; u32 {
}
</pre>

<div id="Rust教程学习:基本概念-泛型-运算符重载"><h3 id="运算符重载">运算符重载</h3></div>
<p>
只要是<code>std::ops</code>里的都可以重载
</p>
<pre class="rust">
use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</pre>

<div id="进阶知识"><h1 id="进阶知识">进阶知识</h1></div>
<div id="进阶知识-测试"><h2 id="测试">测试</h2></div>
<p>
测试函数:
</p>
<pre class="rust">
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</pre>
<p>
使用测试函数注解<code>#[test]</code>声明一个测试,这些注解目前只是由编译器自己规定的,不能自定义
<table>
<tr>
<td>
<code>cargo test</code>
</td>
<td>
运行测试
</td>
</tr>
<tr>
<td>
<code>assert_eq!(a,b)</code>
</td>
<td>
测试a==b
</td>
</tr>
<tr>
<td>
<code>assert!(a)</code>
</td>
<td>
测试a==true
</td>
</tr>
<tr>
<td>
<code>assert_ne!(a,b)</code>
</td>
<td>
测试<code>a!=b</code>
</td>
</tr>
<tr>
<td>
<code>#[should_panic]</code>
</td>
<td>
测试是否成功产生了panic错误处理
</td>
</tr>
<tr>
<td>
<code>#[ignore]</code>
</td>
<td>
忽略这个测试
</td>
</tr>
</table>
</p>

<div id="进阶知识-函数式"><h2 id="函数式">函数式</h2></div>
<div id="进阶知识-函数式-闭包:匿名函数"><h3 id="闭包:匿名函数">闭包:匿名函数</h3></div>
<div id="进阶知识-函数式-闭包:匿名函数-基本语法"><h4 id="基本语法">基本语法</h4></div>
<p>
把括号变成竖线即可,注意类型自动推断导致第一次调用时的类型就是全部的类型,单行可以不写大括号
</p>
<pre class="rust">
let expensive_closure = |num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
let f = |x:i32|-&gt;i32 {x};
f(2)
</pre>
<div id="进阶知识-函数式-闭包:匿名函数-闭包的泛型trait"><h4 id="闭包的泛型trait">闭包的泛型trait</h4></div>
<p>
闭包泛型为<code>Fn</code>,<code>FnMut</code>,<code>FnOnce</code>中的一个
利用结构体保存计算结果,结构体方法作匿名函数,实现惰性求值
先定义泛型结构体,再写泛型结构体的静态方法,把匿名函数(闭包)作为方法的参数
</p>
<pre class="rust">
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}

impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
let mut expensive_result = Cacher::new(|num| {
		println!("calculating slowly...");
		thread::sleep(Duration::from_secs(2));
		num
});
</pre>

<div id="进阶知识-函数式-闭包:匿名函数-move:闭包获得所有权"><h4 id="move:闭包获得所有权">move:闭包获得所有权</h4></div>
<p>
使用<code>move</code>关键字,让闭包强制获得所有权,用来实现迭代器
</p>
<pre class="rust">
    let equal_to_x = move |z| z == x;
</pre>

<div id="进阶知识-迭代器"><h2 id="迭代器">迭代器</h2></div>
<div id="进阶知识-迭代器-使用迭代器"><h3 id="使用迭代器">使用迭代器</h3></div>
<p>
迭代器是零成本抽象之一,因而其速度很快
</p>

<p>
迭代器是惰性求值的,当调用创建函数创建迭代器时,并没有进行运算,只有当对迭代器调用消费函数时才会运行求值
<table>
<tr>
<td>
<code>.iter()</code>
</td>
<td>
创建迭代器,每项是不可变引用
</td>
</tr>
<tr>
<td>
<code>.into_iter()</code>
</td>
<td>
创建迭代器,每项有所有权
</td>
</tr>
<tr>
<td>
<code>.iter_mut()</code>
</td>
<td>
创建迭代器,可变引用
</td>
</tr>
<tr>
<td>
<code>.next()</code>
</td>
<td>
返回迭代器中的一个项,结束时返回<code>None</code>
</td>
</tr>
<tr>
<td>
<code>.sum()</code>
</td>
<td>
获取所有项的总和
</td>
</tr>
<tr>
<td>
<code>.map(Fn)</code>
</td>
<td>
迭代器适配器,对每个项运行函数,把结果形成新的迭代器
</td>
</tr>
<tr>
<td>
<code>.collect()</code>
</td>
<td>
将迭代器的内容收集到数据结构中
</td>
</tr>
<tr>
<td>
<code>.filter(Fn-&gt;bool)</code>
</td>
<td>
迭代器适配器,对每项运行函数,返回<code>true</code>的项将进入到结果迭代器中
</td>
</tr>
</table>
</p>

<div id="进阶知识-迭代器-自定义迭代器"><h3 id="自定义迭代器">自定义迭代器</h3></div>
<p>
只需要对结构体定义<code>Iterator</code>trait的方法<code>next</code>即可,由于标准迭代器方法都用了<code>.next()</code>方法,所以可以使用所有的迭代器方法
</p>
<pre class="rust">
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
</pre>

<div id="进阶知识-智能指针"><h2 id="智能指针">智能指针</h2></div>
<div id="进阶知识-智能指针-Box&lt;T&gt;:堆上存储数据"><h3 id="Box&lt;T&gt;:堆上存储数据">Box&lt;T&gt;:堆上存储数据</h3></div>
<p>
由于Rust编译要求知道栈上空间大小,所以对于未知大小的数据可用,此时栈上的是指向堆上数据的指针
</p>
<pre class="rust">
Box::new(1)
</pre>

<div id="进阶知识-智能指针-自定义智能指针"><h3 id="自定义智能指针">自定义智能指针</h3></div>
<ol>
<li>
定义结构体

<li>
定义<code>new()</code>构造方法

<li>
定义<code>deref()</code>解引用方法,也可以认为是重载<code>*</code>引用

<li>
定义<code>drop()</code>析构方法
		当希望手动提前释放内存时可用<code>std::mem::drop</code>
<pre class="rust">
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

</pre>

</ol>
<div id="进阶知识-智能指针-Rc&lt;T&gt;:单线程引用计数指针"><h3 id="Rc&lt;T&gt;:单线程引用计数指针">Rc&lt;T&gt;:单线程引用计数指针</h3></div>
<p>
通过不可变的引用计数指针来在多个部分间共享内存数据
<code>new()</code>新建指针,<code>clone()</code>增加计数,在作用域离开时自动删除计数
</p>
<pre class="rust">
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
</pre>
<div id="进阶知识-智能指针-RefCell&lt;T&gt;:内部可变模式"><h3 id="RefCell&lt;T&gt;:内部可变模式">RefCell&lt;T&gt;:内部可变模式</h3></div>
<p>
只有内部方法可以改变值,对于外部函数仍是不可变的,组合<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>可以得到多个所有者的可变数据结构
</p>
<pre class="rust">
	    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

</pre>
<div id="进阶知识-智能指针-Weak&lt;T&gt;:弱引用计数指针"><h3 id="Weak&lt;T&gt;:弱引用计数指针">Weak&lt;T&gt;:弱引用计数指针</h3></div>
<p>
强引用计数有可能造成引用循环导致计数不为0的内存泄露,组合使用弱计数和强计数来避免引用循环
</p>
<pre class="rust">
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
</pre>

<div id="进阶知识-并发与并行"><h2 id="并发与并行">并发与并行</h2></div>
<div id="进阶知识-并发与并行-线程"><h3 id="线程">线程</h3></div>
<table>
<tr>
<td>
<code>std::thread</code>
</td>
<td>
标准库线程
</td>
</tr>
<tr>
<td>
<code>thread::spawn(Fn)</code>
</td>
<td>
创建线程,传递一个闭包作为线程执行函数
</td>
</tr>
<tr>
<td>
<code>thread::sleep(time::Duration)</code>
</td>
<td>
线程睡眠,参数为标准库time
</td>
</tr>
<tr>
<td>
<code>thread.join().unwrap()</code>
</td>
<td>
在主线程中,将主线程阻塞直到所有子线程完成
</td>
</tr>
</table>

<p>
		在传递线程闭包时使用<code>move</code>关键字,能够将所有权给子线程,保证主线程不会再次释放同一个变量
</p>
<pre class="rust">
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
</pre>

<div id="进阶知识-并发与并行-线程通信"><h3 id="线程通信">线程通信</h3></div>
<table>
<tr>
<td>
<code>std::sync::mpse</code>
</td>
<td>
多个生产者,一个消费者,多发送一接收
</td>
</tr>
<tr>
<td>
<code>let (tx,rx)=mpsc::channel()</code>
</td>
<td>
新建通信通道
</td>
</tr>
<tr>
<td>
<code>tx</code>
</td>
<td>
发送者
</td>
</tr>
<tr>
<td>
<code>rx</code>
</td>
<td>
接收者
</td>
</tr>
<tr>
<td>
<code>tx.send(val).unwrap()</code>
</td>
<td>
发送,发送后线程内失去所有权
</td>
</tr>
<tr>
<td>
<code>rx.recv().unwrap()</code>
</td>
<td>
接收,阻塞直到收到内容
</td>
</tr>
<tr>
<td>
<code>rx.try_recv().unwrap()</code>
</td>
<td>
立即接收,返回<code>Result</code>
</td>
</tr>
<tr>
<td>
<code>tx1=mpsc::Sender::clone(&amp;tx)</code>
</td>
<td>
通过克隆来得到多个发送者
</td>
</tr>
</table>

<pre class="rust">


use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}

</pre>


<div id="进阶知识-并发与并行-共享状态"><h3 id="共享状态">共享状态</h3></div>
<p>
多个线程共享内存都拥有所有权,在访问数据时线程先获取锁操作之后再解锁
<table>
<tr>
<td>
<code>std::sync::Mutex</code>
</td>
<td>
标准库的互斥器
</td>
</tr>
<tr>
<td>
<code>Mutex::new(T)</code>
</td>
<td>
新建一个互斥器
</td>
</tr>
<tr>
<td>
<code>m.lock()</code>
</td>
<td>
获取锁
</td>
</tr>
<tr>
<td>
<code>std::sync::Arc</code>
</td>
<td>
原子引用计数,类似<code>Rc&lt;T&gt;</code>
</td>
</tr>
<tr>
<td>
<code>Arc::clone()</code>
</td>
<td>
得到新的互斥器指针
</td>
</tr>
</table>
</p>

<div id="进阶知识-并发与并行-Rust语言内的并发trait"><h3 id="Rust语言内的并发trait">Rust语言内的并发trait</h3></div>
<p>
<code>Send</code>:表明类型的所有权可以在线程间进行传递
<code>Sync</code>:表明可以安全的在多线程中获得值的引用
</p>

<div id="进阶知识-面向对象"><h2 id="面向对象">面向对象</h2></div>
<p>
结构体类型-&gt;类
结构体方法-&gt;类方法
trait接口的类型继承-&gt;继承和多态
就是函数式里实现面向对象的技术,和Clojure差不多
</p>

<div id="进阶知识-属性"><h2 id="属性">属性</h2></div>
<p>
所有的属性都是编译器内建实现的,不能自己添加属性
</p>
<div id="进阶知识-属性-derive:自动实现一些泛型方法"><h3 id="derive:自动实现一些泛型方法">derive:自动实现一些泛型方法</h3></div>
<p>
目前只适用于:<code>Clone</code>,<code>Copy</code>,<code>Debug</code>,<code>Default</code>,<code>Eq</code>,<code>Hash</code>,<code>Ord</code>,<code>PartialEq</code>,<code>PartialOrd</code>
</p>
<pre class="rust">
#[derive(Debug)]
struct Foo;

fn main() {
    println!("{:?}", Foo);
}
</pre>

<div id="进阶知识-属性-过程宏"><h3 id="过程宏">过程宏</h3></div>
<p>
过程宏用来给<code>struct</code>添加现成的<code>trait</code>方法,他的行为是宏,但语法和属性相似
</p>
<div id="进阶知识-属性-过程宏-创建过程宏"><h4 id="创建过程宏">创建过程宏</h4></div>
<ul>
<li>
<code>proc_macro</code>:过程宏提取和创建,目前只有<code>proc_macro::TokenStream</code>,用来把代码变成字符串,内置无依赖

<li>
<code>syn</code>:rust语法解析器,需依赖<code>syn = "0.10.5"</code>,具体用法参见文档

<li>
<code>quote</code>:rust代码生成器,需依赖<code>quote = "0.3.10"</code>,<code>quote!</code>可以像普通宏一样写代码,参加文档

<li>
编写过程为:代码生成字符串-&gt;字符串解析语法树-&gt;对语法树进行处理实现目标功能-&gt;将语法树还原成代码字符串

<li>
过程宏要在一个单独的lib里引入,在<code>cargo</code>里写上<code>[lib] proc-macro = true</code>,才能通过编译

<li>
在编写过程宏时,加入参数声明就可以进行自定义<code>#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]</code>

</ul>

<pre class="rust">
extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloWorld)]
pub fn hello_world(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_world(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}

fn impl_hello_world(ast: &amp;syn::MacroInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloWorld for #name {
            fn hello_world() {
                println!("Hello, World! My name is {}", stringify!(#name));
            }
        }
    }
}

</pre>

<div id="进阶知识-属性-过程宏-使用过程宏"><h4 id="使用过程宏">使用过程宏</h4></div>
<p>
从lib中引入宏并定义好trait接口,具体实现交给宏完成
</p>
<pre class="rust">
#[macro_use]
extern crate hello_world_derive;

trait HelloWorld {
    fn hello_world();
}

#[derive(HelloWorld)]
struct FrenchToast;

#[derive(HelloWorld)]
struct Waffles;

fn main() {
    FrenchToast::hello_world();
    Waffles::hello_world();
}

</pre>
<div id="进阶知识-宏"><h2 id="宏">宏</h2></div>
<div id="进阶知识-宏-语法"><h3 id="语法">语法</h3></div>
<table>
<tr>
<td>
<code>macro_rules! m { (....)=&gt;{....}; }</code>
</td>
<td>
定义宏,匹配箭头后面可以是<code>(),{},[]</code>,每个分支都以分号结束
</td>
</tr>
<tr>
<td>
<code>$(e1,e2,..)</code>
</td>
<td>
匹配任何表达式模板都可以
</td>
</tr>
<tr>
<td>
<code>$x:expr</code>
</td>
<td>
匹配任意表达式并绑定在<code>x</code>上,指定匹配的内容
</td>
</tr>
<tr>
<td>
<code>$x</code>
</td>
<td>
在宏里引用绑定的表达式
</td>
</tr>
<tr>
<td>
<code>$(),+</code>
</td>
<td>
表示上一个匹配部分重复出现一次或多次,且这些部分以逗号隔开
</td>
</tr>
<tr>
<td>
<code>$(),*</code>
</td>
<td>
表示上一个匹配部分重复出现零次或多次,且这些部分以逗号隔开
</td>
</tr>
<tr>
<td>
<code>$()*</code>
</td>
<td>
表示这个表达式重复零次或多次,且这些表达式直接相邻,表达式里可以有换行
</td>
</tr>
</table>

<pre class="rust">
macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}
</pre>

<div id="进阶知识-宏-指示符"><h3 id="指示符">指示符</h3></div>
<table>
<tr>
<td>
ident
</td>
<td>
一个标识符。
</td>
<td>
x，foo
</td>
</tr>
<tr>
<td>
path
</td>
<td>
一个受限的名字。
</td>
<td>
T::SpecialA
</td>
</tr>
<tr>
<td>
expr
</td>
<td>
一个表达式。
</td>
<td>
2 + 2；if true then { 1 } else { 2 }；f(42)
</td>
</tr>
<tr>
<td>
ty
</td>
<td>
一个类型。
</td>
<td>
i32；Vec&lt;(char, String)&gt;；&amp;T
</td>
</tr>
<tr>
<td>
pat
</td>
<td>
一个模式。
</td>
<td>
Some(t)；(17, 'a')；_
</td>
</tr>
<tr>
<td>
stmt
</td>
<td>
一个单独语句。
</td>
<td>
let x = 3
</td>
</tr>
<tr>
<td>
block
</td>
<td>
一个大括号界定的语句序列，或者一个表达式。
</td>
<td>
{ log(error, "hi"); return 12; }
</td>
</tr>
<tr>
<td>
item
</td>
<td>
一个项。
</td>
<td>
fn foo() { }，struct Bar
</td>
</tr>
<tr>
<td>
meta
</td>
<td>
一个“元数据项”，可以在属性中找到。
</td>
<td>
cfg(target_os = "windows")
</td>
</tr>
<tr>
<td>
tt
</td>
<td>
一个单独的记号树
</td>
<td>
&nbsp;
</td>
</tr>
</table>


<div id="进阶知识-不安全的Rust"><h2 id="不安全的Rust">不安全的Rust</h2></div>
<div id="进阶知识-不安全的Rust-裸指针"><h3 id="裸指针">裸指针</h3></div>
<ul>
<li>
<code>*const</code>和<code>*mut</code>是裸指针,创建裸指针是安全的,但解引用裸指针不安全

<li>
裸指针没有生命周期和所有权
<pre class="rust">
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
</pre>

</ul>

<div id="进阶知识-不安全的Rust-unsafe"><h3 id="unsafe">unsafe</h3></div>
<table>
<tr>
<td>
<code>unsafe fn a{}</code>
</td>
<td>
声明不安全函数
</td>
</tr>
<tr>
<td>
<code>unsafe{}</code>
</td>
<td>
声明不安全块
</td>
</tr>
<tr>
<td>
<code>unsafe trait A{}</code>
</td>
<td>
声明不安全接口
</td>
</tr>
<tr>
<td>
<code>unsafe impl B for A{}</code>
</td>
<td>
声明不安全方法
</td>
</tr>
</table>
<p>
在不安全块中只能够做三件事
</p>
<ol>
<li>
访问和更新一个静态可变变量

<li>
解引用一个裸指针

<li>
调用不安全函数。

</ol>

<div id="进阶知识-不安全的Rust-创建安全抽象"><h3 id="创建安全抽象">创建安全抽象</h3></div>
<p>
只要一个函数的输入输出都是rust的,只在内部用了unsafe,也是安全的
</p>
<pre class="rust">
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
</pre>

<div id="进阶知识-不安全的Rust-ffi:与C交互"><h3 id="ffi:与C交互">ffi:与C交互</h3></div>
<p>
c类型很多在<code>libc</code>里定义:<code>extern crate libc;</code>
</p>
<div id="进阶知识-不安全的Rust-ffi:与C交互-调用外部函数"><h4 id="调用外部函数">调用外部函数</h4></div>
<ul>
<li>
<code>#[link(name="libname",kind="")]</code>:指定引入的c库及类型,动态(不写kind),静态(static),osx动态(framework)

<li>
目前支持的ABI有:<code>stdcall</code>,<code>aapcs</code>,<code>cdecl</code>,<code>fastcall</code>,<code>Rust</code>,<code>rust-intrinsic</code>,<code>system</code>,<code>C</code>,<code>win64</code>,<code>sysv64</code>

<li>
可变参数用<code>...</code>表示,但在普通的rust里不支持这样

<li>
对于空指针用<code>None</code>代替,即<code>Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;</code>相当于 C 类型<code>int (*)(int)</code>

</ul>

<pre class="rust">
# #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = "snappy")]
extern "C" {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn foo(x: i32, ...);
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
</pre>
<div id="进阶知识-不安全的Rust-ffi:与C交互-导出接口到C"><h4 id="导出接口到C">导出接口到C</h4></div>
<ul>
<li>
<code>#[no_mangle]</code>:保留函数名

<li>
如果有可能发生<code>panic!</code>,要在<code>catch_unwind(|| {})</code>闭包中执行
<pre class="rust">
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</pre>

</ul>
<div id="进阶知识-高级函数"><h2 id="高级函数">高级函数</h2></div>
<div id="进阶知识-高级函数-fn(T):函数指针"><h3 id="fn(T):函数指针">fn(T):函数指针</h3></div>
<p>
函数的参数是函数:
</p>
<pre class="rust">
fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

</pre>
<div id="进阶知识-高级函数-返回闭包"><h3 id="返回闭包">返回闭包</h3></div>
<p>
函数的返回值还是函数,必须用<code>Box&lt;T&gt;</code>把它放在堆上
</p>
<pre class="rust">
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</pre>

		</div>
		<nav class="navbar">
			<span class="navbar-text">
				Page created on 2018-02-23
			</span>
		</nav>

	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- highlight.js -->
	<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
	<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
	<script>
		$(document).ready(function() {
			$('pre').each(function(i, block) {
				hljs.highlightBlock(block);
			});
			$('.article-toc ul li ul li ul li ul').hide();
		});
	</script>
	<!-- MathJax -->
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" src="../js/search.js"></script>
</body>
</html>
