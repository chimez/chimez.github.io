<!doctype html>
<html lang="zh-cn">
	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

		<!-- Template -->
		<link rel="Stylesheet" type="text/css" href="../css/main.css" />
		<title>QuTiP学习记录</title>
	</head>

	<body>
		<div class="container">

			<nav class="navbar navbar-expand-lg sticky-top navbar-light bg-light">
				<a class="navbar-brand" href="../index.html">Chimez</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>

				<div class="collapse navbar-collapse" id="navbarTogglerDemo02">
					<ul class="navbar-nav mr-auto mt-2 mt-lg-0">
						<li class="nav-item active">
							<a class="nav-link" href="../articles_index.html">文章列表 <span class="sr-only">(current)</span></a>
					</ul>
					<form class="form-inline my-2 my-lg-0">
						<input class="form-control mr-sm-2" type="search" placeholder="Search">
						<button class="btn btn-outline-success my-2 my-sm-0" type="button">Search</button>
					</form>
				</div>
			</nav>

			<div class="row">
				
<p>
<div class="col-md-3 article-toc d-none d-md-block">
</p>
<div id="Contents" class="toc"><h1 id="Contents">Contents</h1></div>
<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格">QuTiP学习记录与速查表格</a>

<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-安装与引用">安装与引用</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作">基本操作</a>

<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作-定义左矢右矢算符">定义左矢右矢算符</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作-基本计算">基本计算</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作-粒子数表象下的态和算符生成">粒子数表象下的态和算符生成</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作-混合态">混合态</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-基本操作-其他计算">其他计算</a>

</ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解">时间演化，解薛定谔方程求解</a>

<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-无耗散情况">无耗散情况</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-有耗散情况">有耗散情况</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-随时间变化的哈密顿量">随时间变化的哈密顿量</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用">技巧与应用</a>

<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用-主方程求解显示进度">主方程求解显示进度</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用-主方程求解计算平均值函数">主方程求解计算平均值函数</a>

</ul>
</ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-优化控制">优化控制</a>

<ul>
<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-优化控制-CRAB算法与GRAPE算法">CRAB算法与GRAPE算法</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-优化控制-常用函数">常用函数</a>

<li>
<a href="QuTiP学习记录.html#QuTiP学习记录与速查表格-优化控制-计算过程">计算过程</a>

</ul>
</ul>
</ul>

<p>
</div>
<div class="col-md-9 article-main">
</p>
<div id="QuTiP学习记录与速查表格"><h1 id="QuTiP学习记录与速查表格">QuTiP学习记录与速查表格</h1></div>
<div id="QuTiP学习记录与速查表格-安装与引用"><h2 id="安装与引用">安装与引用</h2></div>
<ol>
<li>
<code>pip3 install qutip</code>

<li>
引用如下
<pre python>
from qutip import *
import matplotlib.pyplot as plt
import numpy as np
</pre>

</ol>


<div id="QuTiP学习记录与速查表格-基本操作"><h2 id="基本操作">基本操作</h2></div>
<div id="QuTiP学习记录与速查表格-基本操作-定义左矢右矢算符"><h3 id="定义左矢右矢算符">定义左矢右矢算符</h3></div>
<table>
<tr>
<td>
说明
</td>
<td>
命令
</td>
<td>
注意事项
</td>
</tr>
<tr>
<td>
定义右矢
</td>
<td>
<code>q_ket = Qobj([[1],[2]])</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
定义左矢
</td>
<td>
<code>q_bra = Qobj([[1,2]])</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
定义算符
</td>
<td>
<code>q_oper = Qobj([[1j+3,2],[3,4]]) </code>
</td>
<td>
虚数用<code>j</code>表示
</td>
</tr>
</table>


<div id="QuTiP学习记录与速查表格-基本操作-基本计算"><h3 id="基本计算">基本计算</h3></div>
<table>
<tr>
<td>
说明
</td>
<td>
命令
</td>
<td>
注意事项
</td>
</tr>
<tr>
<td>
左乘右乘
</td>
<td>
<code>q_ket * q_bar</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>q_bra * q_ket</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>q_oper * q_ket</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
乘方
</td>
<td>
<code>q_oper ** 2</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
转置 transpose
</td>
<td>
<code>q_oper.trans() </code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
复共轭conjugate
</td>
<td>
<code>q_oper.conj() </code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
厄米共轭 hermitian conjugate
</td>
<td>
<code>q_oper.dag()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
迹 trace
</td>
<td>
<code>q_oper.tr()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
对易子
</td>
<td>
<code>commutator(q_oper,q_oper)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
本征值
</td>
<td>
<code>q_oper.eigenenergies()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
本证态
</td>
<td>
<code>q_oper.eigenstates()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
是否为厄米算符hermitian
</td>
<td>
<code>q_oper.isherm </code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>q_oper.check_herm()</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
得到基态
</td>
<td>
<code>q_oper.groundstate()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
得到矩阵表示
</td>
<td>
<code>q_oper.full()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
计算矩阵元
</td>
<td>
<code>q_oper.matrix_element(bra=q_bra, ket=q_ket)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
作用一个变换
</td>
<td>
<code>q_oper.transform(q_oper)</code>
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<div id="QuTiP学习记录与速查表格-基本操作-粒子数表象下的态和算符生成"><h3 id="粒子数表象下的态和算符生成">粒子数表象下的态和算符生成</h3></div>
<table>
<tr>
<td>
说明
</td>
<td>
命令
</td>
<td>
注意事项
</td>
</tr>
<tr>
<td>
Fock态
</td>
<td>
<code>basis(N=4,n=1) </code>
</td>
<td>
N=总状态数，<br>n=占据的状态编号
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>fock(N=4, n=1) </code>
</td>
<td>
从上到下为0,1...N-1
</td>
</tr>
<tr>
<td>
相干态
</td>
<td>
<code>coherent(N=10,alpha=1.0) </code>
</td>
<td>
N=总状态数，<br>alpha=本征值（复数）
</td>
</tr>
<tr>
<td>
Fock密度算符
</td>
<td>
<code>fock_dm(N=5,n=2) </code>
</td>
<td>
N=hilbert空间大小，<br>n=占据的态
</td>
</tr>
<tr>
<td>
相干态密度算符
</td>
<td>
<code>coherent_dm(N=5,alpha=1j+2) </code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
热态 密度算符
</td>
<td>
<code>thermal_dm(N=8, n=2) </code>
</td>
<td>
N=空间大小，<br>n=热光子平均数
</td>
</tr>
<tr>
<td>
从一个右矢生成密度算符
</td>
<td>
<code>ket2dm(q_ket)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
泡利算符
</td>
<td>
<code>sigmax()</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>sigmay()</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>sigmaz()</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
自旋升降算符
</td>
<td>
<code>sigmap() </code>
</td>
<td>
plus
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>sigmam() </code>
</td>
<td>
minus
</td>
</tr>
<tr>
<td>
湮灭产生算符
</td>
<td>
<code>destroy(N=3)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
<code>create(N=3)</code>
</td>
<td>
同上
</td>
</tr>
<tr>
<td>
粒子数算符
</td>
<td>
<code>num(N=3)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
位置算符
</td>
<td>
<code>position(N=2)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
动量算符
</td>
<td>
<code>momentum(N=2)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
位移算符 单模
</td>
<td>
<code>displace(N=3, alpha=1)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
相位算符 单模
</td>
<td>
<code>phase(N=3, phi0=1)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
压缩算符 单模
</td>
<td>
<code>squeeze(N=3, z=1) = z=压缩参数</code>
</td>
<td>
=
</td>
</tr>
<tr>
<td>
压缩算符 双模
</td>
<td>
<code>squeezing(a1=destroy(N=2), a2=destroy(N=2), z=1j)  </code>
</td>
<td>
a1,a2=两个湮灭算符，<br>z=压缩参数
</td>
</tr>
</table>
 
<div id="QuTiP学习记录与速查表格-基本操作-混合态"><h3 id="混合态">混合态</h3></div>
<table>
<tr>
<td>
说明
</td>
<td>
命令
</td>
<td>
注意事项
</td>
</tr>
<tr>
<td>
混合态 张量积
</td>
<td>
<code>tensor(sigmaz(),qeye(2))</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
部分迹
</td>
<td>
<code>state.ptrace([1,2])</code>
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<div id="QuTiP学习记录与速查表格-基本操作-其他计算"><h3 id="其他计算">其他计算</h3></div>
<table>
<tr>
<td>
说明
</td>
<td>
命令
</td>
<td>
注意事项
</td>
</tr>
<tr>
<td>
-
</td>
<td>
-
</td>
<td>
-
</td>
</tr>
<tr>
<td>
保真度
</td>
<td>
<code>fidelity(q_oper,q_oper)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
迹距离 trace distance
</td>
<td>
<code>tracedist(q_oper,q_oper)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Hilbert-Schmidt距离
</td>
<td>
<code>hilbert_dist(q_oper,q_oper)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
计算两qubit纠缠度
</td>
<td>
<code>concurrence(state.ptrace([1,2]))</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
平均值
</td>
<td>
<code>expect(o,state)</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
方差
</td>
<td>
<code>variance(o, state)</code>
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解"><h2 id="时间演化，解薛定谔方程求解">时间演化，解薛定谔方程求解</h2></div>
<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-无耗散情况"><h3 id="无耗散情况">无耗散情况</h3></div>
<pre python>
H # sigmax()                           # 先定义哈密顿量
psi0 # basis(2,0)                      # 初值
tlist # np.linspace(0,10,100)          # 生成一个时间序列
result # mesolve(H, psi0, tlist, [], []) # 使用mesolve计算ode方程
result.states[-1]                        # 列表里保存每一时刻的态，最后一个是末态
expect(sigmaz(), result.states[-1])      # 计算平均值，用算符和态
variance(ope, state)                     # 方差
# result = mesolve(H, psi0, tlist, [], [sigmaz()]) # 可以在计算时只算平均值演化=
[[#]] result.expect[0]                               # 保存每一时刻的平均值=
</pre>
<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-有耗散情况"><h3 id="有耗散情况">有耗散情况</h3></div>
<pre python>
a = destroy(10)             # 湮灭算符
H = a.dag()*a               # 哈密顿量
c_ops = [np.sqrt(0.1) * a]  # 耗散
rho:0 = fock_dm(10,5)       # 初态
tlist = np.linspace(0,50,100) # 时间
result = mesolve(H, rho0, tlist, c_ops, [a.dag()*a])
result.expect[0]
</pre>

<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-随时间变化的哈密顿量"><h3 id="随时间变化的哈密顿量">随时间变化的哈密顿量</h3></div>
<p>
在写哈密顿量时,每个随时间变化的哈密顿量,其系数用一个函数来表示,函数接受<code>t</code>和<code>arg</code>两个参数,其中<code>arg</code>在计算主方程时由<code>arg={}</code>指定
</p>

<pre class="python">
H = [H0,[H1,H1_coeff]]
H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge)  # time-independent term
H1 = (sigma_ue.dag() + sigma_ue)  # time-dependent term
def H1_coeff(t, args):
	return 9 * np.exp(-(t / 5.) ** 2)
	
output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG])

def H1_coeff(t, args):
  A = args['A']
  sig = args['sigma']
  return A * np.exp(-(t / sig) ** 2)
	 
output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5})
</pre>
<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用"><h3 id="技巧与应用">技巧与应用</h3></div>
<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用-主方程求解显示进度"><h4 id="主方程求解显示进度">主方程求解显示进度</h4></div>
<p>
在函数调用中加入<code>progress_bar = True</code>
</p>
<pre Python>
    mesolve(H, psi_0, tlist, c_ops, e_ops, progress_bar=True)
</pre>

<div id="QuTiP学习记录与速查表格-时间演化，解薛定谔方程求解-技巧与应用-主方程求解计算平均值函数"><h4 id="主方程求解计算平均值函数">主方程求解计算平均值函数</h4></div>
<p>
为了节省内存,<code>e_ops=func</code>,只能有一个函数<code>func(t,rho)</code>,且没有返回值,需要自己构造全局变量保存值
</p>
<pre python>

    # 待计算的平均值
    result = {"tlist":tlist,
              "concurrence":[],
              "na":[],
              "z1":[],
              "z2":[]}
    def get_co(t, state):
        pn = state.ptrace([1,2])
        co = concurrence(pn)
        na = expect(dag(a)*a,state)
        z1 = expect(sigma1_z,state)
        z2 = expect(sigma2_z,state)
        result["concurrence"].append(co)
        result["na"].append(na)
        result["z1"].append(z1)
        result["z2"].append(z2)

    e_ops = get_co
</pre>

<div id="QuTiP学习记录与速查表格-优化控制"><h2 id="优化控制">优化控制</h2></div>
<div id="QuTiP学习记录与速查表格-优化控制-CRAB算法与GRAPE算法"><h3 id="CRAB算法与GRAPE算法">CRAB算法与GRAPE算法</h3></div>
<ul>
<li>
CRAB算法是指限定控制场由几个简单的基函数构成,由这些项的系数随时间变化进行控制,优点是优化方便计算快实验实现简单,但有可能得不到优化目标,需要尝试组合,其实就相当于傅立叶展开取前几项那样

<li>
GRAPE算法

</ul>

<div id="QuTiP学习记录与速查表格-优化控制-常用函数"><h3 id="常用函数">常用函数</h3></div>
<table>
<tr>
<td>
<code>import qutip.control.pulseoptim as cpo</code>
</td>
<td>
优化控制计算和生成
</td>
</tr>
<tr>
<td>
<code>import qutip.control.pulsegen as pulsegen</code>
</td>
<td>
控制场脉冲生成
</td>
</tr>
<tr>
<td>
<code>cpo.create_pulse_optimizer</code>
</td>
<td>
创建演化算符描述的优化控制器
</td>
</tr>
<tr>
<td>
<code>dyn = optim.dynamics</code>
</td>
<td>
动力计算器
</td>
</tr>
<tr>
<td>
<code>optim.pulse_generator[0]</code>
</td>
<td>
指定的控制场
</td>
</tr>
<tr>
<td>
<code>pulsegen.create_pulse_gen</code>
</td>
<td>
生成脉冲
</td>
</tr>
<tr>
<td>
<code>dyn.initialize_controls(init_amps)</code>
</td>
<td>
设置初始控制场参数
</td>
</tr>
<tr>
<td>
<code>optim.run_optimization()</code>
</td>
<td>
运行计算
</td>
</tr>
<tr>
<td>
<code>cpo.opt_pulse_crab_unitary</code>
</td>
<td>
创建态到态描述的优化控制器
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
</table>
<div id="QuTiP学习记录与速查表格-优化控制-计算过程"><h3 id="计算过程">计算过程</h3></div>
<pre class="python">

# 创建优化器,简单易行的优化控制
optim = cpo.create_pulse_optimizer(
			H_d,                               # 漂移哈密顿量,固定不变的
			H_c,                               # 控制哈密顿两,一个list里面是不变的量,各个项系数会变,[H1,H2...]
			U_0,                               # 初始演化算符
			U_targ,                            # 目标演化算符
			n_ts,                              # 时间间隔分的段数,200
			evo_time,                          # 总演化时长,10
			fid_err_targ=1e-3,                 # 允许误差范围,1e-3
			max_iter=20000,                    # 优化算法最大迭代数量,20000
			max_wall_time=300,                 # 优化算法最大计算时间,300
			alg='CRAB',                        # 指定算法,'CRAB'或'GRAPE'
			dyn_type='UNIT',                   # 动力学类型:UNIT, GEN_MAT, SYMPL
			prop_type='DIAG',                  # 传播计算类型:DEF, APPROX, DIAG, FRECHET, AUG_MAT
			fid_type='UNIT',                   # 保真度误差计算方法:DEF, UNIT, TRACEDIFF, TD_APPROX
			fid_params={'phase_option':'PSU'}, # 保真度误差计算方法的参数
		 #log_level=logging.INFO,            # 信息记录级别:DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
			gen_stats=True                     # 是否产生数据,态之类的东西
			)
# 从优化器获取到动力计算器
dyn = optim.dynamics

# 为每个控制场设置脉冲
# 1. 先指定要设定第几个场
crab_pgen = optim.pulse_generator[0]
# 2. 再根据动力系统生成脉冲函数
# 可选的脉冲类型有
# * 随机脉冲 RND(每段时间各自独立)RNDFOURIER(随机相关的傅立叶级数)RNDWAVES(随机波动)RNDWALK1(每段随机变化)
# * 非周期脉冲 LIN(线性)ZERO(0)
# * 周期脉冲 SINE(正弦波)SQUARE(方波)SAW(锯齿波)TRIANGLE(三角波)
guess_pgen = pulsegen.create_pulse_gen('LIN', dyn=dyn, 
                                           pulse_params={'scaling':3.0})
# 3. 然后就可以把控制场的脉冲设置上了
crab_pgen.guess_pulse = guess_pgen.gen_pulse()
# 4. 最后还可以再设置一些其他的信息
crab_pgen.scaling = 0.0 #线性缩放比例
crab_pgen.num_coeffs = 5 #估计值
crab_pgen.lbound = -2.0 #下界
crab_pgen.ubound = 2.0#上界

# 5. 再把初值设上,每个控制脉冲的和总的
init_amps = np.zeros([n_ts, n_ctrls])
for j in range(dyn.num_ctrls):
    pgen = optim.pulse_generator[j]
    pgen.init_pulse()
    init_amps[:, j] = pgen.gen_pulse()
dyn.initialize_controls(init_amps)

# 运行计算
result = optim.run_optimization()
# 可以保存参数到文件
dyn.save_amps("a.txt")

# 计算结果,除了自动报告外全是字符串
result.stats.report() #自动报告
result.evo_full_final #末态
result.initial_fid_err #初始保真度偏差
result.fid_err #最终偏差
result.termination_reason#结束原因
result.num_iter #迭代次数
datetime.timedelta(seconds=result.wall_time)#运行时长

# 画图
fig1 = plt.figure()
ax1 = fig1.add_subplot(2, 1, 1)
ax1.set_title("Initial Control amps")
ax1.set_xlabel("Time")
ax1.set_ylabel("Control amplitude")
for j in range(n_ctrls):
    ax1.step(result.time, 
             np.hstack((result.initial_amps[:, j], result.initial_amps[-1, j])), 
             where='post')
ax2 = fig1.add_subplot(2, 1, 2)
ax2.set_title("Optimised Control Amplitudes")
ax2.set_xlabel("Time")
ax2.set_ylabel("Control amplitude")
for j in range(n_ctrls):
    ax2.step(result.time, 
             np.hstack((result.final_amps[:, j], result.final_amps[-1, j])), 
             where='post', label='u{}'.format(j))
ax2.legend(loc=8, ncol=n_ctrls)
plt.tight_layout()
plt.show()


</pre>

		</div>
		<nav class="navbar">
			<span class="navbar-text">
				Page created on 2018-02-26
			</span>
		</nav>

	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- highlight.js -->
	<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
	<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
	<script>
		$(document).ready(function() {
			$('pre').each(function(i, block) {
				hljs.highlightBlock(block);
			});
			$('.article-toc ul li ul li ul li ul').hide();
		});
	</script>
	<!-- MathJax -->
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" src="../js/search.js"></script>
</body>
</html>
