<!doctype html>
<html lang="zh-cn">
	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

		<!-- Template -->
		<link rel="Stylesheet" type="text/css" href="../css/main.css" />
		<title>perl6</title>
	</head>

	<body>
		<div class="container">

			<nav class="navbar navbar-expand-lg sticky-top navbar-light bg-light">
				<a class="navbar-brand" href="../index.html">Chimez</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>

				<div class="collapse navbar-collapse" id="navbarTogglerDemo02">
					<ul class="navbar-nav mr-auto mt-2 mt-lg-0">
						<li class="nav-item active">
							<a class="nav-link" href="../articles_index.html">文章列表 <span class="sr-only">(current)</span></a>
					</ul>
					<form class="form-inline my-2 my-lg-0">
						<input class="form-control mr-sm-2" type="search" placeholder="Search">
						<button class="btn btn-outline-success my-2 my-sm-0" type="button">Search</button>
					</form>
				</div>
			</nav>

			<div class="row">
				
<p>
<div class="col-md-3 article-toc d-none d-md-block">
</p>
<div id="Contents" class="toc"><h1 id="Contents">Contents</h1></div>
<ul>
<li>
<a href="perl6.html#perl6">perl6</a>

<ul>
<li>
<a href="perl6.html#perl6-基本语法">基本语法</a>

<li>
<a href="perl6.html#perl6-常用方法和函数">常用方法和函数</a>

<ul>
<li>
<a href="perl6.html#perl6-常用方法和函数-数组">数组</a>

<li>
<a href="perl6.html#perl6-常用方法和函数-哈希表">哈希表</a>

<li>
<a href="perl6.html#perl6-常用方法和函数-字符串">字符串</a>

</ul>
<li>
<a href="perl6.html#perl6-逻辑控制">逻辑控制</a>

<li>
<a href="perl6.html#perl6-I&#47;O">I/O</a>

<li>
<a href="perl6.html#perl6-函数">函数</a>

<ul>
<li>
<a href="perl6.html#perl6-函数-定义函数">定义函数</a>

<li>
<a href="perl6.html#perl6-函数-匿名函数">匿名函数</a>

<li>
<a href="perl6.html#perl6-函数-实用高级函数">实用高级函数</a>

<ul>
<li>
<a href="perl6.html#perl6-函数-实用高级函数-map与hyper">map与hyper</a>

<li>
<a href="perl6.html#perl6-函数-实用高级函数-链式调用与Feed">链式调用与Feed</a>

</ul>
<li>
<a href="perl6.html#perl6-函数-Junctions">Junctions</a>

<li>
<a href="perl6.html#perl6-函数-惰性列表">惰性列表</a>

</ul>
<li>
<a href="perl6.html#perl6-面向对象">面向对象</a>

<li>
<a href="perl6.html#perl6-正则表达式">正则表达式</a>

<li>
<a href="perl6.html#perl6-模块">模块</a>

<li>
<a href="perl6.html#perl6-并行,并发,异步">并行,并发,异步</a>

<li>
<a href="perl6.html#perl6-C接口">C接口</a>

</ul>
<li>
<a href="perl6.html#进阶知识">进阶知识</a>

<ul>
<li>
<a href="perl6.html#进阶知识-grammar">grammar</a>

<li>
<a href="perl6.html#进阶知识-Phasers">Phasers</a>

<li>
<a href="perl6.html#进阶知识-库">库</a>

</ul>
</ul>

<p>
</div>
<div class="col-md-9 article-main">
</p>

<div id="perl6"><h1 id="perl6">perl6</h1></div>
<p>
Python很好很强大,但是在Linux运维总要写一些只执行一次的脚本,而且还不想多打字,写一堆框架,最重要的是perl6很有趣
</p>

<div id="perl6-基本语法"><h2 id="基本语法">基本语法</h2></div>
<table>
<tr>
<td>
<code>#</code>
</td>
<td>
单行注释
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>=   =</code>
</td>
<td>
多行注释
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
双引号<code>""</code>
</td>
<td>
解析字符串
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
单引号<code>""</code>
</td>
<td>
不解析直接输出
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>say "s"</code>
</td>
<td>
打印输出,原来的print
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>my $a="b"</code>
</td>
<td>
定义变量,注意是在作用域里的
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>my $a:=2</code>
</td>
<td>
绑定变量,也就是不可变const
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>$a</code>
</td>
<td>
标量
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>@arr</code>
</td>
<td>
向量,数组,列表
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>%map</code>
</td>
<td>
hash map
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>[+] 1,2,3 == 1+2+3</code>
</td>
<td>
归约运算
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>6 gcd 9 == 3</code>
</td>
<td>
最大公约数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>6 lcm 9 == 18</code>
</td>
<td>
最小公倍数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>3 div 2 == 1</code>
</td>
<td>
除法,商,向下取整
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>!=</code>
</td>
<td>
不等于
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>"a"~"b" == "ab"</code>
</td>
<td>
字符串连接
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>"a" x 3 == "aaa"</code>
</td>
<td>
字符串重复
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>2~~1==Flase</code>
</td>
<td>
智能匹配
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>?"a"==True</code>
</td>
<td>
强制转换为布尔值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>!"a"==Flase</code>
</td>
<td>
转换为布尔值并取反
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>0..^5==0,1,2,3,4</code>
</td>
<td>
构造区间,角表示不包括,左右都可以加
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>^5==0,1,2,3,4</code>
</td>
<td>
构造从0开始的区间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>0...99999</code>
</td>
<td>
构造惰性区间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>$var.WHAT</code>
</td>
<td>
返回类型
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>my Int @array = 1,2,3;</code>
</td>
<td>
显式指定类型
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<p>
<code>|(0..5)==(0,1,2,3,4,5)</code>: 解开构造 
</p>


<div id="perl6-常用方法和函数"><h2 id="常用方法和函数">常用方法和函数</h2></div>
<div id="perl6-常用方法和函数-数组"><h3 id="数组">数组</h3></div>
<table>
<tr>
<td>
<code>.elems</code>
</td>
<td>
返回列表中的元素个数。
</td>
</tr>
<tr>
<td>
<code>.push()</code>
</td>
<td>
向数组追加一个或多个元素
</td>
</tr>
<tr>
<td>
<code>.pop</code>
</td>
<td>
删除并返回数组中最后一个元素。
</td>
</tr>
<tr>
<td>
<code>.splice(a,b)</code>
</td>
<td>
会删除从位置 a 开始的 b 个元素。
</td>
</tr>
<tr>
<td>
<code>my @tbl[3;2];</code>
</td>
<td>
支持多维数组
</td>
</tr>
</table>

<p>
我们可以通过提供元素在数组中的位置来访问数组中特定元素 @animals[0]
</p>
<div id="perl6-常用方法和函数-哈希表"><h3 id="哈希表">哈希表</h3></div>


<table>
<tr>
<td>
<code>.push:(key =&gt; "value")</code>
</td>
<td>
添加一个新键值对。
</td>
</tr>
<tr>
<td>
<code>.kv</code>
</td>
<td>
返回一个包含所有键值对的列表。
</td>
</tr>
<tr>
<td>
<code>.keys</code>
</td>
<td>
返回一个包含所有键的列表。
</td>
</tr>
<tr>
<td>
<code>.values</code>
</td>
<td>
返回一个包含所有值的列表。
</td>
</tr>
</table>
<p>
我们可以通过哈希中特定值所对应的键来访问这个值。 %hash&lt;key&gt;
</p>

<div id="perl6-常用方法和函数-字符串"><h3 id="字符串">字符串</h3></div>
<table>
<tr>
<td>
<code>splice(",","a,b,c,d")</code>
</td>
<td>
分割字符串
</td>
</tr>
<tr>
<td>
<code>"s".trans('a'=&gt;'b')</code>
</td>
<td>
代替字符串
</td>
</tr>
<tr>
<td>
<code>"s".trim()</code>
</td>
<td>
去除前后空白
</td>
</tr>
<tr>
<td>
<code>"a\nb".join(",")</code>
</td>
<td>
连接多行
</td>
</tr>
<tr>
<td>
<code>index("asd","as")</code>
</td>
<td>
查找子串
</td>
</tr>
</table>

<div id="perl6-逻辑控制"><h2 id="逻辑控制">逻辑控制</h2></div>

<table>
<tr>
<td>
<code>if-elsif-else</code>
</td>
<td>
基本的if判断,不用加括号了
</td>
</tr>
<tr>
<td>
<code>unless</code>
</td>
<td>
相当于<code>if not</code>,不能接<code>else</code>
</td>
</tr>
<tr>
<td>
<code>with</code>
</td>
<td>
也是<code>if</code>,但会判断变量是否已定义,没定义不执行
</td>
</tr>
<tr>
<td>
<code>for</code>
</td>
<td>
现在相当于<code>for-in</code>
</td>
</tr>
<tr>
<td>
<code>loop</code>
</td>
<td>
这个是C的<code>for</code>
</td>
</tr>
<tr>
<td>
<code>given</code>
</td>
<td>
相当与<code>switch</code>,匹配成功就停止,指定<code>proceed</code>可以接着匹配
</td>
</tr>
<tr>
<td>
<code>try-catch</code>
</td>
<td>
异常处理,可以在<code>catch</code>里写<code>when,default</code>
</td>
</tr>
<tr>
<td>
<code>die "s"</code>
</td>
<td>
直接抛出ad-hoc异常
</td>
</tr>
<tr>
<td>
<code>.throw</code>
</td>
<td>
抛出对象异常
</td>
</tr>
</table>

<pre>
if $number-of-seats &lt;= 5 {
  say 'I am a sedan'
} elsif $number-of-seats &lt;= 7 {
  say 'I am 7 seater'
} else {
  say 'I am a van'
}

unless $clean-shoes {
  say 'Clean your shoes'
}

with $var {
  say 'Hello'
}

for @array -&gt; $array-item {
  say $array-item * 100
}

given $var {
    when 0..50 { say 'Less than or equal to 50';proceed}
    when Int { say "is an Int";proceed}
    when 42  { say 42 }
    default  { say "huh?" }
}

loop (my $i = 0; $i &lt; 5; $i++) {
  say "The current number is $i"
}

</pre>
	
<p>
异常
</p>
<pre>
try {
  #code goes in here
  #if anything goes wrong, the script will enter the below CATCH block
  #if nothing goes wrong the CATCH block will be ignored
  CATCH {
    when X::AdHoc { #do something if an exception of type X::AdHoc is thrown }
    when X::IO { #do something if an exception of type X::IO is thrown }
    when X::OS { #do something if an exception of type X::OS is thrown }
    default { #do something if an exception is thrown and doesn't belong to the above types }
  }
}
</pre>
<div id="perl6-I&#47;O"><h2 id="I&#47;O">I/O</h2></div>
<table>
<tr>
<td>
<code>say "a"</code>
</td>
<td>
到标准输出,带换行
</td>
</tr>
<tr>
<td>
<code>print "a"</code>
</td>
<td>
到标准输出,不换行
</td>
</tr>
<tr>
<td>
<code>get</code>
</td>
<td>
从终端获取输入
</td>
</tr>
<tr>
<td>
<code>prompt</code>
</td>
<td>
相当于<code>print+get</code>
</td>
</tr>
<tr>
<td>
<code>run "echo","a"</code>
</td>
<td>
不通过shell执行命令
</td>
</tr>
<tr>
<td>
<code>shell "ls"</code>
</td>
<td>
通过shell执行命令
</td>
</tr>
<tr>
<td>
<code>slurp "a.txt"</code>
</td>
<td>
读取文件
</td>
</tr>
<tr>
<td>
<code>spurt "b.txt", $b</code>
</td>
<td>
写入到文件
</td>
</tr>
<tr>
<td>
<code>dir "."</code>
</td>
<td>
列出所有文件和文件夹
</td>
</tr>
<tr>
<td>
<code>mkdir "n"</code>
</td>
<td>
创建目录
</td>
</tr>
<tr>
<td>
<code>rmdir "n"</code>
</td>
<td>
删除目录
</td>
</tr>
<tr>
<td>
<code>IO.e</code>
</td>
<td>
检查文件夹或文件是否存在。
</td>
</tr>
<tr>
<td>
<code>IO.f</code>
</td>
<td>
检查路径所指的是否为文件。
</td>
</tr>
<tr>
<td>
<code>IO.d</code>
</td>
<td>
检查路径所指的是否为文件夹。
</td>
</tr>
</table>

<div id="perl6-函数"><h2 id="函数">函数</h2></div>
<div id="perl6-函数-定义函数"><h3 id="定义函数">定义函数</h3></div>
<ul>
<li>
使用<code>sub</code>定义函数,使用<code>multi</code>定义多态函数(根据参数不同执行不同的内容)

<li>
参数可以省略:省略整个参数,省略参数类型

<li>
使用<code>x?</code>表示可选参数,使用<code>x=1</code>表示默认参数

<li>
返回值可以指定类型也可以不指定

<li>
指定返回值类型可以用箭头<code>($x--&gt;Int)</code>也可以用<code>returns Int</code>

<li>
返回值的类型用<code>Int:D</code>表示必须已定义,用<code>Int:U</code>表示不用严格定义

</ul>

<pre>
sub alien-greeting {
  say "Hello earthlings";
}
sub say-hello (Str $name) {
    say "Hello " ~ $name ~ "!!!!"
}
multi greet($name, $title) {
    say "Good morning $title $name";
}
sub say-hello($name?) {
  with $name { say "Hello " ~ $name }
  else { say "Hello Human" }
}
sub say-hello($name="Matt") {
  say "Hello " ~ $name;
}
sub squared ($x) returns Int {
  return $x ** 2;
}
sub squared ($x --&gt; Int) {
  return $x ** 2;
}
sub squared ($x --&gt; Int:D) {
  return $x ** 2;
}

</pre>

<div id="perl6-函数-匿名函数"><h3 id="匿名函数">匿名函数</h3></div>
<ul>
<li>
函数名前加上<code>&amp;</code>就可以当作普通参数传递

<li>
<code>-&gt; \(x {\)x}</code>:隐式返回值

</ul>

<pre>
my $squared = -&gt; $x {
    $x ** 2
}
say $squared(9);
</pre>
<div id="perl6-函数-实用高级函数"><h3 id="实用高级函数">实用高级函数</h3></div>
<div id="perl6-函数-实用高级函数-map与hyper"><h4 id="map与hyper">map与hyper</h4></div>
<ul>
<li>
在列表上每个元素执行函数,结果也是列表

<li>
map应用的是函数

<li>
hyper<code>&gt;&gt;</code>应用的是方法

</ul>

<pre>
map(&amp;squared, @array);
map(&amp;func, @array)
my @array = &lt;0 1 2 3 4 5 6 7 8 9 10&gt;;
sub is-even($var) { $var %% 2 };

say @array».is-prime;
say @array».&amp;is-even;
</pre>
	
<div id="perl6-函数-实用高级函数-链式调用与Feed"><h4 id="链式调用与Feed">链式调用与Feed</h4></div>
<pre>

my @final-array = reverse(sort(unique(@array)));

my @final-array = @array.unique.sort.reverse;

@array ==&gt; unique()
       ==&gt; sort()
       ==&gt; reverse()
       ==&gt; my @final-array;

my @final-array-v2 &lt;== reverse()
                   &lt;== sort()
                   &lt;== unique()
                   &lt;== @array;
</pre>

<div id="perl6-函数-Junctions"><h3 id="Junctions">Junctions</h3></div>
<p>
值的逻辑叠加
</p>
<pre>
my $var = 2;
if $var == 1|2|3 {
    say "The variable is 1 or 2 or 3"
}
</pre>
	
<div id="perl6-函数-惰性列表"><h3 id="惰性列表">惰性列表</h3></div>
<ul>
<li>
惰性列表需要一个初始元素,一个生成器和一个结束点

<li>
使用<code>Inf</code>生成无穷列表

<li>
对于一些情况,默认的生成器可以进行推断生成

<li>
结束点必须能被生成器到达,否则跳过结束点则会使生成器永不停止

<li>
惰性生成也有修饰语法用来表示结束点范围

</ul>

<pre>

my  $lazylist = (1 ... 10);

my  $lazylist = (1 ... Inf);

my  $lazylist = (0,2 ... 10);

my  $lazylist = (0, { $_ + 3 } ... 12);

my  $lazylist = (0, { $_ + 3 } ...^ * &gt; 10);
</pre>
	
<div id="perl6-面向对象"><h2 id="面向对象">面向对象</h2></div>

<table>
<tr>
<td>
<code>class C is P dose R</code>
</td>
<td>
定义类,用<code>is</code>表示继承关系,写几个<code>is</code>可表示多重继承
</td>
</tr>
<tr>
<td>
<code>role</code>
</td>
<td>
和类差不多,继承时用<code>dose</code>,只不过会在冲突时发出提示,需要重载
</td>
</tr>
<tr>
<td>
<code>has</code>
</td>
<td>
定义对象属性,类的实例的属性
</td>
</tr>
<tr>
<td>
<code>my</code>
</td>
<td>
定义类属性,类本身的属性
</td>
</tr>
<tr>
<td>
<code>.new</code>
</td>
<td>
构造函数
</td>
</tr>
<tr>
<td>
<code>$!name</code>
</td>
<td>
声明私有属性
</td>
</tr>
<tr>
<td>
<code>$.name</code>
</td>
<td>
自动生成存取器,用于访问变量,公开属性
</td>
</tr>
<tr>
<td>
<code>has $.age is rw</code>
</td>
<td>
声明可修改的属性
</td>
</tr>
<tr>
<td>
<code>method</code>
</td>
<td>
定义类方法,不需要在参数里写<code>self</code>,支持重载
</td>
</tr>
<tr>
<td>
<code>method !m</code>
</td>
<td>
定义私有方法
</td>
</tr>
<tr>
<td>
<code>self!m</code>
</td>
<td>
调用私有方法
</td>
</tr>
<tr>
<td>
<code>submethod</code>
</td>
<td>
定义不能被继承的方法
</td>
</tr>
<tr>
<td>
<code>.WHAT</code>
</td>
<td>
返回已经创建的对象所属的类。
</td>
</tr>
<tr>
<td>
<code>.^attributes</code>
</td>
<td>
返回一个包含该对象所有属性的列表。
</td>
</tr>
<tr>
<td>
<code>.^mtethods</code>
</td>
<td>
返回能在该对象身上调用的所有方法。
</td>
</tr>
<tr>
<td>
<code>.^parents</code>
</td>
<td>
返回该对象所属类的所有父类。
</td>
</tr>
<tr>
<td>
<code>~~</code>
</td>
<td>
叫做智能匹配操作符。 如果对象是从它所进行比较的类或任何它继承的类创建的, 则计算为 True。
</td>
</tr>
</table>



<div id="perl6-正则表达式"><h2 id="正则表达式">正则表达式</h2></div>
<table>
<tr>
<td>
<code>/p/</code>
</td>
<td>
正则表达式
</td>
</tr>
<tr>
<td>
<code>m/p/</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>rx/p/</code>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<code>/:s p/</code>
</td>
<td>
空格包括在内
</td>
</tr>
<tr>
<td>
<code>&lt;:N&gt;</code>
</td>
<td>
unicode数字
</td>
</tr>
<tr>
<td>
<code>&lt;:Lu&gt;</code>
</td>
<td>
unicode大写字母
</td>
</tr>
<tr>
<td>
<code>&lt;:Pd&gt;</code>
</td>
<td>
unicode dash
</td>
</tr>
<tr>
<td>
<code>&lt;:L&gt;</code>
</td>
<td>
匹配单个字符
</td>
</tr>
<tr>
<td>
<code>.</code>
</td>
<td>
任意单个字符
</td>
</tr>
<tr>
<td>
<code>?</code>
</td>
<td>
0或1次
</td>
</tr>
<tr>
<td>
<code>*</code>
</td>
<td>
0或多次
</td>
</tr>
<tr>
<td>
<code>+</code>
</td>
<td>
至少一次
</td>
</tr>
<tr>
<td>
<code>$/</code>
</td>
<td>
匹配的结果对象
</td>
</tr>
<tr>
<td>
<code>.prematch</code>
</td>
<td>
返回匹配前面的字符串
</td>
</tr>
<tr>
<td>
<code>.postmatch</code>
</td>
<td>
返回匹配后面的字符串
</td>
</tr>
<tr>
<td>
<code>.from</code>
</td>
<td>
返回匹配的开始位置
</td>
</tr>
<tr>
<td>
<code>.to</code>
</td>
<td>
返回匹配的结束位置
</td>
</tr>
</table>

<ul>
<li>
在正则表达式中只有字母和数字下划线不用转义,别的都得用<code>\</code>,<code>''</code>转义

<li>
可以对于正则表达式中某个部分进行命名<code>my regex many-letters { &lt;:L&gt;+ };</code>以后可以写成<code>/&lt;many-letters&gt;/</code>

</ul>
<div id="perl6-模块"><h2 id="模块">模块</h2></div>
<ul>
<li>
使用<code>zef</code>安装模块

<li>
使用<code>use Digest::MD5;</code>引入模块

</ul>
<div id="perl6-并行,并发,异步"><h2 id="并行,并发,异步">并行,并发,异步</h2></div>
<table>
<tr>
<td>
<code>@a.race.map</code>
</td>
<td>
数据并行化,不保存顺序,在一个列表上运行函数
</td>
</tr>
<tr>
<td>
<code>@a.hyper.map</code>
</td>
<td>
数据并行化,保持顺序
</td>
</tr>
<tr>
<td>
<code>$a = start @m.map</code>
</td>
<td>
开启并行线程执行函数
</td>
</tr>
<tr>
<td>
<code>@a = await $a</code>
</td>
<td>
获得线程结果
</td>
</tr>
</table>

<div id="perl6-C接口"><h2 id="C接口">C接口</h2></div>

<pre>
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";

sub hellofromc() is native(LIBPATH) { * };#从动态链接库里引出函数
sub hello() is native(LIBPATH) is symbol('hellofromc') { * }#引出函数并重命名
sub hello(Str) is native(LIBPATH) is symbol('hellofromc') { * }#引出函数,重命名并定义传入参数类型
sub add(int32,int32) returns int32 is native(LIBPATH) { * }#引出函数,定义传入传出参数类型

hellofromc();

</pre>
	
<div id="进阶知识"><h1 id="进阶知识">进阶知识</h1></div>
<div id="进阶知识-grammar"><h2 id="grammar">grammar</h2></div>
<ul>
<li>
grammar提供了利用正则构造词法分析器的功能,通过它可以分分钟写个DSL出来,还可以用来构造文本数据结构,解析HTML,甚至将js之类的语言在perl6里执行

<li>
行为既可以单独指定,也可以写在里面,自动执行

</ul>

<table>
<tr>
<td>
<code>grammar G{}</code>
</td>
<td>
创建新语法规则
</td>
</tr>
<tr>
<td>
<code>token N {}</code>
</td>
<td>
定义词法匹配
</td>
</tr>
<tr>
<td>
<code>rule R {}</code>
</td>
<td>
定义行为,匹配后返回
</td>
</tr>
<tr>
<td>
<code>proto token T{}</code>
</td>
<td>
创建匹配的行为
</td>
</tr>
<tr>
<td>
<code>my $m = REST.parse('/ product / update /7 /notify');</code>
</td>
<td>
执行语法解析
</td>
</tr>
<tr>
<td>
<code>my \(matchObject = REST.parse(\)uri, actions =&gt; REST-actions.new);</code>
</td>
<td>
执行语法解析并执行行为
</td>
</tr>
<tr>
<td>
<code>my \(matchObject = REST.parse(\)uri, :actions(REST-actions.new));</code>
</td>
<td>
同上,另一种风格
</td>
</tr>
</table>

<pre>
grammar REST
{
    token TOP { &lt;slash&gt;&lt;subject&gt;&lt;slash&gt;&lt;command&gt;[&lt;slash&gt;&lt;data&gt;]? }
 
    proto token command {*}
    token command:sym&lt;create&gt;   { &lt;sym&gt; }
    token command:sym&lt;retrieve&gt; { &lt;sym&gt; }
    token command:sym&lt;update&gt;   { &lt;sym&gt; }
    token command:sym&lt;delete&gt;   { &lt;sym&gt; }
 
    token subject { \w+ }
    token data    { .* }
    token slash   { \s* '/' \s* }
}
 
 
class REST-actions
{
    method TOP ($/) {
        make { subject    =&gt; $&lt;subject&gt;.Str,
               command    =&gt; $&lt;command&gt;.Str,
               data       =&gt; $&lt;data&gt;.made,
               subject-id =&gt; $&lt;data&gt;.made[0] }
    }
 
    method data($/) { make $/.split('/') }
}

grammar G {
  rule TOP { &lt;function-define&gt; }
  rule function-define {
    'sub' &lt;identifier&gt;
    {
      say "func " ~ $&lt;identifier&gt;.made;
      make $&lt;identifier&gt;.made;
    }
    '(' &lt;parameter&gt; ')' '{' '}'
    { say "end " ~ $/.made; }
  }
  token identifier { \w+ { make ~$/; } }
  token parameter { \w+ { say "param " ~ $/; } }
}
 
G.parse('sub f ( a ) { }');

</pre>
<div id="进阶知识-Phasers"><h2 id="Phasers">Phasers</h2></div>
<ul>
<li>
起到类似装饰器的作用,对函数的编译期或运行期行为进行调整和附加

</ul>

<table>
<tr>
<td>
<code>BEGIN {...} </code>
</td>
<td>
* at compile time, ASAP, only ever runs once
</td>
</tr>
<tr>
<td>
<code>CHECK {...} </code>
</td>
<td>
* at compile time, ALAP, only ever runs once
</td>
</tr>
<tr>
<td>
<code>INIT {...} </code>
</td>
<td>
* at run time, ASAP, only ever runs once
</td>
</tr>
<tr>
<td>
<code>END {...} </code>
</td>
<td>
at run time, ALAP, only ever runs once
</td>
</tr>
<tr>
<td>
<code>ENTER {...} </code>
</td>
<td>
* at every block entry time, repeats on loop blocks.
</td>
</tr>
<tr>
<td>
<code>LEAVE {...} </code>
</td>
<td>
at every block exit time (even stack unwinds from exceptions)
</td>
</tr>
<tr>
<td>
<code>KEEP {...} </code>
</td>
<td>
at every successful block exit, part of LEAVE queue
</td>
</tr>
<tr>
<td>
<code>UNDO {...} </code>
</td>
<td>
at every unsuccessful block exit, part of LEAVE queue
</td>
</tr>
<tr>
<td>
<code>FIRST {...} </code>
</td>
<td>
at loop initialization time, before any ENTER
</td>
</tr>
<tr>
<td>
<code>NEXT {...} </code>
</td>
<td>
at loop continuation time, before any LEAVE
</td>
</tr>
<tr>
<td>
<code>LAST {...} </code>
</td>
<td>
at loop termination time, after any LEAVE
</td>
</tr>
<tr>
<td>
<code>PRE {...} </code>
</td>
<td>
assert precondition at every block entry, before ENTER
</td>
</tr>
<tr>
<td>
<code>POST {...} </code>
</td>
<td>
assert postcondition at every block exit, after LEAVE
</td>
</tr>
<tr>
<td>
<code>CATCH {...} </code>
</td>
<td>
catch exceptions, before LEAVE
</td>
</tr>
<tr>
<td>
<code>CONTROL {...} </code>
</td>
<td>
catch control exceptions, before LEAVE
</td>
</tr>
<tr>
<td>
<code>LAST {...} </code>
</td>
<td>
supply tapped by whenever-block is done, runs very last
</td>
</tr>
<tr>
<td>
<code>QUIT {...} </code>
</td>
<td>
catch async exceptions within a whenever-block, runs very last
</td>
</tr>
<tr>
<td>
<code>COMPOSE {...} </code>
</td>
<td>
when a role is composed into a class
</td>
</tr>
<tr>
<td>
<code>CLOSE   {...} </code>
</td>
<td>
appears in a supply block, called when the supply is closed
</td>
</tr>
</table>
<div id="进阶知识-库"><h2 id="库">库</h2></div>

		</div>
		<nav class="navbar">
			<span class="navbar-text">
				Page created on 2018-02-21
			</span>
		</nav>

	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- highlight.js -->
	<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
	<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
	<script>
		$(document).ready(function() {
			$('pre').each(function(i, block) {
				hljs.highlightBlock(block);
			});
			$('.article-toc ul li ul li ul li ul').hide();
		});
	</script>
	<!-- MathJax -->
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" src="../js/search.js"></script>
</body>
</html>
