<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-12-19 Sat 14:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>javascript</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" static="static/lib/js/jquery.min.js"></script>
<script type="text/javascript" static="static/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" static="static/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" static="static/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style> p{max-width:800px;}</style>
<style> li{max-width:800px;}</style
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">javascript</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbcadaa1">1. JavaScript 基本语法</a>
<ul>
<li><a href="#org0b7e48b">1.1. 特殊规则</a></li>
<li><a href="#org04f6702">1.2. 声明变量</a></li>
<li><a href="#orgaab53f6">1.3. 运算符</a></li>
<li><a href="#org4de4eb6">1.4. 控制流程</a>
<ul>
<li><a href="#orgd56d379">1.4.1. 条件判断</a></li>
<li><a href="#org17782cb">1.4.2. 错误处理</a></li>
<li><a href="#orgf60a1a6">1.4.3. Promise</a></li>
<li><a href="#org269ee78">1.4.4. 循环</a></li>
<li><a href="#org6a44fec">1.4.5. 迭代器</a></li>
</ul>
</li>
<li><a href="#org73230a0">1.5. 函数</a>
<ul>
<li><a href="#org8cb92d6">1.5.1. 定义函数</a></li>
<li><a href="#orgd98166e">1.5.2. 匿名函数</a></li>
<li><a href="#orgbe762ec">1.5.3. 递归调用</a></li>
<li><a href="#org37a8989">1.5.4. 闭包</a></li>
<li><a href="#orgfb987ba">1.5.5. 函数参数</a></li>
<li><a href="#org386612e">1.5.6. 箭头函数</a></li>
<li><a href="#org02ea0a4">1.5.7. <code>this</code> 词法作用域</a></li>
</ul>
</li>
<li><a href="#org384cbcb">1.6. 数据类型</a>
<ul>
<li><a href="#org59ffcfc">1.6.1. 数据类型</a></li>
<li><a href="#orgfdcf31c">1.6.2. 数据类型转换</a></li>
<li><a href="#org89f7a07">1.6.3. 字面量</a></li>
<li><a href="#orgc5be46c">1.6.4. 数字与数学运算</a></li>
<li><a href="#orgbb1939a">1.6.5. 日期对象</a></li>
<li><a href="#org5907c2f">1.6.6. 字符串</a></li>
<li><a href="#org004ef1a">1.6.7. 正则表达式</a></li>
<li><a href="#orgc4e9c1c">1.6.8. 数组对象 <code>Array object</code></a></li>
<li><a href="#orgcdd563b">1.6.9. 映射</a></li>
<li><a href="#org9943e71">1.6.10. 集合</a></li>
<li><a href="#org408483d">1.6.11. 使用对象</a></li>
</ul>
</li>
<li><a href="#org320d19c">1.7. 内建函数</a></li>
<li><a href="#orgccacc23">1.8. 元编程</a>
<ul>
<li><a href="#org7b1bf41">1.8.1. 代理 <code>Proxy</code></a></li>
<li><a href="#org01ac64d">1.8.2. 反射 <code>Reflect</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfe93708">2. React</a>
<ul>
<li><a href="#org940bcaa">2.1. 基本使用</a>
<ul>
<li><a href="#orgd25a85f">2.1.1. 创建新应用的方法</a></li>
<li><a href="#org11b12d1">2.1.2. 工作流程</a></li>
</ul>
</li>
<li><a href="#orgb270644">2.2. API</a>
<ul>
<li><a href="#org77d8db0">2.2.1. 示例代码</a></li>
</ul>
</li>
<li><a href="#org1d63e6b">2.3. 开始新项目: yarn, create-react-app</a>
<ul>
<li><a href="#org996142c">2.3.1. yarn</a></li>
<li><a href="#orgb4d1986">2.3.2. create-react-app</a></li>
</ul>
</li>
<li><a href="#org87cb042">2.4. redux: 状态管理</a>
<ul>
<li><a href="#orgc6e9493">2.4.1. 安装</a></li>
<li><a href="#org01ac383">2.4.2. 基本使用</a></li>
</ul>
</li>
<li><a href="#orgdfe6961">2.5. react-router: 路由管理</a>
<ul>
<li><a href="#org3e6e743">2.5.1. 安装与基本使用</a></li>
<li><a href="#orga476d7f">2.5.2. 与 redux 一起使用</a></li>
</ul>
</li>
<li><a href="#orgafa8c8f">2.6. emotion: css-in-js</a>
<ul>
<li><a href="#orgf258ec5">2.6.1. 基本使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1d093d1">3. bootstrap4</a>
<ul>
<li><a href="#org8b05939">3.1. 安装与基本使用</a>
<ul>
<li><a href="#org55a0bf8">3.1.1. 安装</a></li>
<li><a href="#org6248b84">3.1.2. 网格系统</a></li>
</ul>
</li>
<li><a href="#org9b20ba3">3.2. 各种CSS组件</a>
<ul>
<li><a href="#orgdf4c64e">3.2.1. 固定在上方的导航栏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga8c6392">4. Angular</a></li>
<li><a href="#org0757e7d">5. Electron基础</a>
<ul>
<li><a href="#orgfcdf6f1">5.1. 安装</a></li>
<li><a href="#org0e504c4">5.2. 程序结构</a>
<ul>
<li><a href="#org0c3d060">5.2.1. 语法</a></li>
</ul>
</li>
<li><a href="#org735fcf6">5.3. 页面(进程)间通信</a>
<ul>
<li><a href="#org3b0fea2">5.3.1. 广播-监听方式</a></li>
</ul>
</li>
<li><a href="#orgc359670">5.4. https://electron.org.cn/doc/tutorial/application-distribution.html|打包</a></li>
<li><a href="#org53d0770">5.5. 使用React</a>
<ul>
<li><a href="#org3cab204">5.5.1. 配置</a></li>
<li><a href="#org5199efd">5.5.2. 热调试</a></li>
<li><a href="#org8c9f91c">5.5.3. 使用electron API</a></li>
<li><a href="#org4183073">5.5.4. 使用nodejs本地库</a></li>
</ul>
</li>
<li><a href="#orgd9a2048">5.6. API</a>
<ul>
<li><a href="#orgbfd0b41">5.6.1. app:应用的生命周期</a></li>
<li><a href="#orgbcde6be">5.6.2. BrowserWindow:创建和控制浏览器窗口</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>





<div id="outline-container-orgbcadaa1" class="outline-2">
<h2 id="orgbcadaa1"><span class="section-number-2">1</span> JavaScript 基本语法</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0b7e48b" class="outline-3">
<h3 id="org0b7e48b"><span class="section-number-3">1.1</span> 特殊规则</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>js 中解释器会在每行后自动插入分号, 因而可以不写分号, 但是可能会造成一些困惑, 因此推荐写上所有括号.</li>
<li>单行注释 <code>//</code></li>
<li>多行注释 <code>/* ... */</code></li>
</ol>
</div>
</div>
<div id="outline-container-org04f6702" class="outline-3">
<h3 id="org04f6702"><span class="section-number-3">1.2</span> 声明变量</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>声明变量可以使用三种方式:
<ol class="org-ol">
<li><code>var</code> 会声明一个全局变量,会发生"变量提升",即会被当成放在最顶部的量,这会极大影响可读性,应避免使用</li>
<li><code>let</code> 会声明一个有作用域的变量</li>
<li><code>const</code> 会声明一个有作用域的常量</li>
</ol></li>
<li>推荐使用 <code>let</code> 和 <code>const</code>, 不要用 <code>var</code>.</li>
<li>声明变量可以不带初值 <code>let a;</code>, 也可以带初值 <code>let a=1;</code>, 不带初值的变量声明和没声明一样, 可以用 <code>x === undefined</code> 来判断.</li>
<li>变量名可以以字母, <code>$</code> 号 和 <code>_</code> 下划线开头.</li>
<li><code>undefined</code> 相当于 <code>false</code>.</li>
<li><code>null</code> 相当于 <code>0</code> 或 <code>false</code>.</li>
<li>被设成常量的数组和对象都是可变的,其他类型不可变</li>
</ol>
</div>
</div>
<div id="outline-container-orgaab53f6" class="outline-3">
<h3 id="orgaab53f6"><span class="section-number-3">1.3</span> 运算符</h3>
<div class="outline-text-3" id="text-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">作用</th>
<th scope="col" class="org-left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>赋值运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>=</code></td>
<td class="org-left">赋值</td>
<td class="org-left"><code>a=b</code></td>
</tr>

<tr>
<td class="org-left"><code>+=</code></td>
<td class="org-left">加并赋值</td>
<td class="org-left"><code>a+=b</code></td>
</tr>

<tr>
<td class="org-left"><b>比较运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>===</code></td>
<td class="org-left">相等</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>!==</code></td>
<td class="org-left">不相等</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>算数运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>%</code></td>
<td class="org-left">求余</td>
<td class="org-left"><code>12%5===2</code></td>
</tr>

<tr>
<td class="org-left"><code>++</code></td>
<td class="org-left">自增</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>**</code></td>
<td class="org-left">指数</td>
<td class="org-left"><code>2**3===2*2*2</code></td>
</tr>

<tr>
<td class="org-left"><b>位运算</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>&amp;</code></td>
<td class="org-left">按位于</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>~</code></td>
<td class="org-left">非</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>&lt;&lt;</code></td>
<td class="org-left">左移位</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>逻辑运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>&amp;&amp;</code></td>
<td class="org-left">与</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>¦¦</code></td>
<td class="org-left">或</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>!</code></td>
<td class="org-left">非</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>三元运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>? :</code></td>
<td class="org-left">三元运算符</td>
<td class="org-left"><code>var status = (age &gt;= 18) ? "adult" : "minor";</code></td>
</tr>

<tr>
<td class="org-left"><b>一元运算符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>delete</code></td>
<td class="org-left">删除一个对象或对象的一个键值</td>
<td class="org-left"><code>delete objectName.property;</code></td>
</tr>

<tr>
<td class="org-left"><code>typeof</code></td>
<td class="org-left">返回类型</td>
<td class="org-left"><code>typeof operand</code></td>
</tr>

<tr>
<td class="org-left"><code>void</code></td>
<td class="org-left">运算无返回值</td>
<td class="org-left"><code>void expression</code></td>
</tr>

<tr>
<td class="org-left"><b>关系操作符</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>in</code></td>
<td class="org-left">判断属性是否在对象中</td>
<td class="org-left"><code>propNameOrNumber in objectName</code></td>
</tr>

<tr>
<td class="org-left"><code>instanceof</code></td>
<td class="org-left">判断对象是否为某类型</td>
<td class="org-left"><code>objectName instanceof objectType</code></td>
</tr>

<tr>
<td class="org-left"><b>基本表达式</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>this</code></td>
<td class="org-left">指代当前对象</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>左值表达式</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>new</code></td>
<td class="org-left">创建一个实例</td>
<td class="org-left"><code>var objectName = new objectType([param]);</code></td>
</tr>

<tr>
<td class="org-left"><b>扩展语句</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>...</code></td>
<td class="org-left">扩展一个数组</td>
<td class="org-left"><code>['head', ...['shoulder', 'knees'], 'and', 'toes'];</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4de4eb6" class="outline-3">
<h3 id="org4de4eb6"><span class="section-number-3">1.4</span> 控制流程</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgd56d379" class="outline-4">
<h4 id="orgd56d379"><span class="section-number-4">1.4.1</span> 条件判断</h4>
<div class="outline-text-4" id="text-1-4-1">
</div>
<ol class="org-ol">
<li><a id="org7683e55"></a><code>if-else</code> 条件判断<br />
<div class="outline-text-5" id="text-1-4-1-1">
<div class="org-src-container">
<pre class="src src-javascript">if (condition_1) {
    statement_1;
}
[else if (condition_2) {
    statement_2;
}]
...
    [else if (condition_n_1) {
	statement_n_1;
    }]
[else {
    statement_n;
}]
</pre>
</div>
</div>
</li>
<li><a id="org5c2be72"></a><code>switch</code><br />
<div class="outline-text-5" id="text-1-4-1-2">
<div class="org-src-container">
<pre class="src src-javascript">switch (expression) {
case label_1:
    statements_1
    [break;]
case label_2:
    statements_2
    [break;]
    ...
default:
    statements_def
    [break;]
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org17782cb" class="outline-4">
<h4 id="org17782cb"><span class="section-number-4">1.4.2</span> 错误处理</h4>
<div class="outline-text-4" id="text-1-4-2">
</div>
<ol class="org-ol">
<li><a id="orgfbf92da"></a><code>throw</code><br />
<div class="outline-text-5" id="text-1-4-2-1">
<p>
可以 <code>throw</code> 任何东西, 但使用 DOMError 或 ECMAScript 比较好
</p>
<div class="org-src-container">
<pre class="src src-javascript">throw expression;
</pre>
</div>
</div>
</li>
<li><a id="org925fae6"></a><code>try-catch-fanilly</code><br />
<div class="outline-text-5" id="text-1-4-2-2">
<div class="org-src-container">
<pre class="src src-javascript">openMyFile();
try {
    writeMyFile(theData); //This may throw a error
}catch(e){
    handleError(e); // If we got a error we handle it
}finally {
    closeMyFile(); // always close the resource
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgf60a1a6" class="outline-4">
<h4 id="orgf60a1a6"><span class="section-number-4">1.4.3</span> Promise</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Promise 对象有以下几种状态：
</p>
<ol class="org-ol">
<li><code>pending</code> ：初始的状态，即正在执行，不处于 <code>fulfilled</code> 或 <code>rejected</code> 状态。</li>
<li><code>fulfilled</code> ：成功的完成了操作。</li>
<li><code>rejected</code> ：失败，没有完成操作。</li>
<li><code>settled</code> ：Promise 处于 <code>fulfilled</code> 或 <code>rejected</code> 二者中的任意一个状态, 不会是 <code>pending</code></li>
</ol>
</div>
<ol class="org-ol">
<li><a id="org9db0078"></a>使用 promise<br />
<div class="outline-text-5" id="text-1-4-3-1">
<div class="org-src-container">
<pre class="src src-javascript">// 基本的回调
doSomething().then(successCallback, failureCallback);
// 可以加上回调链和最终错误处理
doSomething()
.then(result =&gt; doSomethingElse(result))
.then(newResult =&gt; doThirdThing(newResult))
.then(finalResult =&gt; {
  console.log(`Got the final result: ${finalResult}`);
})
.catch(failureCallback);
</pre>
</div>
</div>
</li>
<li><a id="org258180a"></a>async await 语法糖<br />
<div class="outline-text-5" id="text-1-4-3-2">
<div class="org-src-container">
<pre class="src src-javascript">async function foo() {
  try {
    let result = await doSomething();
    let newResult = await doSomethingElse(result);
    let finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch(error) {
    failureCallback(error);
  }
}
</pre>
</div>
</div>
</li>
<li><a id="orgb81e31a"></a>创建 Promise<br />
<ol class="org-ol">
<li><a id="orgfa30452"></a>包裹旧式 api<br />
<div class="outline-text-6" id="text-1-4-3-3-1">
<div class="org-src-container">
<pre class="src src-javascript">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

wait(10000).then(() =&gt; saySomething("10 seconds")).catch(failureCallback);
</pre>
</div>
</div>
</li>
<li><a id="org4ad0670"></a>一些方法<br />
<div class="outline-text-6" id="text-1-4-3-3-2">
<p>
Promise.resolve() 和 Promise.reject() 是手动创建一个已经resolve或者reject的promise快捷方法。它们有时很有用。
</p>

<p>
Promise.all() 和 Promise.race()是并行运行异步操作的两个组合式工具。
</p>
</div>
</li>
</ol>
</li>
<li><a id="orgbcadc06"></a>保证并行执行的方法<br />
<div class="outline-text-5" id="text-1-4-3-4">
<div class="org-src-container">
<pre class="src src-javascript">[func1, func2].reduce((p, f) =&gt; p.then(f), Promise.resolve());
// 或者
for (let f of [func1, func2]) {
  await f();
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org269ee78" class="outline-4">
<h4 id="org269ee78"><span class="section-number-4">1.4.4</span> 循环</h4>
<div class="outline-text-4" id="text-1-4-4">
</div>
<ol class="org-ol">
<li><a id="orgfcd745f"></a><code>for</code><br />
<div class="outline-text-5" id="text-1-4-4-1">
<div class="org-src-container">
<pre class="src src-javascript">for (var i = 0; i &lt; selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
	numberSelected++;
    }
}
</pre>
</div>
</div>
</li>
<li><a id="orgf07a626"></a><code>do...while</code><br />
<div class="outline-text-5" id="text-1-4-4-2">
<div class="org-src-container">
<pre class="src src-javascript">do {
    i += 1;
    console.log(i);
} while (i &lt; 5);
</pre>
</div>
</div>
</li>
<li><a id="org084f779"></a><code>while</code><br />
<div class="outline-text-5" id="text-1-4-4-3">
<div class="org-src-container">
<pre class="src src-javascript">while (n &lt; 3) {
    n++;
    x += n;
}
</pre>
</div>
</div>
</li>
<li><a id="orgf637cb4"></a><code>label-break</code><br />
<div class="outline-text-5" id="text-1-4-4-4">
<div class="org-src-container">
<pre class="src src-javascript">var x = 0;
var z = 0
labelCancelLoops: while (true) {
    console.log("外部循环: " + x);
    x += 1;
    z = 1;
    while (true) {
	console.log("内部循环: " + z);
	z += 1;
	if (z === 10 &amp;&amp; x === 10) {
	    break labelCancelLoops;
	} else if (z === 10) {
	    break;
	}
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org0f01d49"></a><code>label-continue</code><br />
<div class="outline-text-5" id="text-1-4-4-5">
<div class="org-src-container">
<pre class="src src-javascript">var i = 0;
var j = 10;
checkiandj:
while (i &lt; 4) {
    console.log(i);
    i += 1;
    checkj:
    while (j &gt; 4) {
	console.log(j);
	j -= 1;
	if ((j % 2) == 0) {
	    continue checkj;
	}
	console.log(j + ' is odd.');
    }
    console.log('i = ' + i);
    console.log('j = ' + j);
}
</pre>
</div>
</div>
</li>
<li><a id="org8ce98e0"></a><code>for-in</code><br />
<div class="outline-text-5" id="text-1-4-4-6">
<p>
注意遍历的是对象的属性, 对于数组,会是数组下标
</p>
<div class="org-src-container">
<pre class="src src-javascript">for (var i in obj) {
    result += obj_name + "." + i + " = " + obj[i] + "&lt;br&gt;";
}
</pre>
</div>
</div>
</li>
<li><a id="org0bf4198"></a><code>for-of</code><br />
<div class="outline-text-5" id="text-1-4-4-7">
<p>
遍历的是可迭代的类型
</p>
<div class="org-src-container">
<pre class="src src-javascript">for (let i of arr) {
    console.log(i); // logs "3", "5", "7" // 注意这里没有 hello
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org6a44fec" class="outline-4">
<h4 id="org6a44fec"><span class="section-number-4">1.4.5</span> 迭代器</h4>
<div class="outline-text-4" id="text-1-4-5">
</div>
<ol class="org-ol">
<li><a id="org94e0a4b"></a>创建迭代器<br />
<div class="outline-text-5" id="text-1-4-5-1">
<p>
一个提供 <code>next</code> 方法的函数就组成了一个迭代器
</p>
<div class="org-src-container">
<pre class="src src-javascript">function makeIterator(array){
    var nextIndex = 0;

    return {
       next: function(){
	   return nextIndex &lt; array.length ?
	       {value: array[nextIndex++], done: false} :
	       {done: true};
       }
    };
}
// 使用
var it = makeIterator(['yo', 'ya']);
console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done);  // true
</pre>
</div>
</div>
</li>
<li><a id="org82a56ff"></a>迭代器生成器 <code>function*</code><br />
<div class="outline-text-5" id="text-1-4-5-2">
<p>
使用 <code>function*</code> 语法可以让创建迭代器变得简单些
</p>
<div class="org-src-container">
<pre class="src src-javascript">function* idMaker() {
  var index = 0;
  while(true)
    yield index++;
}

var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
// ...
</pre>
</div>
</div>
</li>
<li><a id="orgcb320a8"></a>可迭代的对象<br />
<div class="outline-text-5" id="text-1-4-5-3">
<p>
想用 <code>for of</code> 迭代对象, 则需要实现 <code>Symbol.iterator</code> 属性
</p>
<div class="org-src-container">
<pre class="src src-javascript">var myIterable = {};
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};
// 一个语法糖是 yield*
function* gen() {
  yield* ['a', 'b', 'c'];
}


for (let value of myIterable) { 
    console.log(value); 
}
// 1
// 2
// 3

or

[...myIterable]; // [1, 2, 3]
</pre>
</div>
</div>
</li>
<li><a id="org6b876f0"></a>高级生成器<br />
<div class="outline-text-5" id="text-1-4-5-4">
<div class="org-src-container">
<pre class="src src-javascript">function* fibonacci() {
  var fn1 = 0;
  var fn2 = 1;
  while (true) {  
    var current = fn1;
    fn1 = fn2;
    fn2 = current + fn1;
    var reset = yield current;
    if (reset) {
	fn1 = 0;
	fn2 = 1;
    }
  }
}

var sequence = fibonacci();
console.log(sequence.next().value);     // 0
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 2
console.log(sequence.next().value);     // 3
console.log(sequence.next().value);     // 5
console.log(sequence.next().value);     // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 2
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org73230a0" class="outline-3">
<h3 id="org73230a0"><span class="section-number-3">1.5</span> 函数</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org8cb92d6" class="outline-4">
<h4 id="org8cb92d6"><span class="section-number-4">1.5.1</span> 定义函数</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-javascript">function square(number) {
    return number * number;
}
</pre>
</div>
<ol class="org-ol">
<li>原始类型传值, 对象类型传引用</li>
<li>函数可以作为参数和返回值</li>
</ol>
</div>
</div>
<div id="outline-container-orgd98166e" class="outline-4">
<h4 id="orgd98166e"><span class="section-number-4">1.5.2</span> 匿名函数</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-javascript">// 匿名函数
var square = function(number) { return number * number; };
// 递归的匿名函数
var factorial = function fac(n) {return n&lt;2 ? 1 : n*fac(n-1)};
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbe762ec" class="outline-4">
<h4 id="orgbe762ec"><span class="section-number-4">1.5.3</span> 递归调用</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">
<pre class="src src-javascript">var foo = function bar() {
    // statements go here
};
</pre>
</div>
<p>
在这个函数体内，以下的语句是等价的：
</p>
<ol class="org-ol">
<li>bar()</li>
<li>arguments.callee()</li>
<li>foo()</li>
</ol>
</div>
</div>
<div id="outline-container-org37a8989" class="outline-4">
<h4 id="org37a8989"><span class="section-number-4">1.5.4</span> 闭包</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
嵌套的函数或匿名函数形成闭包
</p>
<div class="org-src-container">
<pre class="src src-javascript">var pet = function(name) {          //外部函数定义了一个变量"name"
    var getName = function() {            
	//内部函数可以访问 外部函数定义的"name"
	return name; 
    }
    //返回这个内部函数，从而将其暴露在外部函数作用域
    return getName;               
};
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfb987ba" class="outline-4">
<h4 id="orgfb987ba"><span class="section-number-4">1.5.5</span> 函数参数</h4>
<div class="outline-text-4" id="text-1-5-5">
</div>
<ol class="org-ol">
<li><a id="org64f0030"></a><code>arguments</code> 对象<br />
<div class="outline-text-5" id="text-1-5-5-1">
<p>
传给函数的参数保存在一个 <code>arguments</code> 对象中, 因此可以向函数传递任意数量的参数
</p>
<div class="org-src-container">
<pre class="src src-javascript">function myConcat(separator) {
    var result = ''; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！
    var i;
    // iterate through arguments
    for (i = 1; i &lt; arguments.length; i++) {
	result += arguments[i] + separator;
    }
    return result;
}
</pre>
</div>
</div>
</li>
<li><a id="orge6fbd86"></a>默认参数<br />
<div class="outline-text-5" id="text-1-5-5-2">
<div class="org-src-container">
<pre class="src src-javascript">function multiply(a, b = 1) {
    return a*b;
}
</pre>
</div>
</div>
</li>
<li><a id="org024e086"></a>剩余参数<br />
<div class="outline-text-5" id="text-1-5-5-3">
<div class="org-src-container">
<pre class="src src-javascript">function multiply(multiplier, ...theArgs) {
    return theArgs.map(x =&gt; multiplier * x);
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org386612e" class="outline-4">
<h4 id="org386612e"><span class="section-number-4">1.5.6</span> 箭头函数</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
相当于匿名函数的语法糖
</p>
<div class="org-src-container">
<pre class="src src-javascript">var a = [
    "Hydrogen",
    "Helium",
    "Lithium",
    "Beryllium"
];

var a2 = a.map(function(s){ return s.length });

console.log(a2); // logs [ 8, 6, 7, 9 ]

var a3 = a.map( s =&gt; s.length );

console.log(a3); // logs [ 8, 6, 7, 9 ]
</pre>
</div>
</div>
</div>
<div id="outline-container-org02ea0a4" class="outline-4">
<h4 id="org02ea0a4"><span class="section-number-4">1.5.7</span> <code>this</code> 词法作用域</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
<code>this</code> 的作用域包括函数本身, 因此在嵌套函数中不能用 <code>this</code> 指代上级函数, 一般会定义一个 <code>self</code> 变量保存上级 <code>this</code> 的值, 但箭头函数可以不产生 <code>this</code> .
</p>
<div class="org-src-container">
<pre class="src src-javascript">function Person(){
    this.age = 0;

    setInterval(() =&gt; {
	this.age++; // |this| properly refers to the person object
    }, 1000);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org384cbcb" class="outline-3">
<h3 id="org384cbcb"><span class="section-number-3">1.6</span> 数据类型</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org59ffcfc" class="outline-4">
<h4 id="org59ffcfc"><span class="section-number-4">1.6.1</span> 数据类型</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>原型数据类型有:
<ol class="org-ol">
<li><code>Boolean</code>.  布尔值， <code>true</code> 和 <code>false</code>.</li>
<li><code>null</code>. 一个表明 <code>null</code> 值的特殊关键字。 JavaScript 是大小写敏感的，因此 <code>null</code> 与 Null、NULL或其他变量完全不同。</li>
<li><code>undefined</code>.  变量未定义时的属性。</li>
<li><code>Number</code>.  表示数字，例如： <code>42</code> 或者 <code>3.14159</code></li>
<li><code>String</code>.  表示字符串，例如： <code>"Howdy"</code></li>
<li><code>Symbol</code> ( 在 ECMAScript 6 中新添加的类型). 一种数据类型，它的实例是唯一且不可改变的。</li>
</ol></li>
<li>其它类型:
<ol class="org-ol">
<li><code>Object</code> 对象</li>
<li><code>functions</code> 函数</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgfdcf31c" class="outline-4">
<h4 id="orgfdcf31c"><span class="section-number-4">1.6.2</span> 数据类型转换</h4>
<div class="outline-text-4" id="text-1-6-2">
<ol class="org-ol">
<li>大部分会进行自动转换</li>
<li>显式转换成数字的函数有: <code>parseInt()</code> 和 <code>parseFloat()</code></li>
<li>也可以使用一个加号来转换: <code>(+ "12.3")</code></li>
</ol>
</div>
</div>
<div id="outline-container-org89f7a07" class="outline-4">
<h4 id="org89f7a07"><span class="section-number-4">1.6.3</span> 字面量</h4>
<div class="outline-text-4" id="text-1-6-3">
<ol class="org-ol">
<li>数组字面量是方括号, 多余的逗号会产生 <code>undefined</code> 类型, 要避免这种用法,但最后可以放一个逗号不会影响什么: <code>[1, , "3",]</code></li>
<li>布尔类型: <code>true</code> 和 <code>false</code></li>
<li><p>
整数类型
</p>
<blockquote>
<p>
0, 117 and -345 (十进制, 基数为10)
015, 0001 and -0o77 (八进制, 基数为8) 
0x1123, 0x00111 and -0xF1A7 (十六进制, 基数为16或"hex")
0b11, 0b0011 and -0b11 (二进制, 基数为2)
</p>
</blockquote></li>
<li><p>
浮点数类型
</p>
<blockquote>
<p>
3.14      
-.2345789 <i>/ -0.23456789
-3.12e+12  /</i> -3.12*1012
.1e-23    // 0.1*10-23=10-24=1e-24
</p>
</blockquote></li>
<li><p>
对象字面量, 大括号扩起来的kv对, ES6新增支持在这里面定义方法,继承等东西,和类定义比较像
</p>
<div class="org-src-container">
<pre class="src src-javascript">var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Shorthand for ‘handler: handler’
    handler,
    // Methods
    toString() {
	// Super calls
	return "d " + super.toString();
    },
    // Computed (dynamic) property names
    [ 'prop_' + (() =&gt; 42)() ]: 42
};
</pre>
</div></li>
<li>正则表达式: <code>var re = /ab+c/;</code></li>
<li>字符串字面量: <code>"asd"</code></li>
<li><p>
模板字符串,用反引号扩起来,与python的format差不多,还支持了多行字符串
</p>
<div class="org-src-container">
<pre class="src src-javascript">// Basic literal string creation
`In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript this is
 not legal.`

// String interpolation
var name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-orgc5be46c" class="outline-4">
<h4 id="orgc5be46c"><span class="section-number-4">1.6.4</span> 数字与数学运算</h4>
<div class="outline-text-4" id="text-1-6-4">
</div>
<ol class="org-ol">
<li><a id="orgcaa404a"></a>数字对象<br />
<ol class="org-ol">
<li><a id="org5b286c5"></a>属性<br />
<div class="outline-text-6" id="text-1-6-4-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Number.MAX_VALUE</code></td>
<td class="org-left">可表示的最大值</td>
</tr>

<tr>
<td class="org-left"><code>Number.MIN_VALUE</code></td>
<td class="org-left">可表示的最小值</td>
</tr>

<tr>
<td class="org-left"><code>Number.NaN</code></td>
<td class="org-left">特指”非数字“</td>
</tr>

<tr>
<td class="org-left"><code>Number.NEGATIVE_INFINITY</code></td>
<td class="org-left">特指“负无穷”;在溢出时返回</td>
</tr>

<tr>
<td class="org-left"><code>Number.POSITIVE_INFINITY</code></td>
<td class="org-left">特指“正无穷”;在溢出时返回</td>
</tr>

<tr>
<td class="org-left"><code>Number.EPSILON</code></td>
<td class="org-left">表示1和比最接近1且大于1的最小Number之间的差别</td>
</tr>

<tr>
<td class="org-left"><code>Number.MIN_SAFE_INTEGER</code></td>
<td class="org-left">JavaScript最小安全整数.</td>
</tr>

<tr>
<td class="org-left"><code>Number.MAX_SAFE_INTEGER</code></td>
<td class="org-left">JavaScript最大安全整数.</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org2b465b5"></a>方法<br />
<div class="outline-text-6" id="text-1-6-4-1-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Number.parseFloat()</code></td>
<td class="org-left">把字符串参数解析成浮点数，和全局方法 <code>parseFloat()</code> 作用一致.</td>
</tr>

<tr>
<td class="org-left"><code>Number.parseInt()</code></td>
<td class="org-left">把字符串解析成特定基数对应的整型数字，和全局方法 <code>parseInt()</code> 作用一致.</td>
</tr>

<tr>
<td class="org-left"><code>Number.isFinite()</code></td>
<td class="org-left">判断传递的值是否为有限数字。</td>
</tr>

<tr>
<td class="org-left"><code>Number.isInteger()</code></td>
<td class="org-left">判断传递的值是否为整数。</td>
</tr>

<tr>
<td class="org-left"><code>Number.isNaN()</code></td>
<td class="org-left">判断传递的值是否为 NaN. 比 <code>isNaN()</code> 更稳定一些.</td>
</tr>

<tr>
<td class="org-left"><code>Number.isSafeInteger()</code></td>
<td class="org-left">判断传递的值是否为安全整数。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org611cd8d"></a>数字类型原型上的一些方法<br />
<div class="outline-text-6" id="text-1-6-4-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>toExponential()</code></td>
<td class="org-left">返回一个数字的指数形式的字符串，形如： <code>1.23e+2</code></td>
</tr>

<tr>
<td class="org-left"><code>toFixed()</code></td>
<td class="org-left">返回指定小数位数的表示形式， <code>var a=123,b=a.toFixed(2)//b="123.00"</code></td>
</tr>

<tr>
<td class="org-left"><code>toPrecision()</code></td>
<td class="org-left">返回一个指定精度的数字。如下例子中，a=123中，3会由于精度限制消失. <code>var a=123,b=a.toPrecision(2)//b="1.2e+2"</code></td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</li>
<li><a id="orgc07a6b1"></a>数学对象(<code>Math</code>)<br />
<div class="outline-text-5" id="text-1-6-4-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>abs()</code></td>
<td class="org-left">绝对值</td>
</tr>

<tr>
<td class="org-left"><code>sin(), cos(), tan()</code></td>
<td class="org-left">标准三角函数;参数为弧度</td>
</tr>

<tr>
<td class="org-left"><code>asin(), acos(), atan(), atan2()</code></td>
<td class="org-left">反三角函数;返回值为弧度</td>
</tr>

<tr>
<td class="org-left"><code>sinh(), cosh(), tanh()</code></td>
<td class="org-left">双曲三角函数;返回值为弧度.</td>
</tr>

<tr>
<td class="org-left"><code>asinh(), acosh(), atanh()</code></td>
<td class="org-left">反双曲三角函数;返回值为弧度.</td>
</tr>

<tr>
<td class="org-left"><code>pow(), exp(), expm1(), log10(), log1p(),log2()</code></td>
<td class="org-left">指数与对数函数</td>
</tr>

<tr>
<td class="org-left"><code>floor(), ceil()</code></td>
<td class="org-left">返回最大/最小整数小于/大于或等于参数</td>
</tr>

<tr>
<td class="org-left"><code>min(), max()</code></td>
<td class="org-left">返回一个以逗号间隔的数字参数列表中的较小或较大值(分别地)</td>
</tr>

<tr>
<td class="org-left"><code>random()</code></td>
<td class="org-left">返回0和1之间的随机数。</td>
</tr>

<tr>
<td class="org-left"><code>round(), fround(), trunc(),</code></td>
<td class="org-left">四舍五入和截断函数</td>
</tr>

<tr>
<td class="org-left"><code>sqrt(), cbrt(), hypot()</code></td>
<td class="org-left">平方根，立方根，平方参数的和的平方根,两个参数平方和的平方根</td>
</tr>

<tr>
<td class="org-left"><code>sign()</code></td>
<td class="org-left">数字的符号,说明数字是否为正、负、零。</td>
</tr>

<tr>
<td class="org-left"><code>clz32()</code></td>
<td class="org-left">在32位2进制表示中，开头的0的数量.</td>
</tr>

<tr>
<td class="org-left"><code>imul()</code></td>
<td class="org-left">返回传入的两个参数相乘结果的类C的32位表现形式</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgbb1939a" class="outline-4">
<h4 id="orgbb1939a"><span class="section-number-4">1.6.5</span> 日期对象</h4>
<div class="outline-text-4" id="text-1-6-5">
</div>
<ol class="org-ol">
<li><a id="org529d644"></a>创建一个日期对象<br />
<div class="outline-text-5" id="text-1-6-5-1">
<p>
前边的语法中的参数（parameters）可以是一下任何一种：
</p>
<ol class="org-ol">
<li>无参数 : 创建今天的日期和时间，例如： today = new Date();.</li>
<li>一个符合以下格式的表示日期的字符串: "月 日, 年 时:分:秒." 例如： var Xmas95 = new Date("December 25, 1995 13:30:00")。如果你省略时、分、秒，那么他们的值将被设置为0。</li>
<li>一个年，月，日的整型值的集合，例如： var Xmas95 = new Date(1995, 11, 25)。</li>
<li>一个年，月，日，时，分，秒的集合，例如： var Xmas95 = new Date(1995, 11, 25, 9, 30, 0);.</li>
</ol>
</div>
</li>
<li><a id="org06ce169"></a>Date对象的方法<br />
<div class="outline-text-5" id="text-1-6-5-2">
<p>
处理日期时间的Date对象方法可分为以下几类：
</p>
<ol class="org-ol">
<li>"set" 方法, 用于设置Date对象的日期和时间的值。</li>
<li>"get" 方法,用于获取Date对象的日期和时间的值。</li>
<li>"to" 方法,用于返回Date对象的字符串格式的值。</li>
<li>parse 和UTC 方法, 用于解析Date字符串。</li>
</ol>
<p>
例子
</p>
<div class="org-src-container">
<pre class="src src-javascript">function JSClock() {
    var time = new Date();
    var hour = time.getHours();
    var minute = time.getMinutes();
    var second = time.getSeconds();
    var temp = "" + ((hour &gt; 12) ? hour - 12 : hour);
    if (hour == 0)
	temp = "12";
    temp += ((minute &lt; 10) ? ":0" : ":") + minute;
    temp += ((second &lt; 10) ? ":0" : ":") + second;
    temp += (hour &gt;= 12) ? " P.M." : " A.M.";
    return temp;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org5907c2f" class="outline-4">
<h4 id="org5907c2f"><span class="section-number-4">1.6.6</span> 字符串</h4>
<div class="outline-text-4" id="text-1-6-6">
</div>
<ol class="org-ol">
<li><a id="org2e664f8"></a>属性<br />
<div class="outline-text-5" id="text-1-6-6-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>s.length</code></td>
<td class="org-left">字符串长度</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org0dbec0b"></a>方法<br />
<div class="outline-text-5" id="text-1-6-6-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>charAt, charCodeAt, codePointAt</code></td>
<td class="org-left">返回字符串指定位置的字符或者字符编码。</td>
</tr>

<tr>
<td class="org-left"><code>indexOf, lastIndexOf</code></td>
<td class="org-left">分别返回字符串中指定子串的位置或最后位置。</td>
</tr>

<tr>
<td class="org-left"><code>startsWith, endsWith, includes</code></td>
<td class="org-left">返回字符串是否以指定字符串开始、结束或包含指定字符串。</td>
</tr>

<tr>
<td class="org-left"><code>concat</code></td>
<td class="org-left">连接两个字符串并返回新的字符串。</td>
</tr>

<tr>
<td class="org-left"><code>fromCharCode, fromCodePoint</code></td>
<td class="org-left">从指定的Unicode值序列构造一个字符串。这是一个String类方法，不是实例方法。</td>
</tr>

<tr>
<td class="org-left"><code>split</code></td>
<td class="org-left">通过将字符串分离成一个个子串来把一个String对象分裂到一个字符串数组中。</td>
</tr>

<tr>
<td class="org-left"><code>slice</code></td>
<td class="org-left">从一个字符串提取片段并作为新字符串返回。</td>
</tr>

<tr>
<td class="org-left"><code>substring, substr</code></td>
<td class="org-left">分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集。</td>
</tr>

<tr>
<td class="org-left"><code>match, replace, search</code></td>
<td class="org-left">通过正则表达式来工作.</td>
</tr>

<tr>
<td class="org-left"><code>toLowerCase, toUpperCase</code></td>
<td class="org-left">分别返回字符串的小写表示和大写表示。</td>
</tr>

<tr>
<td class="org-left"><code>normalize 	按照指定的一种 Unicode</code></td>
<td class="org-left">正规形式将当前字符串正规化。</td>
</tr>

<tr>
<td class="org-left"><code>repeat</code></td>
<td class="org-left">将字符串内容重复指定次数后返回。</td>
</tr>

<tr>
<td class="org-left"><code>trim</code></td>
<td class="org-left">去掉字符串开头和结尾的空白字符。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
<div id="outline-container-org004ef1a" class="outline-4">
<h4 id="org004ef1a"><span class="section-number-4">1.6.7</span> 正则表达式</h4>
<div class="outline-text-4" id="text-1-6-7">
<p>
js 的正则表达式支持功能很丰富,字面量也比较好用.
</p>
</div>
<ol class="org-ol">
<li><a id="org374ca5a"></a>创建正则表达式<br />
<ol class="org-ol">
<li><a id="orgd4fc530"></a>字面量方式<br />
<div class="outline-text-6" id="text-1-6-7-1-1">
<div class="org-src-container">
<pre class="src src-javascript">/*
  /pattern/flags
*/

const regex = /ab+c/;

const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;
</pre>
</div>
</div>
</li>
<li><a id="org12bfd0f"></a><code>RegExp</code> 对象方式<br />
<div class="outline-text-6" id="text-1-6-7-1-2">
<div class="org-src-container">
<pre class="src src-javascript">/* 
   new RegExp(pattern [, flags])
*/

let regex = new RegExp("ab+c");

let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi");

let regex = new RegExp("^[a-zA-Z]+[0-9]*\\W?_$", "gi");
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="org0cd398b"></a>使用正则表达式<br />
<ol class="org-ol">
<li><a id="org68b294f"></a>正则表达式方法<br />
<div class="outline-text-6" id="text-1-6-7-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>exec</code></td>
<td class="org-left">一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</td>
</tr>

<tr>
<td class="org-left"><code>test</code></td>
<td class="org-left">一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</td>
</tr>

<tr>
<td class="org-left"><code>match</code></td>
<td class="org-left">一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</td>
</tr>

<tr>
<td class="org-left"><code>search</code></td>
<td class="org-left">一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>

<tr>
<td class="org-left"><code>replace</code></td>
<td class="org-left">一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td>
</tr>

<tr>
<td class="org-left"><code>split</code></td>
<td class="org-left">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org4cb5f87"></a>正则表达式执行返回的信息<br />
<div class="outline-text-6" id="text-1-6-7-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">对象</th>
<th scope="col" class="org-left">属性或索引</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">myArray</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">匹配到的字符串和所有被记住的子字符串。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">index</td>
<td class="org-left">在输入的字符串中匹配到的以0开始的索引值。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">input</td>
<td class="org-left">初始字符串。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">[0]</td>
<td class="org-left">匹配到的所有字符串（并不是匹配后记住的字符串）。匹配到的最终字符。</td>
</tr>

<tr>
<td class="org-left">myRe</td>
<td class="org-left">lastIndex</td>
<td class="org-left">下一个匹配的索引值。（这个属性只有在使用g参数时可用在 通过参数进行高级搜索 一节有详细的描述.)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">source</td>
<td class="org-left">模式文本。在正则表达式创建时更新，不执行。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org109adf4"></a>正则表达式标志<br />
<div class="outline-text-6" id="text-1-6-7-2-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标志</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>g</code></td>
<td class="org-left">全局搜索。</td>
</tr>

<tr>
<td class="org-left"><code>i</code></td>
<td class="org-left">不区分大小写搜索。</td>
</tr>

<tr>
<td class="org-left"><code>m</code></td>
<td class="org-left">多行搜索。</td>
</tr>

<tr>
<td class="org-left"><code>y</code></td>
<td class="org-left">执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-orgc4e9c1c" class="outline-4">
<h4 id="orgc4e9c1c"><span class="section-number-4">1.6.8</span> 数组对象 <code>Array object</code></h4>
<div class="outline-text-4" id="text-1-6-8">
</div>
<ol class="org-ol">
<li><a id="org8dc9678"></a>遍历数组<br />
<div class="outline-text-5" id="text-1-6-8-1">
<p>
应该使用 <code>forEach</code> 方法, 使用普通的 <code>for</code> 循环也可以, 但使用 <code>for in</code> 就不一定会发生什么了.
</p>
<div class="org-src-container">
<pre class="src src-javascript">var colors = ['red', 'green', 'blue'];
colors.forEach(function(color) {
    console.log(color);
});
</pre>
</div>
</div>
</li>
<li><a id="orge8d65fb"></a>创建数组<br />
<div class="outline-text-5" id="text-1-6-8-2">
<p>
大量坑预警, 注意 <code>Array</code> 函数对数字的理解可能与你想像的不同, 推荐全部使用字面量表示.
</p>
<div class="org-src-container">
<pre class="src src-javascript">var arr = new Array(element0, element1, ..., elementN);
var arr = Array(element0, element1, ..., elementN);
var arr = [element0, element1, ..., elementN];
</pre>
</div>
</div>
</li>
<li><a id="org28cd715"></a>增加内容<br />
<div class="outline-text-5" id="text-1-6-8-3">
<p>
由于数组也是对象,对象的引用 key 语法与数组相同.
</p>
<div class="org-src-container">
<pre class="src src-javascript">var emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";
emp[2.3] = "a";
</pre>
</div>
</div>
</li>
<li><a id="org348ba7a"></a>数组方法<br />
<div class="outline-text-5" id="text-1-6-8-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">作用</th>
<th scope="col" class="org-left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>concat()</code></td>
<td class="org-left">连接两个数组并返回一个新的数组。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>join(deliminator = ',')</code></td>
<td class="org-left">将数组的所有元素连接成一个字符串。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>push()</code></td>
<td class="org-left">在数组末尾添加一个或多个元素，并返回数组操作后的长度。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>pop()</code></td>
<td class="org-left">从数组移出最后一个元素，并返回该元素。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>shift()</code></td>
<td class="org-left">从数组移出第一个元素，并返回该元素。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>unshift()</code></td>
<td class="org-left">在数组开头添加一个或多个元素，并返回数组的新长度。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>slice(start_index, upto_index)</code></td>
<td class="org-left">从数组提取一个片段，并作为一个新数组返回。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>splice(index, count_to_remove, addElement1, addElement2,...)</code></td>
<td class="org-left">从数组移出一些元素，（可选）并替换它们。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>reverse()</code></td>
<td class="org-left">颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>sort()</code></td>
<td class="org-left">给数组元素排序。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>indexOf(searchElement[, fromIndex])</code></td>
<td class="org-left">在数组中搜索 <code>searchElement</code> 并返回第一个匹配的索引。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>lastIndexOf(searchElement[, fromIndex])</code></td>
<td class="org-left">和 <code>indexOf</code> 差不多，但这是从结尾开始，并且是反向搜索。</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>forEach(callback[, thisObject])</code></td>
<td class="org-left">在数组每个元素项上执行 <code>callback</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>map(callback[, thisObject])</code></td>
<td class="org-left">在数组的每个单元项上执行 <code>callback</code> 函数，并把返回包含回调函数返回值的新数组.</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>filter(callback[, thisObject])</code></td>
<td class="org-left">返回一个包含所有在回调函数上返回为 <code>true</code> 的元素的新数组</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>every(callback[, thisObject])</code></td>
<td class="org-left">当数组中每一个元素在 <code>callback</code> 上被返回 <code>true</code> 时就返回 <code>true</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>some(callback[, thisObject])</code></td>
<td class="org-left">只要数组中有一项在 <code>callback</code> 上被返回 <code>true</code> ，就返回 <code>true</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>reduce(callback[, initialValue])</code></td>
<td class="org-left">使用回调函数 <code>callback(firstValue, secondValue)</code> 把数组列表计算成一个单一值</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>reduceRight(callback[, initalvalue])</code></td>
<td class="org-left">和 <code>reduce()</code> 相似，但这从最后一个元素开始的。</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="orgfd21a92"></a>使用类数组对象(<code>array-like objects</code>)<br />
<div class="outline-text-5" id="text-1-6-8-5">
<p>
一些对象也用下标作为索引,但没实现各种数组方法, 这时可以用 <code>Array.prototype</code> 来在上面应用这些方法
</p>
<div class="org-src-container">
<pre class="src src-javascript">function printArguments() {
    Array.prototype.forEach.call(arguments, function(item) {
	console.log(item);
    });
}
Array.prototype.forEach.call("a string", function(chr) {
    console.log(chr);
});
</pre>
</div>
</div>
</li>
<li><a id="org5bcd50f"></a>数组推导式<br />
<div class="outline-text-5" id="text-1-6-8-6">
<p>
和 python 的列表推导差不多, 只不过需要加括号, in 换成 of, 求值表达式放后面
</p>
<div class="org-src-container">
<pre class="src src-javascript">var numbers = [1, 2, 3, 4];
var doubled = [for (i of numbers) i * 2];
console.log(doubled); // logs 2,4,6,8
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgcdd563b" class="outline-4">
<h4 id="orgcdd563b"><span class="section-number-4">1.6.9</span> 映射</h4>
<div class="outline-text-4" id="text-1-6-9">
</div>
<ol class="org-ol">
<li><a id="org8e65282"></a><code>Map</code> 对象<br />
<div class="outline-text-5" id="text-1-6-9-1">
<div class="org-src-container">
<pre class="src src-javascript">var sayings = new Map();
sayings.set('dog', 'woof');
sayings.set('cat', 'meow');
sayings.set('elephant', 'toot');
sayings.size; // 3
sayings.get('fox'); // undefined
sayings.has('bird'); // false
sayings.delete('dog');
sayings.has('dog'); // false

for (var [key, value] of sayings) {
    console.log(key + ' goes ' + value);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="orgcd52e23"></a>使用 <code>Map</code> 还是 <code>Object</code><br />
<div class="outline-text-6" id="text-1-6-9-1-1">
<p>
一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。
</p>
<ol class="org-ol">
<li>Object的键均为Strings类型，在Map里键可以是任意类型。</li>
<li>必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。</li>
<li>Map的遍历遵循元素的插入顺序。</li>
<li>Object有原型，所以映射中有一些缺省的键。（可以理解为map = Object.create(null)）。</li>
</ol>
</div>
</li>
</ol>
</li>
<li><a id="org72feb30"></a><code>WeakMap</code> 对象<br />
<div class="outline-text-5" id="text-1-6-9-2">
<p>
键必须是对象类型, 随时可能垃圾回收, 主要用于私有方法和隐藏实现细节
</p>
<div class="org-src-container">
<pre class="src src-javascript">const privates = new WeakMap();

function Public() {
    const me = {
	// Private data goes here
    };
    privates.set(this, me);
}

Public.prototype.method = function () {
    const me = privates.get(this);
    // Do stuff with private data in `me`...
};

module.exports = Public;
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org9943e71" class="outline-4">
<h4 id="org9943e71"><span class="section-number-4">1.6.10</span> 集合</h4>
<div class="outline-text-4" id="text-1-6-10">
</div>
<ol class="org-ol">
<li><a id="org806313b"></a><code>Set</code> 对象<br />
<div class="outline-text-5" id="text-1-6-10-1">
<p>
<code>Set</code> 是不重复的
</p>
<div class="org-src-container">
<pre class="src src-javascript">var mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (let item of mySet) console.log(item);
// 1
// "some text"
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="orgd23dc02"></a>集合与数组相互转换<br />
<div class="outline-text-6" id="text-1-6-10-1-1">
<div class="org-src-container">
<pre class="src src-javascript">Array.from(mySet);
[...mySet2];

mySet2 = new Set([1,2,3,4]);
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="orgcf474fc"></a><code>WeakSet</code> 对象<br />
<div class="outline-text-5" id="text-1-6-10-2">
<p>
用例很有限
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org408483d" class="outline-4">
<h4 id="org408483d"><span class="section-number-4">1.6.11</span> 使用对象</h4>
<div class="outline-text-4" id="text-1-6-11">
</div>
<ol class="org-ol">
<li><a id="orge43dea4"></a>对象的属性<br />
<div class="outline-text-5" id="text-1-6-11-1">
<ol class="org-ol">
<li>对象的属性的键值必须是字符串或者能够隐式转换成字符串的类型.</li>
<li>引用对象的属性的方法可以用点号 <code>o.a</code>, 方括号 <code>o[a]</code>, 方括号引号 <code>o["a"]</code></li>
</ol>
</div>
<ol class="org-ol">
<li><a id="orgd9b1ecb"></a>枚举对象的属性<br />
<div class="outline-text-6" id="text-1-6-11-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>for...in</code></td>
<td class="org-left">该方法依次访问一个对象及其原型链中所有可枚举的属性。</td>
</tr>

<tr>
<td class="org-left"><code>Object.keys(o)</code></td>
<td class="org-left">该方法返回一个对象自身包含（不包括原型中）的所有属性的名称的数组。</td>
</tr>

<tr>
<td class="org-left"><code>Object.getOwnPropertyNames(o)</code></td>
<td class="org-left">该方法返回一个数组，它包含了对象 o所有拥有的属性（无论是否可枚举）的名称。</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org80aaebc"></a>对对象类型追加属性 <code>prototype</code><br />
<div class="outline-text-6" id="text-1-6-11-1-2">
<div class="org-src-container">
<pre class="src src-javascript">Car.prototype.color = null;
car1.color = "black";
</pre>
</div>
</div>
</li>
<li><a id="org87cb185"></a>删除属性<br />
<div class="outline-text-6" id="text-1-6-11-1-3">
<p>
你可以用 delete 操作符删除一个不是继承而来的属性
</p>
<div class="org-src-container">
<pre class="src src-javascript">//Creates a new object, myobj, with two properties, a and b.
var myobj = new Object;
myobj.a = 5;
myobj.b = 12;

//Removes the a property, leaving myobj with only the b property.
delete myobj.a;
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="orgd349332"></a>创建新对象<br />
<ol class="org-ol">
<li><a id="org3deb911"></a>对象初始化器<br />
<div class="outline-text-6" id="text-1-6-11-2-1">
<p>
使用对象初始化器,赋值和命名是可选的
</p>
<div class="org-src-container">
<pre class="src src-javascript">var obj = { property_1:   value_1,   // property_# 可以是一个标识符...
	    2:            value_2,   // 或一个数字...
	    ["property" +3]: value_3,  //  或一个可计算的key名... 
	    // ...,
	    "property n": value_n }; // 或一个字符串
</pre>
</div>
<p>
还可以先进行判断,为真才创建对象
</p>
<div class="org-src-container">
<pre class="src src-javascript">if (cond) var x = {hi: "there"};
</pre>
</div>
</div>
</li>
<li><a id="orga53178b"></a>使用构造函数<br />
<div class="outline-text-6" id="text-1-6-11-2-2">
<p>
作为另一种方式，你可以通过两步来创建对象：
</p>
<ol class="org-ol">
<li>通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。</li>
<li>通过 new 创建对象实例。</li>
</ol>
<div class="org-src-container">
<pre class="src src-javascript">function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
}
var mycar = new Car("Eagle", "Talon TSi", 1993);
</pre>
</div>
</div>
</li>
<li><a id="org4df2ced"></a>从原型继承创建对象,使用 <code>Object.create</code> 方法<br />
<div class="outline-text-6" id="text-1-6-11-2-3">
<p>
对象也可以用 <code>Object.create()</code> 方法创建。该方法非常有用，因为它允许你为创建的对象选择其原型对象，而不用定义一个构造函数。
</p>
<div class="org-src-container">
<pre class="src src-javascript">var Animal = {
    type: "Invertebrates", // 定义属性值
    displayType : function() {  // 定义方法
	console.log(this.type);
    }
}

// 创建一个新对象 
var animal1 = Object.create(Animal);
animal1.displayType(); // Output:Invertebrates

// 创建另一个对象
var fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Output:Fishes
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="orgbb5dc74"></a>方法<br />
<ol class="org-ol">
<li><a id="orge1d45b4"></a>定义方法<br />
<div class="outline-text-6" id="text-1-6-11-3-1">
<div class="org-src-container">
<pre class="src src-javascript">objectName.methodname = function_name;

var myObj = {
    myMethod: function(params) {
	// ...do something
    }

    // 或者 这样写也可以

    myOtherMethod(params) {
	// ...do something else
    }
};
</pre>
</div>
</div>
</li>
<li><a id="orgc5fd265"></a>追加定义方法<br />
<div class="outline-text-6" id="text-1-6-11-3-2">
<div class="org-src-container">
<pre class="src src-javascript">function displayCar() {
    var result = "A Beautiful " + this.year + " " + this.make
	+ " " + this.model;
    pretty_print(result);
}
this.displayCar = displayCar;
</pre>
</div>
</div>
</li>
<li><a id="orgcdcd444"></a>通过 this 引用对象<br />
<div class="outline-text-6" id="text-1-6-11-3-3">
<p>
一般来说 <code>this</code> 指代的是当前对象
</p>
<div class="org-src-container">
<pre class="src src-javascript">function validate(obj, lowval, hival) {
    if ((obj.value &lt; lowval) || (obj.value &gt; hival)) {
	alert("Invalid Value!");
    }
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-html">&lt;input type="text" name="age" size="3"
       onChange="validate(this, 18, 99)"&gt;
</pre>
</div>
</div>
</li>
<li><a id="orga4c0bc9"></a>定义 <code>getters</code> 与 <code>setters</code><br />
<div class="outline-text-6" id="text-1-6-11-3-4">
<p>
一个 getter 是一个获取某个特定属性的值的方法。
一个  setter 是一个设定某个属性的值的方法。
你可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性。
定义 getter 和 setter 的语法采用对象字面量语法。
</p>

<div class="org-src-container">
<pre class="src src-javascript">var o = {
    a: 7,
    get b() { 
	return this.a + 1;
    },
    set c(x) {
	this.a = x / 2
    }
};

console.log(o.a); // 7
console.log(o.b); // 8
o.c = 50;
console.log(o.a); // 25
</pre>
</div>
</div>
</li>
<li><a id="orgeccd673"></a>追加定义 <code>getters</code> 与 <code>setters</code><br />
<div class="outline-text-6" id="text-1-6-11-3-5">
<div class="org-src-container">
<pre class="src src-javascript">var o = { a:0 }

Object.defineProperties(o, {
    "b": { get: function () { return this.a + 1; } },
    "c": { set: function (x) { this.a = x / 2; } }
});

o.c = 10 // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(o.b) // Runs the getter, which yields a + 1 or 6
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="org234f4d1"></a>细节<br />
<ol class="org-ol">
<li><a id="orgf8fc490"></a><code>__proto__</code> 属性<br />
<div class="outline-text-6" id="text-1-6-11-4-1">
<p>
<code>__proto__</code> 属性保存着继承的原型对象
不断的检查 <code>__proto__</code> 属性就能得到原型继承链
</p>
</div>
</li>
<li><a id="orgef14807"></a><code>prototype</code> 属性<br />
<div class="outline-text-6" id="text-1-6-11-4-2">
<p>
<code>prototype</code> 属性中保存着各种参数和方法
</p>
</div>
</li>
<li><a id="org22e55e0"></a>多重继承<br />
<div class="outline-text-6" id="text-1-6-11-4-3">
<p>
js 不支持多重继承, 但是构造器中可以调用多个其它构造器,这造成了多重继承的假象.
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-org320d19c" class="outline-3">
<h3 id="org320d19c"><span class="section-number-3">1.7</span> 内建函数</h3>
<div class="outline-text-3" id="text-1-7">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">解释</th>
<th scope="col" class="org-left">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>eval()</code></td>
<td class="org-left">执行字符串所代表的代码</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>isFinite()</code></td>
<td class="org-left">判断是否为有限数</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>isNaN()</code></td>
<td class="org-left">判断是否为 <code>NaN</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>parseFloat()</code></td>
<td class="org-left">字符串转浮点数</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>parseInt()</code></td>
<td class="org-left">字符串转整数</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>decodeURI()</code></td>
<td class="org-left">解码字符串, 对应 <code>encodeURI</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>decodeURIComponent()</code></td>
<td class="org-left">解码字符串, 对应 <code>encodeURIComponent</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>encodeURI()</code></td>
<td class="org-left">编码字符串</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>encodeURIComponent()</code></td>
<td class="org-left">编码字符串</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgccacc23" class="outline-3">
<h3 id="orgccacc23"><span class="section-number-3">1.8</span> 元编程</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org7b1bf41" class="outline-4">
<h4 id="org7b1bf41"><span class="section-number-4">1.8.1</span> 代理 <code>Proxy</code></h4>
</div>
<div id="outline-container-org01ac64d" class="outline-4">
<h4 id="org01ac64d"><span class="section-number-4">1.8.2</span> 反射 <code>Reflect</code></h4>
</div>
</div>
</div>
<div id="outline-container-orgfe93708" class="outline-2">
<h2 id="orgfe93708"><span class="section-number-2">2</span> React</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org940bcaa" class="outline-3">
<h3 id="org940bcaa"><span class="section-number-3">2.1</span> 基本使用</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgd25a85f" class="outline-4">
<h4 id="orgd25a85f"><span class="section-number-4">2.1.1</span> 创建新应用的方法</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="org-src-container">
<pre class="src src-bash">npm install -g create-react-app
create-react-app my-app
cd my-app
npm start
</pre>
</div>
</div>
</div>
<div id="outline-container-org11b12d1" class="outline-4">
<h4 id="org11b12d1"><span class="section-number-4">2.1.2</span> 工作流程</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
React本质上就是一个JS库
</p>

<p>
工作流程：导入依赖库-&gt;声明组件类和函数-&gt;将组件组合到一起-&gt;将组合组件输出到页面
</p>

<p>
通过 <code>props</code> 传递数据、通过 <code>state</code> 储存状态
</p>
</div>
<ol class="org-ol">
<li><a id="org14dee5e"></a>组件类<br />
<div class="outline-text-5" id="text-2-1-2-1">
<p>
组件类中可以设置构造函数、渲染函数、加载和卸载钩子函数
</p>

<ul class="org-ul">
<li>构造函数中需要继承父类和设置自身状态</li>
<li>渲染函数中使用JSX或其他的语法写出要渲染的内容，包括HTML、一般的JS、CSS和事件处理函数/方法</li>
<li>加载和卸载钩子函数为组件被进入和离开DOM时的行为</li>
</ul>

<div class="org-src-container">
<pre class="src src-js">class SampleClass extends React.Component{
    constructor(){      //构造函数
	this.state = {    //本地状态
	    value: null;
	}
    }
    render() {          //渲染函数
	return(
		&lt;h1&gt;something{props.value}&lt;/h1&gt;  //传递数据
		&lt;h2&gt;{this.state.value}&lt;/h2&gt;      //自身调用
	)
    }
    componentDidMount(){}    //生命周期钩子，当输出到DOM后执行这个
    componentWillUnmount(){} //卸载生命周期钩子，当从DOM清除时执行
}
</pre>
</div>
</div>
</li>
<li><a id="org995fdb0"></a>函数<br />
<div class="outline-text-5" id="text-2-1-2-2">
<p>
函数就是只有渲染的组件类
</p>
<div class="org-src-container">
<pre class="src src-js">function Square(props) {
    return (
	    &lt;h1&gt;{props.value}&lt;/ h1&gt;
    )
}
</pre>
</div>
</div>
</li>
<li><a id="org39ef3f7"></a>数据流<br />
<div class="outline-text-5" id="text-2-1-2-3">
<p>
程序的数据流为自顶向下，不可变，通过‘状态提升’的技巧将需要交互的数据写在共同父类的状态里
</p>

<p>
数据是不可变的，改变数据推荐深度拷贝
</p>
</div>
</li>
<li><a id="org190c653"></a>使用组件<br />
<div class="outline-text-5" id="text-2-1-2-4">
<p>
在JSX里像HTML标签一样使用定义好的组件
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;SampleClass /&gt;          //这样可以调用声明好的组件，返回rander方法的值
&lt;SampleClass name=2 /&gt; //向组件传递数据的方法，props.name
</pre>
</div>
</div>
</li>
<li><a id="orgd9d847e"></a>渲染整个页面<br />
<div class="outline-text-5" id="text-2-1-2-5">
<p>
是改变页面的唯一方法，连续的改变页面就是动画
</p>
<div class="org-src-container">
<pre class="src src-js">ReactDOM.render(
	&lt;SampleClass name="index" /&gt;,
    document.getElementById("root"));
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgb270644" class="outline-3">
<h3 id="orgb270644"><span class="section-number-3">2.2</span> API</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org77d8db0" class="outline-4">
<h4 id="org77d8db0"><span class="section-number-4">2.2.1</span> 示例代码</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">
<pre class="src src-js">import React from 'react';  //React的依赖
import ReactDOM from 'react-dom';
import './index.css'; //本地文件引入

class ShoppingList extends React.Component {  //声明一个React组件类：ShoppingList，组件名称必须大写开头
    constructor() { //构造函数
	super();  //继承父类
	this.state = {  //组件自身的状态数据，只能在构造函数里初始化
	    value: null;
	};
	this.user
	id:"1",
	name:"name",
	:taskCount:"2",
    };
}
const element = ( //在括号里可以直接声明JSX表达式
	&lt;h1&gt;  //和HTML差不多
	Hello, {formatName(user)}!  //在大括号里可以直接调用任何js表达式
    &lt;/h1&gt;
);

const listItems = numbers.map((number) =&gt; //只有在map的遍历列表中key需要明确被表示出来
			      &lt;ListItem key={number.toString()}
			      value={number} /&gt;
			     );
render() {  //render方法，返回一个嵌套结构视图，对渲染内容的描述
    return (  //一般使用JSX语法扩展写描述
	    &lt;div className="shopping-list"&gt;
	    &lt;button  onClick={() =&gt; this.setState({value: 'X'}) }&gt;  //传入一个函数作为事件处理的方法，setState方法可以设置自身的状态，也是唯一的改变状态的方法
	    {this.state.value}  //大括号表示引用数据
	&lt;/button&gt;
	    &lt;h1&gt;Shopping List for {this.props.name}&lt;/h1&gt;  //props用于接受传递数据
	    &lt;ul&gt;
	    &lt;li&gt;WhatsApp&lt;/li&gt;
	    &lt;li&gt;Oculus&lt;/li&gt;
	    &lt;/ul&gt;
	    &lt;/div&gt;
    );
}
componentDidMount() { //生命周期钩子，当输出到DOM后执行这个
}

componentWillUnmount() { //卸载生命周期钩子，当从DOM清除时执行这个
}
}
function Square(props) {  //只有rander方法的单纯组件可以改写成函数
    if (props){ //函数中使用if来进行条件渲染
	return null;  //返回null阻止渲染
    }else{
	return (
		&lt;button className="square" onClick={props.onClick}&gt; //注意这里onClick的方法改写
		{props.value}
	    &lt;/button&gt;
	);
    }
}

    &lt;ShoppingList /&gt;  //这样可以调用声明好的组件，返回rander方法的值
    &lt;ShoppingList name={i} /&gt; //向组件传递数据的方法
    // 状态提升：多个组件的数据都需要用到或者要进行交互时，将他们的数据保存在共同父组件中，单向数据流，只能从顶层向下层传递数据，不能反过来
// 数据是不可变的，改变数据推荐深度拷贝
// 使用组合方式构建组件而不是继承
ReactDOM.render(  //渲染整个页面，将页面传到这个方法里是改变页面的唯一方法
	&lt;ShoppingList name={i} /&gt;,
    document.getElementById("root"));

// setInterval(tick, 1000); 这个可以每一秒调用一次一个函数
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1d63e6b" class="outline-3">
<h3 id="org1d63e6b"><span class="section-number-3">2.3</span> 开始新项目: yarn, create-react-app</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org996142c" class="outline-4">
<h4 id="org996142c"><span class="section-number-4">2.3.1</span> yarn</h4>
<div class="outline-text-4" id="text-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org91ff576"></a>安装与基本参考<br />
<div class="outline-text-5" id="text-2-3-1-1">
<p>
<a href="https://yarn.bootcss.com">中文手册</a>
<code>npm i -g yarn</code>
</p>
</div>
</li>
<li><a id="org393629f"></a>基本使用<br />
<div class="outline-text-5" id="text-2-3-1-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">命令</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>yarn init</code></td>
<td class="org-left">初始化项目</td>
</tr>

<tr>
<td class="org-left"><code>yarn add [package]</code></td>
<td class="org-left">添加包</td>
</tr>

<tr>
<td class="org-left"><code>yarn add [package] --dev</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>yarn add [package] --peer</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>yarn add [package] --optional</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>yarn remove</code></td>
<td class="org-left">移除包</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb4d1986" class="outline-4">
<h4 id="orgb4d1986"><span class="section-number-4">2.3.2</span> create-react-app</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
<a href="https://github.com/facebook/create-react-app">项目地址</a>
开始新项目: <code>yarn create react-app my-app</code>
</p>
</div>
</div>
</div>
<div id="outline-container-org87cb042" class="outline-3">
<h3 id="org87cb042"><span class="section-number-3">2.4</span> redux: 状态管理</h3>
<div class="outline-text-3" id="text-2-4">
<p>
<a href="http://www.redux.org.cn/">中文手册</a>
</p>
</div>
<div id="outline-container-orgc6e9493" class="outline-4">
<h4 id="orgc6e9493"><span class="section-number-4">2.4.1</span> 安装</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">
<pre class="src src-bash">yarn add redux # redux 核心
yarn add react-redux # redux 的 react 绑定
yarn add redux-devtools --dev # redux 开发工具
</pre>
</div>
</div>
</div>
<div id="outline-container-org01ac383" class="outline-4">
<h4 id="org01ac383"><span class="section-number-4">2.4.2</span> 基本使用</h4>
<div class="outline-text-4" id="text-2-4-2">
</div>
<ol class="org-ol">
<li><a id="org6e42eba"></a>Action<br />
<div class="outline-text-5" id="text-2-4-2-1">
<p>
应用的所有状态都存在一起, 为了修改状态只能通过发起 Action.
习惯上用一个字符常量来表示动作的名字,并用一个对象来储存动作和相应的数据
</p>
<div class="org-src-container">
<pre class="src src-javascript">// 动作名称
const ADD_TODO = 'ADD_TODO'
// 一个例子
{
    type: ADD_TODO,
    text: 'Build my first Redux app'
}
</pre>
</div>
<p>
构造动作对象的函数可以写成
</p>
<div class="org-src-container">
<pre class="src src-javascript">export function addTodo(text) {
    return { type: ADD_TODO, text }
}
</pre>
</div>
</div>
</li>
<li><a id="org6c0b798"></a>Reducer: 响应动作的函数<br />
<div class="outline-text-5" id="text-2-4-2-2">
<p>
Reducer 函数接收当前状态以及动作返回下一个状态 <code>(previousState, action) =&gt; newState</code>
</p>
</div>
<ol class="org-ol">
<li><a id="org4c56879"></a>单个的 reducer<br />
<div class="outline-text-6" id="text-2-4-2-2-1">
<div class="org-src-container">
<pre class="src src-javascript">function visibilityFilter(state = SHOW_ALL, action) {
    switch (action.type) {
    case SET_VISIBILITY_FILTER:
	return action.filter
    default:
	return state
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org1052d2c"></a>组合 reducer<br />
<div class="outline-text-6" id="text-2-4-2-2-2">
<p>
一个应用里有很多 reducer, 通过 <code>combineReducers</code> 组合起来
</p>
<div class="org-src-container">
<pre class="src src-javascript">const todoApp = combineReducers({
    visibilityFilter,
    todos
})
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="org9895493"></a>store: 应用的总数据库<br />
<ol class="org-ol">
<li><a id="org1271b64"></a>创建 store<br />
<div class="outline-text-6" id="text-2-4-2-3-1">
<p>
注意 store 是唯一的.
</p>
<div class="org-src-container">
<pre class="src src-javascript">import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
</pre>
</div>
<p>
可以设置其初始状态 <code>let store = createStore(todoApp, window.STATE_FROM_SERVER)</code>
</p>
</div>
</li>
<li><a id="orgd73fd2a"></a>方法<br />
<div class="outline-text-6" id="text-2-4-2-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>getState()</code></td>
<td class="org-left">获取 state；</td>
</tr>

<tr>
<td class="org-left"><code>dispatch(action)</code></td>
<td class="org-left">更新 state；</td>
</tr>

<tr>
<td class="org-left"><code>subscribe(listener)</code></td>
<td class="org-left">注册监听器;</td>
</tr>

<tr>
<td class="org-left"><code>subscribe(listener)</code></td>
<td class="org-left">返回的函数注销监听器。</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</li>
<li><a id="orgcce2985"></a>使用 React<br />
<div class="outline-text-5" id="text-2-4-2-4">
<p>
React 的组件分为展示组件和容器组件
</p>
</div>
<ol class="org-ol">
<li><a id="orgd2598f3"></a>展示组件<br />
<div class="outline-text-6" id="text-2-4-2-4-1">
<p>
推荐使用函数来定义展示组件, 它们接收参数并返回 JSX 
</p>
<div class="org-src-container">
<pre class="src src-javascript">import React from 'react'
import PropTypes from 'prop-types'

const Todo = ({ onClick, completed, text }) =&gt; (
	&lt;li
    onClick={onClick}
    style={ {
	textDecoration: completed ? 'line-through' : 'none'
    }}
	&gt;
	{text}
    &lt;/li&gt;
)

Todo.propTypes = {
    onClick: PropTypes.func.isRequired,
    completed: PropTypes.bool.isRequired,
    text: PropTypes.string.isRequired
}

export default Todo
</pre>
</div>
</div>
</li>
<li><a id="org8bb1935"></a>容器组件<br />
<div class="outline-text-6" id="text-2-4-2-4-2">
<p>
容器组件不生成 JSX, 只是从 Redux 读取数据并分发到数据到展示组件里去
创建容器组件需要实现几个函数并调用 connect 
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>mapStateToProps(state,ownProps)=&gt;{}</code></td>
<td class="org-left">在 store 更新时自动调用, 返回值是普通对象, 会被合并到新组件的参数里</td>
</tr>

<tr>
<td class="org-left"><code>mapDispatchToProps(dispatch, [ownProps])</code></td>
<td class="org-left">指定组件发出 dispatch 的方法, 也会合并到组件参数里, 只是为了分离事件和响应强行把它们分开,其实没什么区别</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-javascript">import { connect } from 'react-redux'
import { setVisibilityFilter } from '../actions'
import Link from '../components/Link'

const mapStateToProps = (state, ownProps) =&gt; {
    return {
	active: ownProps.filter === state.visibilityFilter
    }
}

const mapDispatchToProps = (dispatch, ownProps) =&gt; {
    return {
	onClick: () =&gt; {
	    dispatch(setVisibilityFilter(ownProps.filter))
	}
    }
}

const FilterLink = connect(
    mapStateToProps,
    mapDispatchToProps
)(Link)

export default FilterLink
</pre>
</div>
</div>
</li>
<li><a id="orga90ee23"></a>混合在一起的写法<br />
<div class="outline-text-6" id="text-2-4-2-4-3">
<p>
看着会变得乱一点, 但没区别
</p>
<div class="org-src-container">
<pre class="src src-javascript">import React from 'react'
import { connect } from 'react-redux'
import { addTodo } from '../actions'

let AddTodo = ({ dispatch }) =&gt; {
    let input

    return (
	    &lt;div&gt;
	    &lt;form
	onSubmit={e =&gt; {
	    e.preventDefault()
	    if (!input.value.trim()) {
		return
	    }
	    dispatch(addTodo(input.value))
	    input.value = ''
	}}
	    &gt;
	    &lt;input
	ref={node =&gt; {
	    input = node
	}}
	    /&gt;
	    &lt;button type="submit"&gt;
	    Add Todo
	&lt;/button&gt;
	    &lt;/form&gt;
	    &lt;/div&gt;
    )
}
AddTodo = connect()(AddTodo)

export default AddTodo
</pre>
</div>
</div>
</li>
<li><a id="org13a8c99"></a>Provider<br />
<div class="outline-text-6" id="text-2-4-2-4-4">
<p>
在最上层用 <code>&lt;Provider&gt;</code> 包裹一下才能正确传递数据库
</p>
<div class="org-src-container">
<pre class="src src-javascript">import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp)

render(
	&lt;Provider store={store}&gt;
	&lt;App /&gt;
	&lt;/Provider&gt;,
    document.getElementById('root')
)
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgdfe6961" class="outline-3">
<h3 id="orgdfe6961"><span class="section-number-3">2.5</span> react-router: 路由管理</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org3e6e743" class="outline-4">
<h4 id="org3e6e743"><span class="section-number-4">2.5.1</span> 安装与基本使用</h4>
<div class="outline-text-4" id="text-2-5-1">
</div>
<ol class="org-ol">
<li><a id="orge64e32d"></a>安装<br />
<div class="outline-text-5" id="text-2-5-1-1">
<div class="org-src-container">
<pre class="src src-bash">yarn add react-router-dom
</pre>
</div>
</div>
</li>
<li><a id="org9e95047"></a>基本使用<br />
<ol class="org-ol">
<li><a id="org4d34904"></a>最上层路由<br />
<div class="outline-text-6" id="text-2-5-1-2-1">
<p>
可以认为这是模板代码了
</p>
<div class="org-src-container">
<pre class="src src-javascript">import { BrowserRouter } from 'react-router-dom'
ReactDOM.render((
	&lt;BrowserRouter&gt;
	&lt;App/&gt;
	&lt;/BrowserRouter&gt;
), holder)
</pre>
</div>
</div>
</li>
<li><a id="org337cf42"></a>路由分发<br />
<div class="outline-text-6" id="text-2-5-1-2-2">
<ol class="org-ol">
<li><code>Switch</code> 将可能匹配上的各种路由包裹起来</li>
<li><code>Route</code> 会比较当前的浏览器路由与 path 值, 并渲染匹配上的组件</li>
</ol>
<div class="org-src-container">
<pre class="src src-javascript">import { Route, Switch } from 'react-router-dom'
const Home = () =&gt; &lt;div&gt;Home&lt;/div&gt;

const App = () =&gt; {
    const someVariable = true;

    return (
	    &lt;Switch&gt;
	    {/* these are good */}
	    &lt;Route exact path='/' component={Home} /&gt;
	    &lt;Route
	path='/about'
	render={(props) =&gt; &lt;About {...props} extra={someVariable} /&gt;}
	    /&gt;
	    {/* do not do this */}
	    &lt;Route
	path='/contact'
	component={(props) =&gt; &lt;Contact {...props} extra={someVariable} /&gt;}
	    /&gt;  

	{/* when none of the above match, &lt;NoMatch&gt; will be rendered */}
	    &lt;Route component={NoMatch}/&gt;
	    &lt;/Switch&gt;
    )
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript">// 类似 a
    &lt;Link to='/'&gt;Home&lt;/Link&gt;
    // &lt;a href='/'&gt;Home&lt;/a&gt;

// 和 Link 一样, 只是可以自定义样式
// location = { pathname: '/react' }
    &lt;NavLink to='/react' activeClassName='hurray'&gt;React&lt;/NavLink&gt;
    // &lt;a href='/react' className='hurray'&gt;React&lt;/a&gt;

// 强行重定向
    &lt;Redirect to='/login'/&gt;
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-orga476d7f" class="outline-4">
<h4 id="orga476d7f"><span class="section-number-4">2.5.2</span> 与 redux 一起使用</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
只需要改一句
</p>
<div class="org-src-container">
<pre class="src src-javascript">// before
export default connect(mapStateToProps)(Something)

// after
import { withRouter } from 'react-router-dom'
export default withRouter(connect(mapStateToProps)(Something))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgafa8c8f" class="outline-3">
<h3 id="orgafa8c8f"><span class="section-number-3">2.6</span> emotion: css-in-js</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-orgf258ec5" class="outline-4">
<h4 id="orgf258ec5"><span class="section-number-4">2.6.1</span> 基本使用</h4>
<div class="outline-text-4" id="text-2-6-1">
</div>
<ol class="org-ol">
<li><a id="orgf2a7caf"></a>安装<br />
<div class="outline-text-5" id="text-2-6-1-1">
<div class="org-src-container">
<pre class="src src-bash">yarn add @emotion/core
</pre>
</div>
</div>
</li>
<li><a id="org2bc7ac6"></a>例子<br />
<div class="outline-text-5" id="text-2-6-1-2">
<div class="org-src-container">
<pre class="src src-javascript">// this comment tells babel to convert jsx to calls to a function called jsx instead of React.createElement
/** @jsx jsx */
import { jsx, css } from '@emotion/core'

const style = css`
  color: hotpink;
`

const SomeComponent = ({ children }) =&gt; (
  &lt;div css={style}&gt;
    Some hotpink text.
    {children}
  &lt;/div&gt;
)

const anotherStyle = css({
  textDecoration: 'underline'
})

const AnotherComponent = () =&gt; (
  &lt;div css={anotherStyle}&gt;Some text with an underline.&lt;/div&gt;
)
render(
  &lt;SomeComponent&gt;
    &lt;AnotherComponent /&gt;
  &lt;/SomeComponent&gt;
)
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1d093d1" class="outline-2">
<h2 id="org1d093d1"><span class="section-number-2">3</span> bootstrap4</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8b05939" class="outline-3">
<h3 id="org8b05939"><span class="section-number-3">3.1</span> 安装与基本使用</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org55a0bf8" class="outline-4">
<h4 id="org55a0bf8"><span class="section-number-4">3.1.1</span> 安装</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
使用CDN的源
网站的全部内容需要在一个容器里，可以是 <code>container`固定宽度并响应式或者`container-fluid</code> 100%窗口宽度
网页如下：
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;!-- Required meta tags --&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;

    &lt;!-- Bootstrap CSS --&gt;
    &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"&gt;

    &lt;title&gt;Hello, world!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello, world!&lt;/h1&gt;

    &lt;!-- Optional JavaScript --&gt;
    &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;
    &lt;script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"&gt;&lt;/script&gt;
    &lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6248b84" class="outline-4">
<h4 id="org6248b84"><span class="section-number-4">3.1.2</span> 网格系统</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
最大为12列，并且有5个类用来适应不同大小窗口
</p>

<p>
具体的写法如下：
</p>
<pre class="example">
&lt;!-- 第一个例子：控制列的宽度及在不同的设备上如何显示 --&gt;
  &lt;div class="col-*-*"&gt;&lt;/div&gt;
  &lt;div class="col-*-*"&gt;&lt;/div&gt;
  &lt;div class="col-*-*"&gt;&lt;/div&gt;
  &lt;div class="col-*-*"&gt;&lt;/div&gt;

&lt;!-- 第二个例子：或让 Bootstrap 者自动处理布局 --&gt;
  &lt;div class="col"&gt;&lt;/div&gt;
  &lt;div class="col"&gt;&lt;/div&gt;
  &lt;div class="col"&gt;&lt;/div&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b20ba3" class="outline-3">
<h3 id="org9b20ba3"><span class="section-number-3">3.2</span> 各种CSS组件</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-orgdf4c64e" class="outline-4">
<h4 id="orgdf4c64e"><span class="section-number-4">3.2.1</span> 固定在上方的导航栏</h4>
</div>
</div>
</div>
<div id="outline-container-orga8c6392" class="outline-2">
<h2 id="orga8c6392"><span class="section-number-2">4</span> Angular</h2>
<div class="outline-text-2" id="text-4">
<p>
Angular Cli 使用
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>ng new my-app</code></td>
<td class="org-left">新建项目</td>
</tr>

<tr>
<td class="org-left"><code>ng serve --open</code></td>
<td class="org-left">实时调试</td>
</tr>
</tbody>
</table>

<p>
组件
组件模板 html
插值绑定语法使用双大括号 <code>{{sth}}</code> 
这会使用ts中指定的变量.
</p>
</div>
</div>

<div id="outline-container-org0757e7d" class="outline-2">
<h2 id="org0757e7d"><span class="section-number-2">5</span> Electron基础</h2>
<div class="outline-text-2" id="text-5">
<p>
<a href="https://electron.org.cn/doc/index.html%20%7CElectron%E5%9F%BA%E7%A1%80">https://electron.org.cn/doc/index.html%20%7CElectron%E5%9F%BA%E7%A1%80</a>=
</p>
</div>
<div id="outline-container-orgfcdf6f1" class="outline-3">
<h3 id="orgfcdf6f1"><span class="section-number-3">5.1</span> 安装</h3>
<div class="outline-text-3" id="text-5-1">
<p>
安装到本地
</p>
<pre class="example">
npm install --save-dev electron
./node_modules/.bin/electron .
</pre>
</div>
</div>
<div id="outline-container-org0e504c4" class="outline-3">
<h3 id="org0e504c4"><span class="section-number-3">5.2</span> 程序结构</h3>
<div class="outline-text-3" id="text-5-2">
<p>
目录结构
</p>
<pre class="example">
your-app/         =文件夹=
├── package.json  =和node的一样，写明依赖和入口=
├── main.js       =要执行的主程序=
└── index.html    =要渲染的页面=
</pre>
<p>
<code>package.json</code>  内容
</p>
<pre class="example">
{
  "name": "your-app",
  "version": "0.1.0",
  "main": "main.js",
  "devDependencies": {
    "electron": "^1.7.5"
  }
}
</pre>
<p>
=main.js = 中要引入依赖、启动app的事件、创建主窗口
</p>

<p>
在这里需要绑定的事件有
</p>
<ul class="org-ul">
<li>ready</li>
<li>window-all-closed</li>
<li>activate</li>
</ul>
</div>


<div id="outline-container-org0c3d060" class="outline-4">
<h4 id="org0c3d060"><span class="section-number-4">5.2.1</span> 语法</h4>
<div class="outline-text-4" id="text-5-2-1">
</div>
<ol class="org-ol">
<li><a id="org60080b3"></a>绑定事件<br />
<div class="outline-text-5" id="text-5-2-1-1">
<p>
在js中使用.on()方法绑定事件
</p>
<pre class="example">
app.on('ready', createWindow)
</pre>
</div>
</li>
<li><a id="org20b8a76"></a>使用nodejs本地库<br />
<div class="outline-text-5" id="text-5-2-1-2">
<p>
在主进程中使用node,直接写就行，在渲染进程中要用 <code>window.require</code> 
</p>
<pre class="example">
var exec = require('child_process').exec,
    last = exec('last | wc -l');

last.stdout.on('data', function (data) {
    console.log('标准输出：' + data);
});
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org735fcf6" class="outline-3">
<h3 id="org735fcf6"><span class="section-number-3">5.3</span> 页面(进程)间通信</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-org3b0fea2" class="outline-4">
<h4 id="org3b0fea2"><span class="section-number-4">5.3.1</span> 广播-监听方式</h4>
</div>
</div>
<div id="outline-container-orgc359670" class="outline-3">
<h3 id="orgc359670"><span class="section-number-3">5.4</span> <a href="https://electron.org.cn/doc/tutorial/application-distribution.html%7C%E6%89%93%E5%8C%85">https://electron.org.cn/doc/tutorial/application-distribution.html%7C%E6%89%93%E5%8C%85</a></h3>
<div class="outline-text-3" id="text-5-4">
<p>
下载一个编译好的程序，把源代码放进 <code>resources/app</code> 里即可
</p>
</div>
</div>
<div id="outline-container-org53d0770" class="outline-3">
<h3 id="org53d0770"><span class="section-number-3">5.5</span> 使用React</h3>
<div class="outline-text-3" id="text-5-5">
</div>
<div id="outline-container-org3cab204" class="outline-4">
<h4 id="org3cab204"><span class="section-number-4">5.5.1</span> 配置</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
electron提供了一个窗口用来显示网页，因而使用React生成网页，并指定electron加载这个页面就可以了，首先用create-react-app创建react应用，然后修改 <code>package.json</code> ，将electron依赖添加进去，先用react编译，再用electron启动这个项目
</p>

<p>
<code>package.json</code> 添加的内容
</p>
<pre class="example">
{
  "main":"./main.js",   //指定electron的入口
  "homepage":".",       //指定React编译路径
  "dependcies":{        
    "electron":"^1.7.5" //添加electron依赖
  }
}
</pre>
<p>
<code>main.js</code> 中加载生成的页面的方法
</p>
<pre class="example">
win.loadURL(url.format({  //普通的加入页面
 pathname: path.join(__dirname, './build/index.html'),
 protocol: 'file:',
 slashes: true
}))
</pre>
</div>
</div>
<div id="outline-container-org5199efd" class="outline-4">
<h4 id="org5199efd"><span class="section-number-4">5.5.2</span> 热调试</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
加载页面为React热调试( <code>npm start</code> )页面即可
</p>
<pre class="example">
win.loadURL('http://localhost:3000/') //这样可以实现在线调试
</pre>
</div>
</div>
<div id="outline-container-org8c9f91c" class="outline-4">
<h4 id="org8c9f91c"><span class="section-number-4">5.5.3</span> 使用electron API</h4>
<div class="outline-text-4" id="text-5-5-3">
<p>
由于主进程和渲染进程的分割，React的网页只能使用有限的electron-API，与原生GUI有关的操作只能由主进程进行，通过渲染进程和主进程之间通信实现
</p>

<p>
使用electronAPI一样要用 <code>window.require</code> 
</p>
<pre class="example">
var webFrame = window.require('electron').webFrame
webFrame.setZoomFactor(2)
</pre>
</div>
</div>
<div id="outline-container-org4183073" class="outline-4">
<h4 id="org4183073"><span class="section-number-4">5.5.4</span> 使用nodejs本地库</h4>
<div class="outline-text-4" id="text-5-5-4">
<p>
不能使用 <code>require`,要用`window.require`,所以也不能`import</code> 
</p>
<pre class="example">
var cp = window.require('child_process');
var lss = cp.exec('ls -al');
lss.stdout.on('data', function(data) {console.log(data)})

</pre>
</div>
</div>
</div>
<div id="outline-container-orgd9a2048" class="outline-3">
<h3 id="orgd9a2048"><span class="section-number-3">5.6</span> API</h3>
<div class="outline-text-3" id="text-5-6">
</div>
<div id="outline-container-orgbfd0b41" class="outline-4">
<h4 id="orgbfd0b41"><span class="section-number-4">5.6.1</span> app:应用的生命周期</h4>
<div class="outline-text-4" id="text-5-6-1">
</div>
<ol class="org-ol">
<li><a id="orgba7dd95"></a>'ready':完成初始化时被触发<br />
<div class="outline-text-5" id="text-5-6-1-1">
<p>
返回:
</p>
<pre class="example">
launchInfo Object macOS
</pre>

<p>
当 Electron 完成初始化时被触发。在 macOs 中， 如果从通知中心中启动，那么launchInfo 中的userInfo包含 用来打开应用程序的 NSUserNotification 信息。你可以通过调用 app.isReady() 方法来检查此事件是否已触发。
</p>
</div>
</li>
<li><a id="org5666241"></a>'window-all-closed':当所有的窗口都被关闭时触发。<br />
<div class="outline-text-5" id="text-5-6-1-2">
<p>
如果您没有监听此事件，当所有窗口都已关闭时，默认值行为是退出应用程序。但如果你监听此事件， 将由你来控制应用程序是否退出。 如果用户按下了 Cmd + Q，或者开发者调用了 app.quit() ， Electron 将会先尝试关闭所有的窗口再触发 will-quit 事件，在这种情况下 window-all-closed 不会被触发。
</p>
</div>
</li>
<li><a id="org78455d5"></a>'activate':(macOS)当应用被激活时触发<br />
<div class="outline-text-5" id="text-5-6-1-3">
<p>
返回：
</p>
<pre class="example">
event Event
hasVisibleWindows Boolean
</pre>
<p>
当应用被激活时触发，常用于点击应用的 dock 图标的时候。
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgbcde6be" class="outline-4">
<h4 id="orgbcde6be"><span class="section-number-4">5.6.2</span> BrowserWindow:创建和控制浏览器窗口</h4>
<div class="outline-text-4" id="text-5-6-2">
</div>
<ol class="org-ol">
<li><a id="orge5a5ad5"></a>新建页面（渲染进程）<br />
<div class="outline-text-5" id="text-5-6-2-1">
<pre class="example">
window = new BrowserWindow({width: 800, height: 600})
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-12-19 Sat 14:07</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
