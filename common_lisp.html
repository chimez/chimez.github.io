<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-12-19 Sat 14:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>common lisp</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" static="static/lib/js/jquery.min.js"></script>
<script type="text/javascript" static="static/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" static="static/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" static="static/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style> p{max-width:800px;}</style>
<style> li{max-width:800px;}</style
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">common lisp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb70f78b">1. 基本语法</a>
<ul>
<li><a href="#org404ce5a">1.1. 特殊操作符</a></li>
<li><a href="#orgb109e95">1.2. 函数</a>
<ul>
<li><a href="#orge403d1f">1.2.1. 基本函数定义 <code>defun</code></a></li>
<li><a href="#org9b77133">1.2.2. 可选形参 <code>&amp;optional</code></a></li>
<li><a href="#org81ae674">1.2.3. 剩余形参 <code>&amp;rest</code></a></li>
<li><a href="#orgbcabbe5">1.2.4. 关键字形参 <code>&amp;key</code></a></li>
<li><a href="#orgfddf826">1.2.5. 强制返回值 <code>return-from</code></a></li>
<li><a href="#org067b93c">1.2.6. 获得函数对象 <code>function, #'</code></a></li>
<li><a href="#org14499c5">1.2.7. 调用函数 <code>funcall</code></a></li>
<li><a href="#orgf9158b2">1.2.8. 应用函数 <code>apply</code></a></li>
<li><a href="#orgc68c87c">1.2.9. 匿名函数 <code>lambda</code></a></li>
</ul>
</li>
<li><a href="#orge844718">1.3. 变量</a>
<ul>
<li><a href="#orgdce4ecc">1.3.1. 等价 <code>eq,eql</code></a></li>
<li><a href="#org1286aae">1.3.2. 局部变量 <code>let</code></a></li>
<li><a href="#org68c5def">1.3.3. 嵌套的局部变量 <code>let*</code></a></li>
<li><a href="#orgbc8ccba">1.3.4. 赋值和闭包 <code>setf, set, setq</code></a></li>
<li><a href="#org618a198">1.3.5. 全局变量 <code>defparameter</code></a></li>
<li><a href="#org2c9e984">1.3.6. 全局变量 <code>defvar</code></a></li>
<li><a href="#org083f388">1.3.7. 全局常量 <code>defconstant</code></a></li>
</ul>
</li>
<li><a href="#orgb0c92a7">1.4. 流程控制</a>
<ul>
<li><a href="#org4b2f504">1.4.1. 条件 <code>if</code></a></li>
<li><a href="#org4bc9f1b">1.4.2. <code>when, unless</code></a></li>
<li><a href="#org4547e44">1.4.3. 多重分支 <code>cond</code></a></li>
<li><a href="#orgb799906">1.4.4. 布尔运算 <code>and, or, not</code></a></li>
<li><a href="#org3c38b92">1.4.5. 列表上循环 <code>dolist</code></a></li>
<li><a href="#org21939e7">1.4.6. 次数循环 <code>dotimes</code></a></li>
<li><a href="#org95d338b">1.4.7. 一般循环 <code>do</code></a></li>
<li><a href="#orgf140ac8">1.4.8. <code>loop</code> 宏</a></li>
</ul>
</li>
<li><a href="#org280877f">1.5. 宏</a>
<ul>
<li><a href="#org6edf953">1.5.1. 定义宏 <code>defmacro</code></a></li>
<li><a href="#orgbfbc4d3">1.5.2. 反引用 <code>`,@</code></a></li>
<li><a href="#orgd2c6086">1.5.3. 展开宏与调试 <code>macroexpand-1</code></a></li>
<li><a href="#org83e376a">1.5.4. 自动生成变量名 <code>gensym</code></a></li>
</ul>
</li>
<li><a href="#org917d4ca">1.6. 面向对象 CLOS</a>
<ul>
<li><a href="#org6bb88c3">1.6.1. 创建类和访问实例的属性 <code>defclass, make-instance, slot-value, with-accessors</code></a></li>
<li><a href="#org6905515">1.6.2. 创建和使用方法 <code>defgeneric,defmethod,call-next-method</code></a></li>
</ul>
</li>
<li><a href="#orge1de78d">1.7. 错误处理</a></li>
<li><a href="#org0bcfee9">1.8. 包系统</a></li>
<li><a href="#orgca7738a">1.9. 类型与注解</a></li>
<li><a href="#org5aa5207">1.10. loop 宏</a></li>
<li><a href="#orgb80a672">1.11. format 宏</a></li>
</ul>
</li>
<li><a href="#org121978e">2. 标准库</a>
<ul>
<li><a href="#orgd96fc95">2.1. 数字</a>
<ul>
<li><a href="#org4b93b58">2.1.1. 数字的表示</a></li>
<li><a href="#org7202dd6">2.1.2. 算术运算 <code>mod,rem,floor,ceiling,truncate,round</code></a></li>
<li><a href="#orgb27107b">2.1.3. 数值比较</a></li>
<li><a href="#org928933a">2.1.4. 数学函数</a></li>
</ul>
</li>
<li><a href="#orgc01eff0">2.2. 字符</a>
<ul>
<li><a href="#org512f8a5">2.2.1. 字符的表示</a></li>
<li><a href="#org545b5eb">2.2.2. 字符的比较</a></li>
</ul>
</li>
<li><a href="#orgd48c8e2">2.3. 字符串</a>
<ul>
<li><a href="#org40c4128">2.3.1. 字符串的表示</a></li>
<li><a href="#orgf1c8791">2.3.2. 字符串的比较</a></li>
</ul>
</li>
<li><a href="#org13c1f99">2.4. 向量或序列</a>
<ul>
<li><a href="#org62f57fc">2.4.1. 创建向量 <code>vector, make-array</code></a></li>
<li><a href="#org700c5e4">2.4.2. 项操作函数 <code>count,find,position,remove,substitute</code></a></li>
<li><a href="#orgdbda18c">2.4.3. 序列整体操作函数 <code>copy-seq,reverse,concatenate, sort,merge, subseq, search, mismatch</code></a></li>
<li><a href="#orgf54990a">2.4.4. 遍历操作函数 <code>every,some,notany,notevery, map,reduce</code></a></li>
</ul>
</li>
<li><a href="#org4afa8f4">2.5. 哈希表</a>
<ul>
<li><a href="#orgecf1b70">2.5.1. 基本操作 <code>make-hash-table, gethash</code></a></li>
<li><a href="#org431219f">2.5.2. 迭代函数 <code>maphash</code></a></li>
</ul>
</li>
<li><a href="#org802811c">2.6. 列表</a>
<ul>
<li><a href="#org710c94f">2.6.1. 基本操作 <code>cons,car,cdr,list, nth,null,listp</code></a></li>
<li><a href="#orge5e35d4">2.6.2. 函数 <code>append,reverse,push,remove,mapcar,maplist</code></a></li>
</ul>
</li>
<li><a href="#org0b0e5de">2.7. 文件和I/O</a>
<ul>
<li><a href="#org4f700ce">2.7.1. 文件操作函数 <code>with-open-file, read, write, pprint</code></a></li>
<li><a href="#orge24e38c">2.7.2. 文件名和路径函数 <code>pathname, namestring</code></a></li>
<li><a href="#org90d849a">2.7.3. 文件系统交互函数  <code>probe-file,delete-file,rename-file</code></a></li>
<li><a href="#orgb726a2d">2.7.4. 其它I/O流 <code>with-input-from-string, with-output-to-string</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org35c74fd">3. 坑与技巧</a>
<ul>
<li><a href="#org5cfcd02">3.1. 在REPL里删除各种东西</a>
<ul>
<li><a href="#orgcb2e7d3">3.1.1. 删除变量</a></li>
<li><a href="#org9133918">3.1.2. 删除类和方法</a></li>
</ul>
</li>
<li><a href="#org98b66ab">3.2. 查询包中的符号</a>
<ul>
<li><a href="#org6b05699">3.2.1. 查询符号在哪个包中</a></li>
<li><a href="#orga2b3771">3.2.2. 列出包中所有符号</a></li>
<li><a href="#org624435e">3.2.3. 查询包使用了哪些包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd92f3fe">4. 构建项目与测试</a>
<ul>
<li><a href="#org0674e6a">4.1. roswell</a>
<ul>
<li><a href="#org8a5ab88">4.1.1. 常用命令</a></li>
</ul>
</li>
<li><a href="#org5f894e7">4.2. quicklisp</a>
<ul>
<li><a href="#org8dc1b60">4.2.1. 常用命令</a></li>
<li><a href="#orga5c930a">4.2.2. 问题</a></li>
</ul>
</li>
<li><a href="#org37f01aa">4.3. asdf</a>
<ul>
<li><a href="#org7d1e848">4.3.1. 加载 ASDF</a></li>
<li><a href="#org25e0f83">4.3.2. 配置 ASDF</a></li>
<li><a href="#org9306525">4.3.3. 使用 ASDF</a></li>
<li><a href="#org7608912">4.3.4. 定义系统</a></li>
</ul>
</li>
<li><a href="#org58d4023">4.4. rove</a></li>
<li><a href="#org56a52ad">4.5. 项目模板</a>
<ul>
<li><a href="#org16568bb">4.5.1. 文件目录</a></li>
<li><a href="#org49a563c">4.5.2. asd 文件</a></li>
<li><a href="#org506adcb">4.5.3. 源文件</a></li>
<li><a href="#orgf355f21">4.5.4. 测试文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf49b665">5. FFI</a>
<ul>
<li><a href="#orgd74cecf">5.1. CFFI</a>
<ul>
<li><a href="#orge175a39">5.1.1. 基本过程</a></li>
<li><a href="#org58e04ac">5.1.2. 类型参考</a></li>
<li><a href="#org753f387">5.1.3. 问题解决</a></li>
</ul>
</li>
<li><a href="#orgedcefaa">5.2. cl-autowrap</a>
<ul>
<li><a href="#org0e921f2">5.2.1. 安装 c2ffi</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd6aef35">6. iterate : 代替 loop 宏</a></li>
<li><a href="#orge453a9e">7. ugly-tiny-infix-macro</a></li>
<li><a href="#org09901e8">8. eazy-gnuplot</a></li>
</ul>
</div>
</div>





<div id="outline-container-orgb70f78b" class="outline-2">
<h2 id="orgb70f78b"><span class="section-number-2">1</span> 基本语法</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org404ce5a" class="outline-3">
<h3 id="org404ce5a"><span class="section-number-3">1.1</span> 特殊操作符</h3>
<div class="outline-text-3" id="text-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>控制求值</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>quote</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>if</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>progn</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>维护词法环境</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>let</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>let*</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>setq</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>flet</code></td>
<td class="org-left">局部函数</td>
</tr>

<tr>
<td class="org-left"><code>labels</code></td>
<td class="org-left">局部函数</td>
</tr>

<tr>
<td class="org-left"><code>macrolet</code></td>
<td class="org-left">局部宏</td>
</tr>

<tr>
<td class="org-left"><code>symbol-macrolet</code></td>
<td class="org-left">局部符号宏</td>
</tr>

<tr>
<td class="org-left"><code>function</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>局部控制流</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>block</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>return-from</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>tagbody</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>go</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>控制栈</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>catch</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>throw</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>unwind-protect</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>多重返回值</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>multiple-value-call</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>eval-when</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>eval-when</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>其它</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>locally</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>the</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>load-time-value</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>progv</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb109e95" class="outline-3">
<h3 id="orgb109e95"><span class="section-number-3">1.2</span> 函数</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orge403d1f" class="outline-4">
<h4 id="orge403d1f"><span class="section-number-4">1.2.1</span> 基本函数定义 <code>defun</code></h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(defun f (x)
  x)
(f 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b77133" class="outline-4">
<h4 id="org9b77133"><span class="section-number-4">1.2.2</span> 可选形参 <code>&amp;optional</code></h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
未提供的参数会自动绑定为 <code>nil</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun f (a &amp;optional b)
  (list a b))

(f 2 3)
(f 2)
</pre>
</div>
</div>
</div>

<div id="outline-container-org81ae674" class="outline-4">
<h4 id="org81ae674"><span class="section-number-4">1.2.3</span> 剩余形参 <code>&amp;rest</code></h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(defun f (a &amp;rest vals)
  (list a vals))

(f 1 2 3 4 5)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbcabbe5" class="outline-4">
<h4 id="orgbcabbe5"><span class="section-number-4">1.2.4</span> 关键字形参 <code>&amp;key</code></h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(defun f (&amp;key a b c)
  (list a b c))

(f :a 2 :c 1 :b 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfddf826" class="outline-4">
<h4 id="orgfddf826"><span class="section-number-4">1.2.5</span> 强制返回值 <code>return-from</code></h4>
<div class="outline-text-4" id="text-1-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(defun f ()
  (dotimes (i 10)
    (dotimes (j 10)
      (return-from f (list 2)))))

(f)
</pre>
</div>
</div>
</div>

<div id="outline-container-org067b93c" class="outline-4">
<h4 id="org067b93c"><span class="section-number-4">1.2.6</span> 获得函数对象 <code>function, #'</code></h4>
<div class="outline-text-4" id="text-1-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(defun f () 2)
(function f)
#'f
</pre>
</div>
</div>
</div>

<div id="outline-container-org14499c5" class="outline-4">
<h4 id="org14499c5"><span class="section-number-4">1.2.7</span> 调用函数 <code>funcall</code></h4>
<div class="outline-text-4" id="text-1-2-7">
<div class="org-src-container">
<pre class="src src-lisp">(funcall #'(lambda (x y) (+ x y)) 1 2) 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9158b2" class="outline-4">
<h4 id="orgf9158b2"><span class="section-number-4">1.2.8</span> 应用函数 <code>apply</code></h4>
<div class="outline-text-4" id="text-1-2-8">
<div class="org-src-container">
<pre class="src src-lisp">(apply #'(lambda (x y) (+ x y)) '(1 2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc68c87c" class="outline-4">
<h4 id="orgc68c87c"><span class="section-number-4">1.2.9</span> 匿名函数 <code>lambda</code></h4>
<div class="outline-text-4" id="text-1-2-9">
<div class="org-src-container">
<pre class="src src-lisp">((lambda (x) (* x 5)) 2)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge844718" class="outline-3">
<h3 id="orge844718"><span class="section-number-3">1.3</span> 变量</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgdce4ecc" class="outline-4">
<h4 id="orgdce4ecc"><span class="section-number-4">1.3.1</span> 等价 <code>eq,eql</code></h4>
<div class="outline-text-4" id="text-1-3-1">
<ol class="org-ol">
<li><code>eq</code> 比较是否为同一对象，相当于比较指针</li>
<li><code>eql</code> 比较类型和值是否都一样</li>
</ol>
</div>
</div>
<div id="outline-container-org1286aae" class="outline-4">
<h4 id="org1286aae"><span class="section-number-4">1.3.2</span> 局部变量 <code>let</code></h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 2)
      (y 3))
  (+ x y))
</pre>
</div>
</div>
</div>
<div id="outline-container-org68c5def" class="outline-4">
<h4 id="org68c5def"><span class="section-number-4">1.3.3</span> 嵌套的局部变量 <code>let*</code></h4>
<div class="outline-text-4" id="text-1-3-3">
<div class="org-src-container">
<pre class="src src-lisp">(let* ((x 2)
       (y (+ 1 x)))
  (+ x y))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbc8ccba" class="outline-4">
<h4 id="orgbc8ccba"><span class="section-number-4">1.3.4</span> 赋值和闭包 <code>setf, set, setq</code></h4>
<div class="outline-text-4" id="text-1-3-4">
<ol class="org-ol">
<li>改变的量只在闭包里</li>
<li><code>set</code> 只作用于符号</li>
<li><code>setq</code> 自动把第一个值变成符号</li>
<li><code>setf</code> 是一个宏，自动把第一个值转换成合适的东西，比如修改列表中的某一项</li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (let ((x 2))
    (print x)
    (setf x 3)
    (print x))
  (print x))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (print x)
  (set 'x 2)
  (print x)
  (setq x 3)
  (print x)
  (setf (car (list x)) 4)
  (print x))
</pre>
</div>
</div>
</div>

<div id="outline-container-org618a198" class="outline-4">
<h4 id="org618a198"><span class="section-number-4">1.3.5</span> 全局变量 <code>defparameter</code></h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
可以重新定义，可以修改
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defparameter *x* 1
  "docs")
(print *x*)
(defparameter *x* 2)
(print *x*)
(setf *x* 3)
(print *x*)
(setq *x* 4)
(print *x*)
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c9e984" class="outline-4">
<h4 id="org2c9e984"><span class="section-number-4">1.3.6</span> 全局变量 <code>defvar</code></h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
不能重新定义，可以修改
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defvar *y* 1
  "docs")
(print *y*)
(defvar *y* 2)
(print *y*)
(setf *y* 3)
(print *y*)
(setq *y* 4)
(print *y*)
</pre>
</div>
</div>
</div>

<div id="outline-container-org083f388" class="outline-4">
<h4 id="org083f388"><span class="section-number-4">1.3.7</span> 全局常量 <code>defconstant</code></h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
修改和重新定义都会报错
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defconstant const-x 1)
(print const-x)
(setf const-x 2)
(print const-x)
(defconstant const-x 3)
(print const-x)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb0c92a7" class="outline-3">
<h3 id="orgb0c92a7"><span class="section-number-3">1.4</span> 流程控制</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org4b2f504" class="outline-4">
<h4 id="org4b2f504"><span class="section-number-4">1.4.1</span> 条件 <code>if</code></h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (if (= x 1)
      2
      3))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4bc9f1b" class="outline-4">
<h4 id="org4bc9f1b"><span class="section-number-4">1.4.2</span> <code>when, unless</code></h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1 ))
  (when (= x 1)
    2))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (unless (= x 1) 2))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4547e44" class="outline-4">
<h4 id="org4547e44"><span class="section-number-4">1.4.3</span> 多重分支 <code>cond</code></h4>
<div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (cond
    ((= x 1) 2)
    ((= x 2) 3)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb799906" class="outline-4">
<h4 id="orgb799906"><span class="section-number-4">1.4.4</span> 布尔运算 <code>and, or, not</code></h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (if (and (or (= x 1)
	       (= x 2))
	   (not (= x 2)))
      2
      3))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3c38b92" class="outline-4">
<h4 id="org3c38b92"><span class="section-number-4">1.4.5</span> 列表上循环 <code>dolist</code></h4>
<div class="outline-text-4" id="text-1-4-5">
<ol class="org-ol">
<li>可以使用 <code>return</code> 结束循环</li>
<li>返回值是 <code>nil</code></li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 0))
  (dolist (i '(1 2 3))
    (if (= i 2) (return))
    (setq x (+ x i)))
  x)
</pre>
</div>
</div>
</div>
<div id="outline-container-org21939e7" class="outline-4">
<h4 id="org21939e7"><span class="section-number-4">1.4.6</span> 次数循环 <code>dotimes</code></h4>
<div class="outline-text-4" id="text-1-4-6">
<ol class="org-ol">
<li>从0 到 n-1</li>
<li>也可以使用 <code>return</code></li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x '()))
  (dotimes (i 3)
    (setf x (cons i x)))
  x)
</pre>
</div>
</div>
</div>
<div id="outline-container-org95d338b" class="outline-4">
<h4 id="org95d338b"><span class="section-number-4">1.4.7</span> 一般循环 <code>do</code></h4>
<div class="outline-text-4" id="text-1-4-7">
<ol class="org-ol">
<li>变量 <code>var</code> 初始值 <code>init-form</code> 步长 <code>step-form</code> 可以有多个变量</li>
<li>每次之后计算 <code>end-test-form</code> 只要是 <code>nil</code> 就停止循环</li>
<li>停止循环后把 <code>result-form</code> 计算后返回</li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(do ((var init-form step-form)* )
    (end-test-form result-form*)
  statement*)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf140ac8" class="outline-4">
<h4 id="orgf140ac8"><span class="section-number-4">1.4.8</span> <code>loop</code> 宏</h4>
<div class="outline-text-4" id="text-1-4-8">
</div>
<ol class="org-ol">
<li><a id="orgad90077"></a>无限循环<br />
<div class="outline-text-5" id="text-1-4-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(loop 
body)
</pre>
</div>
</div>
</li>
<li><a id="org22f4198"></a>辅助的宏<br />
<div class="outline-text-5" id="text-1-4-8-2">
<div class="org-src-container">
<pre class="src src-lisp">(loop for x across "abcdefghijkl"
     counting (find x "aeiou"))
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org280877f" class="outline-3">
<h3 id="org280877f"><span class="section-number-3">1.5</span> 宏</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org6edf953" class="outline-4">
<h4 id="org6edf953"><span class="section-number-4">1.5.1</span> 定义宏 <code>defmacro</code></h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
基本语法：
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro name (parameter*)
  "Optional documentation string"
  body-form*)
</pre>
</div>

<p>
宏的实质是构造一个 list ，然后运行这个list。
下面构造了列表语句 <code>(list (funcall #'f) (funcall #'f))</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro m (x)
  (let ((x (funcall x))
	(r '(list)))
    (dotimes (i 2) (setq r (append r '(x))))
    r))


(defun f () 2)
(m f)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbfbc4d3" class="outline-4">
<h4 id="orgbfbc4d3"><span class="section-number-4">1.5.2</span> 反引用 <code>`,@</code></h4>
<div class="outline-text-4" id="text-1-5-2">
<ol class="org-ol">
<li>反引用和引用作用是一样的</li>
<li>用逗号恢复求值，方便构造列表</li>
<li><p>
解开列表用 <code>,@</code>
</p>

<p>
这个例子和上面的作用一样，不加逗号的话得到的不是值而是符号
</p></li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro m (x)
  (let ((x (funcall x)))
    `(list ,x ,x ,x)))

(defun f () 2)
(m f)
</pre>
</div>


<p>
这里显示了解开列表的作用
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro m (x)
  (let ((x (funcall x)))
    `(list ,@x)))

(defun f () '(2 2 2))
(m f)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd2c6086" class="outline-4">
<h4 id="orgd2c6086"><span class="section-number-4">1.5.3</span> 展开宏与调试 <code>macroexpand-1</code></h4>
<div class="outline-text-4" id="text-1-5-3">
<ol class="org-ol">
<li>使用 <code>macrooexpand-1</code> 展开宏，可以看出宏最后要运行的表达式是什么</li>
<li>slime 可以用快捷键 <code>C-c RET</code> 快速展开宏</li>
<li><p>
使用时要转换成列表
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defmacro m (x)
  (let ((x (funcall x)))
    `(list ,@x)))

(defun f () '(2 2 2))
(macroexpand-1 '(m f))
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-org83e376a" class="outline-4">
<h4 id="org83e376a"><span class="section-number-4">1.5.4</span> 自动生成变量名 <code>gensym</code></h4>
<div class="outline-text-4" id="text-1-5-4">
<ol class="org-ol">
<li><p>
防止自己使用的变量名与输入的符号重复
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defmacro m (x)
  (let* ((p (gensym))
	 (x (funcall x)))
    `(dotimes (,p 10)
       (print (list ,p ,@x)))))

(defun f () '(1 2 3))
(m f)
(print (macroexpand-1 '(m f)))
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org917d4ca" class="outline-3">
<h3 id="org917d4ca"><span class="section-number-3">1.6</span> 面向对象 CLOS</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org6bb88c3" class="outline-4">
<h4 id="org6bb88c3"><span class="section-number-4">1.6.1</span> 创建类和访问实例的属性 <code>defclass, make-instance, slot-value, with-accessors</code></h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>类由 <code>defclass</code> 定义</li>
<li>属性叫做槽 slot</li>
<li>初始化实例用 <code>make-instance</code></li>
<li>访问实例的属性用 <code>with-accessors, with-slots, slot-value</code></li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp">;; 创建类
;; 槽 slots 字段
;; :initarg 初始化时使用的符号
;; :initform 默认值
;; :accesor 访问函数
;; :documentation 字段的文档
;; :allocation :class 指定槽是类所有实例公用的,默认值 :instance
(defclass person ()
  ((name :initarg :name
	 :initform "name"
	 :accessor name
	 :documentation "doc of name")
   (lisper :initform nil
	   :accessor lisper)
   (all :initform "all"
	:accessor all
	:allocation :class)))

;; 创建类的实例，同时指定初始化值
(defvar p1 (make-instance 'person :name "p1"))
(defvar p2 (make-instance 'person))

;; 访问实例的属性值
(print (slot-value p2 'name))

;; 通过访问函数获取实例的属性值
(format t "accessor (name p1):~t~s" (name p1))
(setf (lisper p1) t)
(format t "accessor (lisper p1):~t~s" (lisper p1))

;; 使用槽的名字进行访问
(with-slots (name lisper) p1
  (pprint name))

;; 使用访问函数的名字
(with-accessors ((n1 name)
		 (a1 all)) p1
  (with-accessors ((n2 name)
		   (a2 all)) p2
    (format t "访问实例属性：p1.name:~s,~tp2.name:~s" n1 n2)
    (setf a1 "a1")
    (setf a2 "a2")
    (format t "访问公用属性：p1.all:~s,~tp2.all:~s" a1 a2)
    ))



;; 初始化函数，也就是构造函数，和python的 __init__ 一样
(defmethod initialize-instance :after ((p person)  &amp;key)
  (print (slot-value p 'name))
  (setf (slot-value p 'lisper) t))

;; 删除某类的方法
(remove-method #'initialize-instance
	       (find-method #'initialize-instance ()
			    (list (find-class 'person))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org6905515" class="outline-4">
<h4 id="org6905515"><span class="section-number-4">1.6.2</span> 创建和使用方法 <code>defgeneric,defmethod,call-next-method</code></h4>
<div class="outline-text-4" id="text-1-6-2">
<ol class="org-ol">
<li>抽象函数的定义不是必须的，但为了有个地方放文档，还是要把它定义出来</li>
<li>抽象函数的参数表没有任何限制，所有只要实现方法时对不同参数指定不同的类就能实现方法的组合，即多重分发，这在一般的语言中是不能实现的</li>
<li>特化得到有效方法的组合， <code>call-next-method</code> 会找到所有可以执行的函数，然后按照一定的顺序执行它们，子类总是最先执行的</li>
<li>方法组合有 9 种和两个顺序，绝大多数情况都是标准顺序不用动
<ol class="org-ol">
<li><code>+, and, append, list, max, min, nconc, or, progn, standard</code></li>
<li><code>:most-specific-first, :most-specific-last</code></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp">(defclass person ()
  ((name :initform "name"
	 :initarg :name)
   (age :initform 0
	:initarg :age)))

(defclass child (person)
  ((ischild :initform nil
	    :initarg :ischild)))

;; 定义抽象函数,参数只表示位置
;; 方法组合默认为相关优先顺序 standard
(defgeneric name-times (person times)
  (:documentation "print name for n times")
  (:method-combination standard))

;; 为父类实现函数，参数表第二元素表示参数的类，默认为 t，即所有类
(defmethod name-times ((p person) times)
  (dotimes (i times)
    (print (slot-value p 'name))))

;; 为子类实现函数
;; call-next-method 表示执行可组合的其它方法
(defmethod name-times ((p child) times)
  (print "child:\t")
  (call-next-method))

;; 标准方法组合
;; :before 主函数之前运行
(defmethod name-times :before ((p child) times)
  (print "child:before;"))

;; :after 最后运行
(defmethod name-times :after ((p child) times)
  (print "child:after;"))

;; :around 在所有方法之前运行，需要含有 call-next-method才行
(defmethod name-times :around ((p child) times)
  (print "child:around;")
  (call-next-method))

(let ((p1 (make-instance 'child :ischild t)))
  (name-times p1 4))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge1de78d" class="outline-3">
<h3 id="orge1de78d"><span class="section-number-3">1.7</span> 错误处理</h3>
<div class="outline-text-3" id="text-1-7">
<ol class="org-ol">
<li>定义新的异常用 <code>define-condition</code></li>
<li>抛出异常 <code>error</code></li>
<li>处理异常用 <code>handler-bind, handler-case</code></li>
<li>再启动用 <code>restart-case, invoke-restart</code></li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp">;; 定义状况,和类一样,也就是异常
(define-condition my-error (error)
  ((text :initarg :text :initform "error" :accessor text)))

(define-condition my-error-2 (error)
  ((text :initarg :text :initform "error" :accessor text)))


;; 抛出一个异常
(dotimes (i 10)
  (when (= i 3)
    (error 'my-error :text "e")
    (print i)))

;; 处理异常
(dotimes (i 10)
  (handler-case
      (progn
	(when (= i 2) 
	  (error 'my-error :text "e"))
	(when (= i 4) 
	  (error 'my-error-2 :text "e"))
	(print i))
    (my-error () (print "asd"))
    (my-error-2 (c) (print (text c)))))

;; 再启动处理异常，手动选择执行哪个函数
(restart-case
    (error 'my-error)
  (use-value (value) value)
  (return-nil () nil)
  (skip-it () (print "skip"))
  (input-a-number (v)
    :report "please input a number"
    :interactive (lambda ()
		   (format t "Enter: ")
		   (list (read)))
    (format t "you input: ~a~&amp;" v)))


;; 自动执行一个函数，然后进入再启动模式
(defun my-error-skip (c)
  (declare (ignore c))
  (print "my error skip")
  (let ((r (find-restart 'my-error-skip)))
    (when r  (invoke-restart r))))

(handler-bind
    ((my-error #'my-error-skip))
  (error 'my-error))


;; 忽略所有异常
(ignore-errors
  (error 'my-error))

;; 捕获所有异常
(handler-case (/ 3 0)
  (error (c)
    (format t "We caught a condition.~&amp;")
    (values 0 c)))

;; 使用 use-value 代替错误的值，需要定制异常类型才能工作
(defun c-use-value (c)
  (use-value (lambda (arg)
	       (format t "~%dummy function with arg ~a~%" arg))
	     c))

(handler-bind ((undefined-function #'c-use-value))
  (this-function-does-not-exist "foo"))

;; 产生警告
(warn "asd")



</pre>
</div>
</div>
</div>

<div id="outline-container-org0bcfee9" class="outline-3">
<h3 id="org0bcfee9"><span class="section-number-3">1.8</span> 包系统</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">
<pre class="src src-lisp">;; 定义包
;; :nicknames 设置包的别名
;; :use 指定使用的包
;; :export 指定外部名字
;; :shadow 不导入的函数名
;; :import-from 从包导入函数
;; :shdowing-import-from 使用其它包中的函数而不是自己包中的
(defpackage :com.my.p1
  (:nicknames :cmp1 :cmpp1)
  (:use :common-lisp)
  (:export #:func1 #:func2 #:func3))


(defpackage :com.my.p2
  (:use :common-lisp :com.my.p1)
  (:import-from :com.my.p1 :func1)
  (:shadow :func2)
  (:shadowing-import-from :com.my.p1 :func3))

;; 成为当前包
(in-package :com.my.p1)

(defun func1 () (print "func1 from p1"))

(defun func2 () (print "func2 from p1"))

(defun func3 () (print "func3 from p1"))

;; 设置包的局域别名
(rename-package :common-lisp :common-lisp '(mmp))

(print (symbol-package 'mmp:defun))

;; 查看当前包名
(print *package*)

;; 查询符号在哪个包中
(print (package-name (symbol-package 'defun)))

;; 列出包中所有符号
(let (symbols)
  (do-external-symbols (s (find-package "COMMON-LISP"))
    (push s symbols))
  symbols)

;; 查询包使用了哪些包
(print (mapcar #'package-name (package-use-list :cl-user)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca7738a" class="outline-3">
<h3 id="orgca7738a"><span class="section-number-3">1.9</span> 类型与注解</h3>
</div>
<div id="outline-container-org5aa5207" class="outline-3">
<h3 id="org5aa5207"><span class="section-number-3">1.10</span> loop 宏</h3>
</div>
<div id="outline-container-orgb80a672" class="outline-3">
<h3 id="orgb80a672"><span class="section-number-3">1.11</span> format 宏</h3>
</div>
</div>
<div id="outline-container-org121978e" class="outline-2">
<h2 id="org121978e"><span class="section-number-2">2</span> 标准库</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgd96fc95" class="outline-3">
<h3 id="orgd96fc95"><span class="section-number-3">2.1</span> 数字</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org4b93b58" class="outline-4">
<h4 id="org4b93b58"><span class="section-number-4">2.1.1</span> 数字的表示</h4>
<div class="outline-text-4" id="text-2-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>123</code></td>
<td class="org-left">任意大整数</td>
</tr>

<tr>
<td class="org-left"><code>-1/2</code></td>
<td class="org-left">分数</td>
</tr>

<tr>
<td class="org-left"><code>1.3</code></td>
<td class="org-left">分数</td>
</tr>

<tr>
<td class="org-left"><code>#b101</code></td>
<td class="org-left">二进制</td>
</tr>

<tr>
<td class="org-left"><code>#o777</code></td>
<td class="org-left">八进制</td>
</tr>

<tr>
<td class="org-left"><code>#xDA</code></td>
<td class="org-left">十六进制</td>
</tr>

<tr>
<td class="org-left"><code>#36rASD</code></td>
<td class="org-left">三十六进制</td>
</tr>

<tr>
<td class="org-left"><code>1e2</code></td>
<td class="org-left">科学计数法</td>
</tr>

<tr>
<td class="org-left"><code>1s</code></td>
<td class="org-left">短型浮点数</td>
</tr>

<tr>
<td class="org-left"><code>1f</code></td>
<td class="org-left">单精度浮点数</td>
</tr>

<tr>
<td class="org-left"><code>1d</code></td>
<td class="org-left">双精度浮点数</td>
</tr>

<tr>
<td class="org-left"><code>1l</code></td>
<td class="org-left">长型浮点数</td>
</tr>

<tr>
<td class="org-left"><code>#c(2,3)</code></td>
<td class="org-left">复数</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org7202dd6" class="outline-4">
<h4 id="org7202dd6"><span class="section-number-4">2.1.2</span> 算术运算 <code>mod,rem,floor,ceiling,truncate,round</code></h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(print (+ 1 2)) ; 加
(print (- 1 2)) ; 减
(print (* 1 2)) ; 乘
(print (/ 1 2)) ; 除
(print (mod 5 3)) ; 取模
(print (rem 5 3)) ; 余数
(print (floor 1.35)) ; 向负无穷截断
(print (ceiling 1.35)) ; 向正无穷截断
(print (truncate 1.35)) ; 向零截断
(print (truncate -1.35)) ; 向零截断
(print (round 1.35)) ; 四舍五入
(print (round 1.5)) ; 四舍五入
(let ((x 1))
  (incf x) ; 自减1，修改值
  (decf x) ; 自增1，修改值
  (1+ x) ; 加1，不修改值
  (1- x) ; 减1， 不修改值
  )
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb27107b" class="outline-4">
<h4 id="orgb27107b"><span class="section-number-4">2.1.3</span> 数值比较</h4>
<div class="outline-text-4" id="text-2-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>=</code></td>
<td class="org-left">相等</td>
</tr>

<tr>
<td class="org-left"><code>/=</code></td>
<td class="org-left">不相等</td>
</tr>

<tr>
<td class="org-left"><code>&lt;,&gt;,&gt;=,&lt;=</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>max</code></td>
<td class="org-left">最大值</td>
</tr>

<tr>
<td class="org-left"><code>min</code></td>
<td class="org-left">最小值</td>
</tr>

<tr>
<td class="org-left"><code>zerop</code></td>
<td class="org-left">等于0</td>
</tr>

<tr>
<td class="org-left"><code>minusp</code></td>
<td class="org-left">小于0</td>
</tr>

<tr>
<td class="org-left"><code>plusp</code></td>
<td class="org-left">大于0</td>
</tr>

<tr>
<td class="org-left"><code>evenp</code></td>
<td class="org-left">偶数</td>
</tr>

<tr>
<td class="org-left"><code>oddp</code></td>
<td class="org-left">奇数</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org928933a" class="outline-4">
<h4 id="org928933a"><span class="section-number-4">2.1.4</span> 数学函数</h4>
<div class="outline-text-4" id="text-2-1-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>log</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>exp</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>expt</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>sin,cos,tan</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>asin,acos,atan</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>sinh,cosh,tanh</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>asinh,acosh,atanh</code></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgc01eff0" class="outline-3">
<h3 id="orgc01eff0"><span class="section-number-3">2.2</span> 字符</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org512f8a5" class="outline-4">
<h4 id="org512f8a5"><span class="section-number-4">2.2.1</span> 字符的表示</h4>
<div class="outline-text-4" id="text-2-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>#\x</code></td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left"><code>#\Space</code></td>
<td class="org-left">空格</td>
</tr>

<tr>
<td class="org-left"><code>#\Newline</code></td>
<td class="org-left">换行</td>
</tr>

<tr>
<td class="org-left"><code>#\Tab</code></td>
<td class="org-left">制表符</td>
</tr>

<tr>
<td class="org-left"><code>#\Backspace</code></td>
<td class="org-left">退格</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org545b5eb" class="outline-4">
<h4 id="org545b5eb"><span class="section-number-4">2.2.2</span> 字符的比较</h4>
<div class="outline-text-4" id="text-2-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>char=</code></td>
<td class="org-left">相等,大小写相关</td>
</tr>

<tr>
<td class="org-left"><code>char-equal</code></td>
<td class="org-left">相等，大小写无关</td>
</tr>

<tr>
<td class="org-left"><code>char/=</code></td>
<td class="org-left">不等，大小写相关</td>
</tr>

<tr>
<td class="org-left"><code>char-not-equal</code></td>
<td class="org-left">不等，大小写无关</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgd48c8e2" class="outline-3">
<h3 id="orgd48c8e2"><span class="section-number-3">2.3</span> 字符串</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org40c4128" class="outline-4">
<h4 id="org40c4128"><span class="section-number-4">2.3.1</span> 字符串的表示</h4>
<div class="outline-text-4" id="text-2-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>"asd"</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>"\""</code></td>
<td class="org-left">转义</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf1c8791" class="outline-4">
<h4 id="orgf1c8791"><span class="section-number-4">2.3.2</span> 字符串的比较</h4>
<div class="outline-text-4" id="text-2-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>string=</code></td>
<td class="org-left">相等,大小写相关</td>
</tr>

<tr>
<td class="org-left"><code>string-equal</code></td>
<td class="org-left">相等，大小写无关</td>
</tr>

<tr>
<td class="org-left"><code>string/=</code></td>
<td class="org-left">不等，大小写相关</td>
</tr>

<tr>
<td class="org-left"><code>string-not-equal</code></td>
<td class="org-left">不等，大小写无关</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org13c1f99" class="outline-3">
<h3 id="org13c1f99"><span class="section-number-3">2.4</span> 向量或序列</h3>
<div class="outline-text-3" id="text-2-4">
<p>
vector, 一维数组 sequence
</p>
</div>
<div id="outline-container-org62f57fc" class="outline-4">
<h4 id="org62f57fc"><span class="section-number-4">2.4.1</span> 创建向量 <code>vector, make-array</code></h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 创建向量
(vector 1)

;; 字面量
#(1)

;; 设置初值和大小
(make-array 4 :initial-element nil)

;; 创建定长可变数组
(make-array 5 :fill-pointer 0)

;; 填充可变数组
(vector-push 'a vec)

;; 取出可变数组
(vector-pop vec)

;; 创建可变长数组
(make-array 5 :fill-pointer :adjustable t)

;; 可变长字符数组，也就是字符串
(make-array 5 :fill-pointer :adjustable t :element-type 'character)

;; 取出第n个元素，可重设值大小
(elt vec n)
(setf (elt vec n) x)
</pre>
</div>
</div>
</div>
<div id="outline-container-org700c5e4" class="outline-4">
<h4 id="org700c5e4"><span class="section-number-4">2.4.2</span> 项操作函数 <code>count,find,position,remove,substitute</code></h4>
<div class="outline-text-4" id="text-2-4-2">
<div class="org-src-container">
<pre class="src src-lisp">;; 出现某项的次数
(count 1 #(1 2 3 1))

;; 找到第一个索引位置
(find 2  #(1 2 3 1))

;; 返回所有索引位置
(position 1 #(1 2 3 1))

;; 移除项
(remove 1 #(1 2 3 1))

;; 用新的项取代旧的项
(substitute 10 1 #(1 2 3 1))
</pre>
</div>

<p>
可以选择使用关键字参数改变行为
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>:test</code></td>
<td class="org-left">比较函数</td>
</tr>

<tr>
<td class="org-left"><code>:key</code></td>
<td class="org-left">对每项修改后用于比较</td>
</tr>

<tr>
<td class="org-left"><code>:start</code></td>
<td class="org-left">开始位置</td>
</tr>

<tr>
<td class="org-left"><code>:end</code></td>
<td class="org-left">结束位置</td>
</tr>

<tr>
<td class="org-left"><code>:from-end</code></td>
<td class="org-left">逆序</td>
</tr>

<tr>
<td class="org-left"><code>:count</code></td>
<td class="org-left">执行次数</td>
</tr>
</tbody>
</table>

<p>
对每个函数都有相应的 <code>-if</code> 和 <code>-if-not</code> 版本，用来加比较函数，只有为真的才被处理。
</p>
</div>
</div>
<div id="outline-container-orgdbda18c" class="outline-4">
<h4 id="orgdbda18c"><span class="section-number-4">2.4.3</span> 序列整体操作函数 <code>copy-seq,reverse,concatenate, sort,merge, subseq, search, mismatch</code></h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">
<pre class="src src-lisp">;; 复制
(copy-seq vec)

;; 反序
(reverse vec)

;; 连接多个序列，第一个参数需要指定生成的类型
(concatenate 'vector #(1 2) #(3 4))
(concatenate 'list #(1 2) #(3 4))

;; 排序
(sort #(1 2 3) #'&gt;)

;; 合并排序两个序列，需要指定生成类型
(merge 'vector #(1 2) #(3 4) #'&gt;)

;; 取出子序列
(subseq #(1 2 3 4) 3)
(subseq #(1 2 3 4) 1 3)

;; 子序列的位置
(search #(1 2) #(1 2 3 4))

;; 比较序列，返回第一个不同位置
(mismatch seq1 seq2)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf54990a" class="outline-4">
<h4 id="orgf54990a"><span class="section-number-4">2.4.4</span> 遍历操作函数 <code>every,some,notany,notevery, map,reduce</code></h4>
<div class="outline-text-4" id="text-2-4-4">
<div class="org-src-container">
<pre class="src src-lisp">;; 每一个都为真
(every #'evenp #(1 2 3 4))

;; 有一个为真
(some #'evenp #(1 2 3 4))

;; 有真时返回假
(notany #'evenp #(1 2 3 4))

;; 都真时返回假
(notevery #'evenp #(1 2 3 4))

;; 上面四个函数都可比较两个序列
(every #'&gt; #(1 2) #(3 4))

;; 映射，创建新序列，n-参函数和n个序列
(map 'vector #'* #(1 2) #(3 4))

;; 映射，传递到第一个参数里
(map-into a #'+ a b)

;; 级联运算, 从一个序列得到一个值,
;; 支持 :key :from-end :start :end 参数
;; 可以使用 :intial-value 给函数一个初值用来比较
(reduce #'+ #(1 2 3))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4afa8f4" class="outline-3">
<h3 id="org4afa8f4"><span class="section-number-3">2.5</span> 哈希表</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-orgecf1b70" class="outline-4">
<h4 id="orgecf1b70"><span class="section-number-4">2.5.1</span> 基本操作 <code>make-hash-table, gethash</code></h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 创建hash表，字符串做键需要指定 :test 'equal
(make-hash-table)

;; 取出键对应的值
(gethash 'key ht)

</pre>
</div>
</div>
</div>
<div id="outline-container-org431219f" class="outline-4">
<h4 id="org431219f"><span class="section-number-4">2.5.2</span> 迭代函数 <code>maphash</code></h4>
<div class="outline-text-4" id="text-2-5-2">
<div class="org-src-container">
<pre class="src src-lisp">;; 遍历所有键值对
(maphash #'(lambda (k v) v) ht)

;; loop 宏
(loop for k being the hash-keys in ht using (hash-value v)
     do func)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org802811c" class="outline-3">
<h3 id="org802811c"><span class="section-number-3">2.6</span> 列表</h3>
<div class="outline-text-3" id="text-2-6">
<p>
有副作用的操作分破坏性和回收性，破坏性操作如 <code>setf</code> 这类函数不应该用于函数式代码，回收性操作的副作用是用来优化速度的，保持无副作用的操作速度会比较慢。
</p>
</div>
<div id="outline-container-org710c94f" class="outline-4">
<h4 id="org710c94f"><span class="section-number-4">2.6.1</span> 基本操作 <code>cons,car,cdr,list, nth,null,listp</code></h4>
<div class="outline-text-4" id="text-2-6-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 连接两个元素
(cons 1 2)

;; 取出第一项
(car '(1 2))
(first '(1 2))

;; 得到剩余项
(cdr '(1 2 3))
(rest '(1 2 3)

;; 得到第n项
(nth 1 '(1 2))
(nthcdr 1 '(1 2))


;; 构造列表
(list  1 2 3)

;; 是否为点对单元
(consp o)

;; 是否不是点对单元
(atom o)

;; 是否为点的单元或nil
(listp o)

;; 是否为 nil
(null o)

</pre>
</div>
</div>
</div>
<div id="outline-container-orge5e35d4" class="outline-4">
<h4 id="orge5e35d4"><span class="section-number-4">2.6.2</span> 函数 <code>append,reverse,push,remove,mapcar,maplist</code></h4>
<div class="outline-text-4" id="text-2-6-2">
<div class="org-src-container">
<pre class="src src-lisp">;; 连接列表
(append '(1 2) '(3 4))

;; 连接列表，回收性
(nconc '(1 2) '(1 2))

;; 反序
(reverse '(1 2))

;; 反序，回收性
(nreverse '(1 2))

;; 添加项
(push i l)

;; 移除项
(remove i l)

;; 移除项，回收性
(delete i l)

;; 映射，对元素
(mapcar #'f l)

;; 映射，对点对单元
(maplist #f l)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0b0e5de" class="outline-3">
<h3 id="org0b0e5de"><span class="section-number-3">2.7</span> 文件和I/O</h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-org4f700ce" class="outline-4">
<h4 id="org4f700ce"><span class="section-number-4">2.7.1</span> 文件操作函数 <code>with-open-file, read, write, pprint</code></h4>
<div class="outline-text-4" id="text-2-7-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 打开文件
;; :if-dose-not-exist :error 报错， :create 创建 , nil 返回nil 
;; :element-type '(unsigned-byte 8) 读取二进制
;; :direction :output 输出文件
;; :if-exists :supersede 替换，:append 追加 ,:ouverwrite 覆盖 ,nil 返回nil
(open "filename")

;; 关闭文件
(close s)

;; 打开并关闭文件
(with-open-file (s "filename"))

;; 读取字符、读取行、读取s表达式、读取二进制、批量读取
(read-char s)
(read-line s)
(read s)
(read-byte s)
(read-sequence seq s)

;; 输出字符、输出行、输出字符串不换行、输出换行符、输出S表达式
(write-char c s)
(write-line str s)
(write-string str s)
(terpri s)
(fresh-line s)
(write obj s)
(print obj s) ; 有换行
(prin1 obj s) ; 无换行
(pprint obj s) ; 美化格式
(princ obj s) ; 字符串无引号
(write-sequence seq s) ; 批量输出


</pre>
</div>
</div>
</div>
<div id="outline-container-orge24e38c" class="outline-4">
<h4 id="orge24e38c"><span class="section-number-4">2.7.2</span> 文件名和路径函数 <code>pathname, namestring</code></h4>
<div class="outline-text-4" id="text-2-7-2">
<div class="org-src-container">
<pre class="src src-lisp">;; 文件名字符串转换成路径对象
(pathname "path")
#p"path"

;; 获取路径对象中的组件
(pathname-directory p) ; 文件夹路径
(pathname-name p) ; 文件名
(pathname-type p) ; 文件扩展名
(pathname-host p) ; win上返回驱动器字母
(pathname-device p) ; win上返回驱动器字母

;; 获取路径的字符串
(namestring p) ; 完整路径字符串
(directory-namestring p) ; 文件夹路径字符串
(file-namestring p) ; 文件名和扩展名字符串

;; 构造路径名
(make-pathname
 :device "c"
 :directory '(:absolute "foo" "bar")
 :name "baz"
 :type "txt")

;; 从输入的路径构造新路径
(make-pathname :type "html" :default input-pathname)
(make-pathname :directory '(:relative "b")
	       :default input-pathname)

;; 合并两个路径
(merge-pathnames #p"foo/bar.html" #p"/www/html/")
</pre>
</div>
</div>
</div>
<div id="outline-container-org90d849a" class="outline-4">
<h4 id="org90d849a"><span class="section-number-4">2.7.3</span> 文件系统交互函数  <code>probe-file,delete-file,rename-file</code></h4>
<div class="outline-text-4" id="text-2-7-3">
<div class="org-src-container">
<pre class="src src-lisp">;; 文件是否存在
(probe-file "path")

;; 删除文件
(delete-file "path")

;; 重命名文件
(rename-file "old" "new")

;; 创建目录
(ensure-directories-exist "path")

;; 获取文件写时间
(file-write-date "path")

</pre>
</div>
</div>
</div>
<div id="outline-container-orgb726a2d" class="outline-4">
<h4 id="orgb726a2d"><span class="section-number-4">2.7.4</span> 其它I/O流 <code>with-input-from-string, with-output-to-string</code></h4>
<div class="outline-text-4" id="text-2-7-4">
<div class="org-src-container">
<pre class="src src-lisp">;; 字符串流
(string-stream)
(make-string-input-stream str) ; 输入流
(make-string-output-stream str) ; 输出流
(with-input-from-string (s str)) ; 输入流
(with-output-to-string (s str)) ; 输出流

;; 流拼接
(broadcast-stream) ; 输出流转发
(concatenated-stream) ; 输入流拼接
(two-way-stream) ; 输入输出双向
(echo-stream)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org35c74fd" class="outline-2">
<h2 id="org35c74fd"><span class="section-number-2">3</span> 坑与技巧</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org5cfcd02" class="outline-3">
<h3 id="org5cfcd02"><span class="section-number-3">3.1</span> 在REPL里删除各种东西</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgcb2e7d3" class="outline-4">
<h4 id="orgcb2e7d3"><span class="section-number-4">3.1.1</span> 删除变量</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(defvar a 0)
(makunbound 'a)
(print (boundp 'a))

(defparameter b 0)
(makunbound 'b)
(print (boundp 'b))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9133918" class="outline-4">
<h4 id="org9133918"><span class="section-number-4">3.1.2</span> 删除类和方法</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(defclass c ()
  ())
(defgeneric f (c))
(defmethod f ((c c))
  (print nil))

(remove-method #'f
	       (find-method #'f
			    '()
			    (mapcar #'find-class '(c))))

(setf (find-class 'c) nil)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org98b66ab" class="outline-3">
<h3 id="org98b66ab"><span class="section-number-3">3.2</span> 查询包中的符号</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org6b05699" class="outline-4">
<h4 id="org6b05699"><span class="section-number-4">3.2.1</span> 查询符号在哪个包中</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(print (package-name (symbol-package 'defun)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga2b3771" class="outline-4">
<h4 id="orga2b3771"><span class="section-number-4">3.2.2</span> 列出包中所有符号</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(let (symbols)
  (do-external-symbols (s (find-package "COMMON-LISP"))
    (push s symbols))
  symbols)
</pre>
</div>
</div>
</div>

<div id="outline-container-org624435e" class="outline-4">
<h4 id="org624435e"><span class="section-number-4">3.2.3</span> 查询包使用了哪些包</h4>
<div class="outline-text-4" id="text-3-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(print (mapcar #'package-name (package-use-list :cl-user)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd92f3fe" class="outline-2">
<h2 id="orgd92f3fe"><span class="section-number-2">4</span> 构建项目与测试</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>roswell 用来下载和安装common lisp，和部分管理包，类似conda，  <a href="https://github.com/roswell/roswell">https://github.com/roswell/roswell</a></li>
<li>quicklisp 用来下载和管理包，类似pip， <a href="https://www.quicklisp.org/beta/">https://www.quicklisp.org/beta/</a></li>
<li>asdf 用来构建和编译包，类似setup.py <a href="https://common-lisp.net/project/asdf/">https://common-lisp.net/project/asdf/</a></li>
<li>rove 单元测试框架 <a href="https://github.com/fukamachi/rove">https://github.com/fukamachi/rove</a></li>
</ol>
</div>
<div id="outline-container-org0674e6a" class="outline-3">
<h3 id="org0674e6a"><span class="section-number-3">4.1</span> roswell</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>安上就能用了，最大的坑是安装包下载不下来，可以换别的工具下好以后放在 <code>~/.roswell/archives/</code> 文件夹里，~tmp~ 里的东西要删了之后再重新运行。</li>
</ol>
</div>
<div id="outline-container-org8a5ab88" class="outline-4">
<h4 id="org8a5ab88"><span class="section-number-4">4.1.1</span> 常用命令</h4>
<div class="outline-text-4" id="text-4-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>ros run</code></td>
<td class="org-left">运行repl</td>
</tr>

<tr>
<td class="org-left"><code>ros install</code></td>
<td class="org-left">可以从github安装包</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org5f894e7" class="outline-3">
<h3 id="org5f894e7"><span class="section-number-3">4.2</span> quicklisp</h3>
<div class="outline-text-3" id="text-4-2">
<p>
安装就按照官网即可，或用 roswell
</p>
</div>
<div id="outline-container-org8dc1b60" class="outline-4">
<h4 id="org8dc1b60"><span class="section-number-4">4.2.1</span> 常用命令</h4>
<div class="outline-text-4" id="text-4-2-1">
</div>
<ol class="org-ol">
<li><a id="org34b19bf"></a>下载并加载包<br />
<div class="outline-text-5" id="text-4-2-1-1">
<ol class="org-ol">
<li><code>:verbose t</code> ： 显示详细信息</li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload system-name)
</pre>
</div>
</div>
</li>
<li><a id="org26169c3"></a>删除包<br />
<div class="outline-text-5" id="text-4-2-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(ql:uninstall system-name)

;; 或
(ql-dist:uninstall (ql-dist:release "babel"))
(ql-dist:clean (ql-dist:dist "quicklisp"))
</pre>
</div>
</div>
</li>
<li><a id="orgb399082"></a>查询可用包<br />
<div class="outline-text-5" id="text-4-2-1-3">
<div class="org-src-container">
<pre class="src src-lisp">(ql:system-apropos substring)
(ql:system-apropos "xml")
</pre>
</div>
</div>
</li>
<li><a id="org6e6bc33"></a>升级包<br />
<div class="outline-text-5" id="text-4-2-1-4">
<div class="org-src-container">
<pre class="src src-lisp">(ql:update-dist "quicklisp")
</pre>
</div>
</div>
</li>
<li><a id="orge21edb5"></a>升级quicklisp<br />
<div class="outline-text-5" id="text-4-2-1-5">
<div class="org-src-container">
<pre class="src src-lisp">(ql:update-client)
</pre>
</div>
</div>
</li>
<li><a id="org6c81c96"></a>查看包的依赖<br />
<div class="outline-text-5" id="text-4-2-1-6">
<div class="org-src-container">
<pre class="src src-lisp">(ql:who-depends-on system-name)
</pre>
</div>
</div>
</li>
<li><a id="orgac5daaf"></a>查看已安装的包<br />
<div class="outline-text-5" id="text-4-2-1-7">
<div class="org-src-container">
<pre class="src src-lisp">(ql-dist:installed-releases (ql-dist:dist "quicklisp"))

(ql:where-is-system "cl-ppcre")
(ql:register-local-projects)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orga5c930a" class="outline-4">
<h4 id="orga5c930a"><span class="section-number-4">4.2.2</span> 问题</h4>
<div class="outline-text-4" id="text-4-2-2">
</div>
<ol class="org-ol">
<li><a id="org6a60934"></a>配置代理<br />
<div class="outline-text-5" id="text-4-2-2-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 安装时
(quicklisp-quickstart:install :proxy "http://myproxy.site.com:8080/")

;; 更改代理设置
(setf (ql-config:config-value "proxy-url") "http://proxy.value.here")
</pre>
</div>
</div>
</li>
<li><a id="orgf815bb7"></a>改变包安装位置<br />
<div class="outline-text-5" id="text-4-2-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(quicklisp-quickstart:install :path ".quicklisp/")
</pre>
</div>
</div>
</li>
<li><a id="orgc6289be"></a>安装本地包<br />
<div class="outline-text-5" id="text-4-2-2-3">
<p>
把项目放到 <code>local-projects</code> 里
</p>
<div class="org-src-container">
<pre class="src src-bash">cd ~/quicklisp/local-projects/
git clone git://github.com/xach/format-time.git
</pre>
</div>

<p>
然后
</p>
<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload "format-time")
</pre>
</div>

<p>
或者使用 asdf 的源注册系统
</p>
<div class="org-src-container">
<pre class="src src-lisp">(push #p"/projects/my-project/" asdf:*central-registry*)
(ql:quickload "my-project")
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org37f01aa" class="outline-3">
<h3 id="org37f01aa"><span class="section-number-3">4.3</span> asdf</h3>
<div class="outline-text-3" id="text-4-3">
<p>
asdf 是用来构建软件包的事实标准，所有实现都应该附带了asdf。
asdf包括两部分
</p>
<ol class="org-ol">
<li><code>asdf/defsystem</code> 用来描述源码的组成和依赖，并编译和加载包。类似于 <code>make,autoconf,dlopen,libc</code> 这一套东西。也就是通常所说的 <code>asdf</code> 。</li>
<li><code>uiop</code> 是用来在不同的系统和实现上实现移植的辅助库，可以抹平不同系统之间的差异。可以单独作为一个库使用。</li>
</ol>
</div>

<div id="outline-container-org7d1e848" class="outline-4">
<h4 id="org7d1e848"><span class="section-number-4">4.3.1</span> 加载 ASDF</h4>
<div class="outline-text-4" id="text-4-3-1">
</div>
<ol class="org-ol">
<li><a id="org8a61010"></a>加载自带的ASDF<br />
<div class="outline-text-5" id="text-4-3-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(require "asdf")
</pre>
</div>
</div>
</li>

<li><a id="org8dafb54"></a>判断是否已经加载ASDF<br />
<div class="outline-text-5" id="text-4-3-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(asdf:asdf-version)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org25e0f83" class="outline-4">
<h4 id="org25e0f83"><span class="section-number-4">4.3.2</span> 配置 ASDF</h4>
<div class="outline-text-4" id="text-4-3-2">
</div>
<ol class="org-ol">
<li><a id="orgb186dd1"></a>配置ASDF搜索系统的路径<br />
<div class="outline-text-5" id="text-4-3-2-1">
<p>
默认的搜索路径是
</p>
<ol class="org-ol">
<li>~/common-lisp/</li>
<li>~/.local/share/common-lisp/source/</li>
</ol>
<p>
如果使用了 quicklisp，已经配置好路径了，不需要自己动
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org9306525" class="outline-4">
<h4 id="org9306525"><span class="section-number-4">4.3.3</span> 使用 ASDF</h4>
<div class="outline-text-4" id="text-4-3-3">
</div>
<ol class="org-ol">
<li><a id="org9e07c64"></a>加载一个系统<br />
<div class="outline-text-5" id="text-4-3-3-1">
<div class="org-src-container">
<pre class="src src-lisp">;; 正规用法
(asdf:load-system :foo)

;; 大多数实现中可以直接
(require :foo)
</pre>
</div>
</div>
</li>

<li><a id="org15961eb"></a>其它可用函数<br />
<div class="outline-text-5" id="text-4-3-3-2">
<ol class="org-ol">
<li><code>load-system</code> 加载系统</li>
<li><code>compile-system</code> 只编译不加载</li>
<li><code>test-system</code> 运行测试</li>
<li><code>make</code> 默认就是加载系统，但是可以被系统的作者重载成别的功能</li>
<li><code>require-system</code> 加载系统，如果已经加载了就不重复加载</li>
<li><code>already-loaded-systems</code> 返回所有已经加载的系统名</li>
</ol>
</div>
</li>
</ol>
</div>
<div id="outline-container-org7608912" class="outline-4">
<h4 id="org7608912"><span class="section-number-4">4.3.4</span> 定义系统</h4>
<div class="outline-text-4" id="text-4-3-4">
</div>
<ol class="org-ol">
<li><a id="org357b0bb"></a>基本的定义系统<br />
<div class="outline-text-5" id="text-4-3-4-1">
<p>
在 <code>hello-lisp.asd</code> 文件中加入，这部分很直观了
</p>
<div class="org-src-container">
<pre class="src src-lisp">;; Usual Lisp comments are allowed here

(defsystem "hello-lisp"
    :description "hello-lisp: a sample Lisp system."
    :version "0.0.1"
    :author "Joe User &lt;joe@example.com&gt;"
    :licence "Public Domain"
    :depends-on ("optima.ppcre" "command-line-arguments")
    :components ((:file "packages")
		 (:file "macros" :depends-on ("packages"))
		 (:file "hello" :depends-on ("macros"))))
</pre>
</div>
</div>
</li>
<li><a id="org3986045"></a>复杂的例子<br />
<div class="outline-text-5" id="text-4-3-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(in-package :asdf-user) ; 没有必要，但是通常复杂情况时还是会有这句

(defsystem "foo"
  :version (:read-file-form "variables" :at (3 2))
  :components
  ((:file "package")
   (:file "variables" :depends-on ("package"))
   (:module "mod" ; 定义模块
     :depends-on ("package") ; 模块依赖文件
     :serial t ; 表示模块内的文件下一个依赖上一个
     :components ((:file "utils")
		  (:file "reader")
		  (:file "cooker")
		  (:static-file "data.raw")) ; 没有隐含扩展名，不是lisp源码
     ;; 以下两个是方法定义，用来定制asdf的行为
     :output-files (compile-op (o c) (list "data.cooked"))
     :perform (compile-op :after (o c)
	(cook-data
	 :in (component-pathname (find-component c "data.raw"))
	 :out (first (output-files o c)))))
   (:file "foo" :depends-on ("mod"))))

(defmethod action-description
    ((o compile-op) (c (eql (find-component "foo" "mod"))))
  "cooking data")
</pre>
</div>
</div>
</li>
<li><a id="orgef3b2d2"></a>一个文件一个系统模式<br />
<div class="outline-text-5" id="text-4-3-4-3">
<p>
在 3.1.2 之后版本支持。这种方法可维护性更高一点。
只需要在顶级路径指定包名，之后可以自动推断子系统名。
<code>my-lib.asd</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">;; This example is based on lil.asd of LISP-INTERFACE-LIBRARY.

;; 判断版本号，这一行没用了，因为所有实现都带了比这个更新的
#-asdf3.1 (error "MY-LIB requires ASDF 3.1 or later.") 
(defsystem "my-lib"
    :class :package-inferred-system ; 表示启用单文件系统模式
    :depends-on ("my-lib/interface/all"
		 "my-lib/src/all"
		 "my-lib/extras/all")
    :in-order-to ((test-op (load-op "my-lib/test/all")))
    :perform (test-op (o c) (symbol-call :my-lib/test/all :test-suite)))

(defsystem "my-lib/test" :depends-on ("my-lib/test/all"))

;; 代码中使用的系统名和文件名不一样时需要注册新名字
(register-system-packages "my-lib/interface/all" '(:my-lib-interface))
(register-system-packages "my-lib/src/all" '(:my-lib-implementation))
(register-system-packages "my-lib/test/all" '(:my-lib-test))

(register-system-packages
 "closer-mop"
 '(:c2mop
   :closer-common-lisp
   :c2cl
   :closer-common-lisp-user
   :c2cl-user))
</pre>
</div>

<p>
源文件应该以系统定义开头： <code>interface/order.lisp</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">(uiop:define-package :my-lib/interface/order
  (:use :closer-common-lisp
   :my-lib/interface/definition
   :my-lib/interface/base)
  (:mix :fare-utils :uiop :alexandria)
  (:export ...))
</pre>
</div>

<p>
子系统的顶级文件要重新导出 <code>interface/all.lisp</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">(uiop:define-package :my-lib/interface/all
  (:nicknames :my-lib-interface)
  (:use :closer-common-lisp)
  (:mix :fare-utils :uiop :alexandria)
  (:use-reexport
   :my-lib/interface/definition
   :my-lib/interface/base
   :my-lib/interface/order
   :my-lib/interface/monad/continuation))
</pre>
</div>

<p>
也可以使用 <code>:import-from</code> 自动生成依赖
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defpackage :foo/bar
  (:use :cl)
  (:import-from :foo/baz #:sym1 #:sym2)
  (:import-from :foo/quux)
  (:export ...))
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org58d4023" class="outline-3">
<h3 id="org58d4023"><span class="section-number-3">4.4</span> rove</h3>
<div class="outline-text-3" id="text-4-4">
<p>
从 quicklisp 直接安装即可，按照模板写，很简单
</p>
<div class="org-src-container">
<pre class="src src-lisp">;; 运行测试
(use-package :rove)
(use-package :my-a-lib)
(run :my-a-lib/tests)
</pre>
</div>
</div>
</div>

<div id="outline-container-org56a52ad" class="outline-3">
<h3 id="org56a52ad"><span class="section-number-3">4.5</span> 项目模板</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">
<pre class="src src-lisp">;; 加载项目
(ql:quickload :my-a-lib)
(use-package :my-a-lib)
(run)
(ret 3)

;; 运行测试
(ql:quickload :rove)
(rove:run :my-a-lib/tests)
</pre>
</div>
</div>

<div id="outline-container-org16568bb" class="outline-4">
<h4 id="org16568bb"><span class="section-number-4">4.5.1</span> 文件目录</h4>
<div class="outline-text-4" id="text-4-5-1">
<pre class="example">
my-a-lib
my-a-lib/my-a-lib.asd
my-a-lib/main.lisp
my-a-lib/src
my-a-lib/src/all.lisp
my-a-lib/src/p.lisp
my-a-lib/tests
my-a-lib/tests/test-all.lisp
</pre>
</div>
</div>

<div id="outline-container-org49a563c" class="outline-4">
<h4 id="org49a563c"><span class="section-number-4">4.5.2</span> asd 文件</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
<code>my-a-lib/my-a-lib.asd</code>
</p>
<div class="org-src-container">
<pre class="src src-lisp">#-asdf3.1 (error "MY-LIB requires ASDF 3.1 or later.") 
(defsystem "my-a-lib"
  :class :package-inferred-system
  :version "0.0.1"
  :author "c"
  :description "description"
  :license "BSD"
  :depends-on ("my-a-lib/main")
  :in-order-to ((test-op (test-op "my-a-lib/tests"))))

(defsystem "my-a-lib/tests"
  :class :package-inferred-system
  :depends-on ("rove"
	       "my-a-lib/tests/test-all")
  :perform (test-op (o c ) (symbol-call :rove '#:run c)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org506adcb" class="outline-4">
<h4 id="org506adcb"><span class="section-number-4">4.5.3</span> 源文件</h4>
<div class="outline-text-4" id="text-4-5-3">
</div>
<ol class="org-ol">
<li><a id="org1dec62c"></a>main.lisp<br />
<div class="outline-text-5" id="text-4-5-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(in-package :cl-user)
(defpackage :my-a-lib/main
  (:nicknames #:my-a-lib)
  (:use :cl)
  (:import-from :my-a-lib/src/all #:p)
  (:export #:run
	   #:ret))

(in-package :my-a-lib/main)

(defun run ()
  (p))

(defun ret (x)
  x)
</pre>
</div>
</div>
</li>
<li><a id="org38577ee"></a>src/all.lisp<br />
<div class="outline-text-5" id="text-4-5-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(defpackage :my-a-lib/src/all
  (:use :cl)
  (:import-from :my-a-lib/src/p #:p)
  (:export #:p))
</pre>
</div>
</div>
</li>
<li><a id="org3a2b855"></a>src/p.lisp<br />
<div class="outline-text-5" id="text-4-5-3-3">
<div class="org-src-container">
<pre class="src src-lisp">(defpackage :my-a-lib/src/p
  (:use :cl)
  (:export #:p))

(in-package :my-a-lib/src/p)


(defun p ()
  (print "in p func"))
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgf355f21" class="outline-4">
<h4 id="orgf355f21"><span class="section-number-4">4.5.4</span> 测试文件</h4>
<div class="outline-text-4" id="text-4-5-4">
</div>
<ol class="org-ol">
<li><a id="org5fd5acc"></a>tests/test-all.lisp<br />
<div class="outline-text-5" id="text-4-5-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(defpackage :my-a-lib/tests/test-all
  (:use :cl
	:my-a-lib)
  (:import-from :rove #:deftest #:testing #:ok)
  (:shadowing-import-from :rove
			  :*debug-on-error*))
(in-package :my-a-lib/tests/test-all)

(deftest my-a-test
  (testing "test part 1"
    (ok (= (ret 1) 1))
    (ok (= (ret 2) 2)))

  (testing "test part 2"
    (ok (= (ret 3) 3))))

</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgf49b665" class="outline-2">
<h2 id="orgf49b665"><span class="section-number-2">5</span> FFI</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgd74cecf" class="outline-3">
<h3 id="orgd74cecf"><span class="section-number-3">5.1</span> CFFI</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<a href="https://common-lisp.net/project/cffi/">https://common-lisp.net/project/cffi/</a>
</p>
</div>
<div id="outline-container-orge175a39" class="outline-4">
<h4 id="orge175a39"><span class="section-number-4">5.1.1</span> 基本过程</h4>
<div class="outline-text-4" id="text-5-1-1">
<ol class="org-ol">
<li>定义和加载动态库</li>
<li>使用基本的c类型，或者自己定义复杂的c类型-lisp类的新类型</li>
<li>将c函数定义成lisp函数，或者创建更lisp式的接口</li>
</ol>
</div>
<ol class="org-ol">
<li><a id="orgd304fc4"></a>加载动态链接库<br />
<div class="outline-text-5" id="text-5-1-1-1">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;; 首先要载入 cffi 系统
(asdf:load-system :cffi)

(defpackage :cffi-user
  (:use :common-lisp :cffi))

(in-package :cffi-user)

;; 定义库，主要是指定合适的名字
(define-foreign-library libcurl
  (:windows (:or "libcurl-x86.dll" "libcurl-x64.dll"))
  (:darwin (:or "libcurl.3.dylib" "libcurl.dylib"))
  (:unix (:or "libcurl.so.3" "libcurl.so"))
  (t (:default "libcurl")))

;; 载入库
(use-foreign-library libcurl)

</pre>
</div>
</div>
</li>
<li><a id="org338bcaf"></a>定义和使用基本类型与函数<br />
<div class="outline-text-5" id="text-5-1-1-2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;; 定义基本类型，相当于c类型的别名
(defctype curl-code :int)

;; 定义函数
;; 自动把名字进行转换，也可以用 ~:lisp-name~ ~:foreign-name~ 指定
;; 如果有 ~&amp;rest~ 就定义成可变参函数
;; 如果要传结构体 ~(:struct ...)~ ，就得加载 ~cffi-libffi~ 系统，这依赖 libffi
(defcfun "curl_global_init" curl-code
  (flags :long))

;; 使用函数，和普通的函数一样
(curl-global-init 0)


;; 字符串 :string 实际上是一个 char 的列表，然后返回指针 :pointer ，和 c 里的一样。
;; 要注意字符串的生命周期，它会被自动释放掉，如果想保持它，就得自己管理内存，使用全局变量或者类
(defcfun "sprintf" :int
  (str :pointer)
  (control :string)
  &amp;rest)

(with-foreign-pointer-as-string (s 100)
  (sprintf s "%c %d %.2f %s" :char 90 :short 42 :float pi
	   :string "super-locrian"))


;; 枚举和普通类型一样
(defcenum curl-option
  (:noprogress 43)
  (:nosignal 99)
  (:errorbuffer 10010)
  (:url 10002))

(foreign-funcall "curl_easy_setopt"
		 :pointer *easy-handle*
		 curl-option :nosignal :long 1 curl-code)
</pre>
</div>
</div>
</li>
<li><a id="org2e06a54"></a>回调函数<br />
<div class="outline-text-5" id="text-5-1-1-3">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defctype size :unsigned-int)

;; 回调函数可以用lisp写，然后会自动生成可以被c调用的函数
;; 回调函数里可以使用外部的变量和方法，但是返回值得是c类型的，而且必须返回确定的类型，否则会发生c的未定义行为
(defcallback easy-write size ((ptr :pointer) (size size)
			      (nmemb size) (stream :pointer))
  (let ((data-size (* size nmemb)))
    (handler-case
	;; We use the dynamically-bound *easy-write-procedure* to
	;; call a closure with useful lexical context.
	(progn (funcall (symbol-value '*easy-write-procedure*)
			(foreign-string-to-lisp ptr :count data-size))
	       data-size)         ;indicates success
      ;; The WRITEFUNCTION should return something other than the
      ;; #bytes available to signal an error.
      (error () (if (zerop data-size) 1 0)))))
</pre>
</div>
</div>
</li>
<li><a id="org0bda816"></a>定义新类型<br />
<div class="outline-text-5" id="text-5-1-1-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">;; 新的c类型就是一种类，只是有一些与ffi相关的方法和槽
;; 下面定义一个新类型，对于c代码，它只是个整数，但对于lisp，不同整数的值被翻译成符号或异常
;; 实际上的作用是 (defctype curl-code :int)
(define-foreign-type curl-code-type ()
  ()
  (:actual-type :int)
  (:simple-parser curl-code))

;; 下面给这个类型添加一个方法，从c类型转换成lisp类型时判断值是否为0，不为0就抛异常
(define-condition curl-code-error (error)
  (($code :initarg :curl-code :reader curl-error-code))
  (:report (lambda (c stream)
	     (format stream "libcurl function returned error ~A"
		     (curl-error-code c))))
  (:documentation "Signalled when a libcurl function answers
  a code other than CURLE_OK."))

(defmethod translate-from-foreign (value (type curl-code-type))
  "Raise a CURL-CODE-ERROR if VALUE, a curl-code, is non-zero."
  (if (zerop value)
      :curle-ok
    (error 'curl-code-error :curl-code value)))


;;
;; 下面定义一个新类型，它对c来说只是个指针，但对lisp，它是一个类，同时还能存储一些持久化变量，达到管理内存的效果
;; 这个类储存了与它相关的数据，包括lisp数据和c数据
(defclass easy-handle ()
  ((pointer :initform (curl-easy-init)
	    :documentation "Foreign pointer from curl_easy_init")
   (error-buffer
    :initform (foreign-alloc :char :count *curl-error-size*
			     :initial-element 0)
    :documentation "C string describing last error")
   (c-strings :initform '()
	      :documentation "C strings set as options"))
  (:documentation "I am a parameterization you may pass to
  curl-easy-perform to perform a cURL network protocol request."))

;; 创建时的初始化方法
(defmethod initialize-instance :after ((self easy-handle) &amp;key)
  (set-curl-option-errorbuffer self (slot-value self 'error-buffer)))

;; 修改对象的属性
(defun add-curl-handle-cstring (handle cstring)
  "Add CSTRING to be freed when HANDLE is, answering CSTRING."
  (car (push cstring (slot-value handle 'c-strings))))

;; 从对象中获取属性的值
(defun get-easy-handle-error (handle)
  "Answer a string containing HANDLE's current error message."
  (foreign-string-to-lisp
   (slot-value handle 'error-buffer)))

;; 用来手动释放内存的函数，当然并不能自动析构，还是得在某个位置手动调用它
(defun free-easy-handle (handle)
  "Free CURL easy interface HANDLE and any C strings created to
  be its options."
  (with-slots (pointer error-buffer c-strings) handle
    (curl-easy-cleanup pointer)
    (foreign-free error-buffer)
    (mapc #'foreign-string-free c-strings)))

;; 在储存数据的类的基础上创建cffi的类型
(define-foreign-type easy-handle-type ()
  ()
  (:actual-type :pointer)
  (:simple-parser easy-handle))

;; 并给指定这个cffi类型如何被c函数理解
(defmethod translate-to-foreign (handle (type easy-handle-type))
  "Extract the pointer from an easy-HANDLE."
  (slot-value handle 'pointer))
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org58e04ac" class="outline-4">
<h4 id="org58e04ac"><span class="section-number-4">5.1.2</span> 类型参考</h4>
<div class="outline-text-4" id="text-5-1-2">
</div>
<ol class="org-ol">
<li><a id="orgb68cb5b"></a>预定义类型<br />
<ol class="org-ol">
<li><a id="org9be7ab7"></a>基本类型<br />
<div class="outline-text-6" id="text-5-1-2-1-1">
<ol class="org-ol">
<li>字符类型： <code>:char, :unsigned-char, :short, :unsigned-short, :int, :unsigned-int, :long, :unsigned-long, :long-long, :unsigned-long-long</code></li>
<li><code>:long-long, :unsigned-long-long</code> 没有实现支持，都是使用 <code>men-ref, mem-set</code> 模拟</li>
<li>无符号字符类型的简写： <code>:uchar, :ushort, :uint, :ulong, :llong, :ullong</code></li>
<li>整数类型，对应 <code>stdint.h</code> : <code>:int8, :uint8, :int16, :uint16, :int32, :uint32, :int64, :uint64</code></li>
<li>浮点数 <code>:float</code> 对应 <code>single-float</code> ， <code>:double</code> 对应 <code>:double-float</code></li>
<li>指针 <code>:pointer</code> 对应 <code>void *</code></li>
<li>指针 <code>(:pointer :char)</code> 等，对应 <code>char *</code> ，但是没有实际效果，c的指针都是一样的。</li>
<li>无类型 <code>:void</code> 对应c的 <code>void</code> 只能用作函数的返回类型标记</li>
<li><code>:string</code> 对应 <code>char *</code> ,它的作用域是动态的，也就是说作为函数返回值时会被立即释放。也可用 <code>free-translated-object</code> 方法释放。</li>
<li><code>:string+ptr</code> 和 <code>:string</code> 一样，只是用作返回值时会返回lisp字符串和c字符串的指针两个元素的列表</li>
<li><code>:boolean</code> ： <code>nil</code> 对应 <code>int 0</code> , <code>t</code> 对应 <code>int 1</code></li>
<li><code>:bool</code> 对应 c99的 <code>_Bool</code> 和c++的 <code>bool</code></li>
</ol>
</div>
</li>

<li><a id="orgde92500"></a>结构体类型<br />
<ol class="org-ol">
<li><a id="orgb9b95e9"></a>结构体 <code>defcstruct</code><br />
<div class="outline-text-7" id="text-5-1-2-1-2-1">
<p>
只有当lisp代码需要知道结构体确切的值的时候才用，一般情况下只需要传指针 <code>:pointer</code> 不需要传值。
</p>

<p>
当确实需要传值的时候，可以使用 <code>translate-into-foreign-memory, expand-into-foreign-memory</code> 优化内存控制。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defcstruct person
  (number :int)
  (reason :string))
</pre>
</div>
</div>
</li>
<li><a id="org3361bad"></a><code>defbitfield</code><br /></li>
<li><a id="org9513774"></a>联合 <code>defcunion</code><br />
<div class="outline-text-7" id="text-5-1-2-1-2-3">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defcunion uint32-bytes
  (int-value :unsigned-int)
  (bytes :unsigned-char :count 4))
</pre>
</div>
</div>
</li>
<li><a id="org4bfc8cb"></a>枚举 <code>defcenum</code><br />
<div class="outline-text-7" id="text-5-1-2-1-2-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defcenum boolean
  :no
  :yes)

(foreign-enum-value 'boolean :no)
;; ⇒ 0

(defcenum numbers
  (:one 1)
  :two
  (:four 4))

(foreign-enum-keyword 'numbers 2)
;; ⇒ :TWO

</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</li>

<li><a id="orga6ea8e8"></a>自定义类型<br />
<ol class="org-ol">
<li><a id="orgb32c667"></a>定义基本类型 <code>defctype</code><br />
<div class="outline-text-6" id="text-5-1-2-2-1">
<p>
基本上可以认为是类型别名
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Define MY-INT as an alias for the built-in type :INT.
(defctype my-int :int)
</pre>
</div>
</div>
</li>

<li><a id="org35a705e"></a>定义c类型和lisp类型的组合 <code>:wrapper</code><br />
<div class="outline-text-6" id="text-5-1-2-2-2">
<p>
<code>:wrapper</code> 是一种将lisp类型和c类型对应组合起来的简单方法
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun bool-c-to-lisp (value)
  (not (zerop value)))

(defun bool-lisp-to-c (value)
  (if value 1 0))

(defctype my-bool (:wrapper :int :from-c bool-c-to-lisp
			    :to-c bool-lisp-to-c))

(convert-to-foreign nil 'my-bool) ⇒ 0
(convert-from-foreign 1 'my-bool) ⇒ t
</pre>
</div>
</div>
</li>

<li><a id="orgf9d6eb9"></a>定义复杂类型<br />
<ol class="org-ol">
<li><a id="org37649df"></a>定义cffi类型 <code>define-foreign-type</code><br />
<div class="outline-text-7" id="text-5-1-2-2-3-1">
<p>
也就是类和方法
</p>
<ol class="org-ol">
<li>设置类型的参数，也就是槽</li>
<li><code>:actual-type</code> 指定最终被传递给c的是什么类型</li>
<li><p>
定义类型的字面量解析方法 <code>define-parse-method</code>
</p>

<p>
下面定义 (my-string &amp;key encoding) 类型，以及 <code>(my-string :encoding :utf-8)</code> 这样使用时的行为
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(define-foreign-type my-string-type ()
  ((encoding :reader string-type-encoding :initarg :encoding))
  (:actual-type :pointer))

(define-parse-method my-string (&amp;key (encoding :utf-8))
  (make-instance 'my-string-type :encoding encoding))
</pre>
</div></li>
</ol>
</div>
</li>

<li><a id="orge7352a1"></a>定义类型转换方法 <code>translate-to-foreign, translate-from-foreign, free-translated-object</code><br />
<div class="outline-text-7" id="text-5-1-2-2-3-2">
<p>
需要定义下面几个方法
</p>
<ol class="org-ol">
<li>从lisp类型转换成c类型的方法 <code>translate-from-foreign</code></li>
<li>从c类型转换成lisp类型的方法 <code>translate-to-foreign</code></li>
<li>释放储存的数据的方法 <code>free-translated-object</code></li>
</ol>

<p>
需要注意，这三个是钩子方法，不能直接调用，调用需要用一般函数 <code>convert-to-foreign, convert-from-foreign, free-converted-object</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;; lisp -&gt; c
(defmethod translate-to-foreign (string (type my-string-type))
  (foreign-string-alloc string :encoding (string-type-encoding type)))

;; c -&gt; lisp
(defmethod translate-from-foreign (pointer (type my-string-type))
  (foreign-string-to-lisp pointer :encoding (string-type-encoding type)))

;; free
(defmethod free-translated-object (pointer (type my-string-type) param)
  (declare (ignore param))
  (foreign-string-free pointer))
</pre>
</div>
</div>
</li>

<li><a id="orgd31d7e7"></a>优化类型转换开销<br />
<div class="outline-text-7" id="text-5-1-2-2-3-3">
<p>
按照类型转换的三个函数直接写，会导致类型转换的开销。通常情况下这个问题不明显，但有时候需要尽可能减小这种开销。
</p>

<p>
减小类型转换开销的方法是使用展开宏，类似于cl的编译器宏
</p>
<ol class="org-ol">
<li><code>expand-to-foreign</code> ： lisp-&gt;c</li>
<li><code>expand-from-foreign</code> ： c-&gt;lisp</li>
<li><code>expand-to-foreign-dyn</code> ：由于没有对应的释放内存函数，只能用动态作用域的 lisp-&gt;c 函数代替，这个函数在知道对象有动态作用域的时候有用，因为这时候函数调用不会保存分配参数</li>
</ol>

<p>
展开宏比对应的翻译函数要先调用，所有如果展开宏得不到最终结构，就使用 <code>next</code> 函数让翻译函数完成剩下的工作。
</p>

<p>
例1：使用宏判断并使用对应的立即值，消除函数调用和类型转换
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(define-foreign-type my-boolean-type ()
  ()
  (:actual-type :int)
  (:simple-parser my-boolean))

(defmethod expand-to-foreign (value (type my-boolean-type))
  `(if ,value 1 0))

(defmethod expand-from-foreign (value (type my-boolean-type))
  `(not (zerop ,value)))
</pre>
</div>

<p>
例：字符串传递给函数，再得到返回值
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defmethod expand-from-foreign (form (type my-string-type))
  `(foreign-string-to-lisp ,form))

(defmethod expand-to-foreign-dyn (value var body (type my-string-type))
  (let ((encoding (string-type-encoding type)))
    `(with-foreign-string (,var ,value :encoding ',encoding)
			  ,@body)))
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="org4d41910"></a>有用的函数<br />
<div class="outline-text-6" id="text-5-1-2-2-4">
<p>
convert-from-foreign
convert-to-foreign
foreign-type-alignment
foreign-type-size
free-converted-object
free-translated-object
with-foreign-slots
</p>
</div>
</li>
</ol>
</li>

<li><a id="org62cd6cc"></a>指针和内存<br />
<div class="outline-text-5" id="text-5-1-2-3">
<p>
cffi中所有c数据都是指针，包括整数。
</p>
<ol class="org-ol">
<li>指针的类型是 <code>foreign-pointer</code></li>
<li>一些操作指针的函数： <code>make-pointer, pointer-address, pointer-eq</code></li>
<li>栈上分配内存,也是lisp的动态分配，它有动态作用域，就像用 <code>let</code> 绑定的变量： <code>with-foreign-object</code></li>
<li>堆上分配内存用 <code>foreign-alloc</code> ，会一直保持到使用 <code>foreign-free</code> 释放为止。</li>
<li>访问c内存中的值是通过 <code>mem-aref</code> 和 <code>mem-ref</code> ，并用 <code>setf</code> 修改它的值。</li>
<li>访问内存中的数据时，认为所有指针都指向了一个数组， <code>mem-aref</code> 会得到数组的下标 <code>[n]</code> ， <code>mem-ref</code> 会得到指针的解引用 <code>*</code> 。</li>
</ol>
</div>

<ol class="org-ol">
<li><a id="orgecc8a32"></a>有用的函数<br />
<div class="outline-text-6" id="text-5-1-2-3-1">
<p>
foreign-free
foreign-alloc
foreign-symbol-pointer
inc-pointer
incf-pointer
make-pointer
mem-aptr
mem-aref
mem-ref
null-pointer
null-pointer-p
pointerp
pointer-address
pointer-eq
with-foreign-object
with-foreign-objects
with-foreign-pointer
</p>
</div>
</li>
</ol>
</li>

<li><a id="org9736894"></a>字符串<br />
<div class="outline-text-5" id="text-5-1-2-4">
<p>
字符串是字符的数组，它很常用所以提供了一些函数来操作它，这些函数都可以自己来实现。所以它也可以看作是一个使用cffi的示例。
</p>

<ol class="org-ol">
<li><b>default-foreign-encoding</b></li>
<li>foreign-string-alloc</li>
<li>foreign-string-free</li>
<li>foreign-string-to-lisp</li>
<li>lisp-string-to-foreign</li>
<li>with-foreign-string</li>
<li>with-foreign-strings</li>
<li>with-foreign-pointer-as-string</li>
</ol>
</div>
</li>

<li><a id="org4f84fe0"></a>变量<br />
<div class="outline-text-5" id="text-5-1-2-5">
<ol class="org-ol">
<li><code>defcvar</code> :定义一个变量，可以直接访问，会自动把它的名字在c和lisp之间转换</li>
<li><code>get-var-pointer</code> :获得指向 <code>defcvar</code> 定义的变量的指针</li>
</ol>
</div>
</li>
<li><a id="org70d0ab5"></a>函数<br />
<div class="outline-text-5" id="text-5-1-2-6">
<ol class="org-ol">
<li><code>defcfun</code> :</li>
<li><code>foreign-funcall</code> :</li>
<li><code>foreign-funcall-pointer</code> :</li>
<li><code>foreign-funcall-varargs</code> :</li>
<li><code>foreign-funcall-pointer-varargs</code> :</li>
<li><code>translate-camelcase-name</code> :</li>
<li><code>translate-name-from-foreign</code> :</li>
<li><code>translate-name-to-foreign</code> :</li>
<li><code>translate-underscore-separated-name</code> :</li>
</ol>
</div>
</li>

<li><a id="org9acb21f"></a>回调<br />
<div class="outline-text-5" id="text-5-1-2-7">
<ol class="org-ol">
<li><code>callback</code> : 获得函数指针</li>
<li><code>defcallback</code> : 定义一个能从c访问的lisp函数</li>
<li><code>get-callback</code> : 是 <code>callback</code> 宏的函数版本</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org753f387" class="outline-4">
<h4 id="org753f387"><span class="section-number-4">5.1.3</span> 问题解决</h4>
<div class="outline-text-4" id="text-5-1-3">
</div>
<ol class="org-ol">
<li><a id="orgb3f1e88"></a>windows上的dll路径位置<br />
<div class="outline-text-5" id="text-5-1-3-1">
<p>
cffi是直接使用 <code>LoadLibrary</code> 函数加载dll库的，所以dll位置要能被这个函数找到才行。
</p>

<ol class="org-ol">
<li>把dll所在文件夹添加进 <code>PATH</code> 里，windows只认path里的东西，没有 <code>LD_LIBRARY_PATH</code> 这种变量</li>
</ol>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgedcefaa" class="outline-3">
<h3 id="orgedcefaa"><span class="section-number-3">5.2</span> cl-autowrap</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org0e921f2" class="outline-4">
<h4 id="org0e921f2"><span class="section-number-4">5.2.1</span> 安装 c2ffi</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
<a href="https://github.com/rpav/c2ffi">https://github.com/rpav/c2ffi</a>
用 llvm + cmake 那一套直接编译就好了
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd6aef35" class="outline-2">
<h2 id="orgd6aef35"><span class="section-number-2">6</span> iterate : 代替 loop 宏</h2>
<div class="outline-text-2" id="text-6">
<p>
<a href="https://common-lisp.net/project/iterate/">https://common-lisp.net/project/iterate/</a>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b>语法</b></th>
<th scope="col" class="org-left"><b>作用</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>重复次数</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(repeat 100)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>数字迭代</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for i upfrom 0)</td>
<td class="org-left">0 1 2 &#x2026;</td>
</tr>

<tr>
<td class="org-left">(for i from 5)</td>
<td class="org-left">5 6 7 &#x2026;</td>
</tr>

<tr>
<td class="org-left">(for i downfrom 0)</td>
<td class="org-left">0 -1 -2 &#x2026;</td>
</tr>

<tr>
<td class="org-left">(for i from 1 to 3)</td>
<td class="org-left">1 2 3</td>
</tr>

<tr>
<td class="org-left">(for i from 1 below 3)</td>
<td class="org-left">1 2</td>
</tr>

<tr>
<td class="org-left">(for i from 1 to 3 by 2)</td>
<td class="org-left">1 3</td>
</tr>

<tr>
<td class="org-left">(for i from 1 below 3 by 2)</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">(for i from 5 downto 3)</td>
<td class="org-left">5 4 3</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>列表迭代</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in list &amp;optional by step-function)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var on list &amp;optional by step-function)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-vector vector &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-sequence seq &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-string string &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var index-of-vector vector &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var index-of-sequence sequence &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var index-of-string string &amp;sequence)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for (key value) in-hashtable table)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-package package &amp;optional)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-packages &amp;optional having-access symbol-types)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-file name &amp;optional using reader)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var in-stream stream &amp;optional using reader)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>生成驱动器 next</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var next expr)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>条件迭代 generate</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(generate i upfrom 1) (next i)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>上一次迭代的元素 previous</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for el in '(1 2 3 4)) (for p-el previous el)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for pp-el previous el back 2 initially 0)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>变量绑定 initially then</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var initially init-expr then then-expr)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(for var first first-expr then then-expr)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>获取语句</b></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>收缩 reducing</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(sum expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(multiply expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(counting expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(maximize expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(minimize expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(reducing expr by func &amp;optional)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>累积 collect</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(collect exptr &amp;optional  into var at place result-type type )</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(adjoining exptr &amp;optional into var test test at place result-type type)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(appending expr &amp;optional into var at place)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(nconcing expr &amp;optional into var at place)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(unioning expr &amp;optional into var test test at place)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(nunioning expr &amp;optional into var test test at place)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(accumulate expr by func &amp;optional initial-value init-val into var)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>寻找 finding</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(finding expr such-that test &amp;optionally into var on-failure failure-value)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(finding expr maximizing m-expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(finding expr minimizing m-expr &amp;optional into var)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>布尔测试</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">first-iteration-p</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">first-time-p</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(always expr)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(never expr)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(thereis expr)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>控制流</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(finish)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(leave &amp;optional value)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(next-iteration)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(while expr)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(until expr)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(if-first-time then &amp;optional else)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>代码放置</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(initially &amp;rest forms)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(after-each &amp;rest forms)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(else &amp;rest forms)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(finally &amp;rest forms)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge453a9e" class="outline-2">
<h2 id="orge453a9e"><span class="section-number-2">7</span> ugly-tiny-infix-macro</h2>
<div class="outline-text-2" id="text-7">
<p>
<a href="https://github.com/peey/ugly-tiny-infix-macro">https://github.com/peey/ugly-tiny-infix-macro</a>
</p>
</div>
</div>
<div id="outline-container-org09901e8" class="outline-2">
<h2 id="org09901e8"><span class="section-number-2">8</span> eazy-gnuplot</h2>
<div class="outline-text-2" id="text-8">
<p>
<a href="https://github.com/guicho271828/eazy-gnuplot">https://github.com/guicho271828/eazy-gnuplot</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-12-19 Sat 14:07</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
