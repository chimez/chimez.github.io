<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-12-19 Sat 14:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>rust</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="static/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" static="static/lib/js/jquery.min.js"></script>
<script type="text/javascript" static="static/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" static="static/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" static="static/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style> p{max-width:800px;}</style>
<style> li{max-width:800px;}</style
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">rust</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9c2c1d4">1. Rust教程学习:基本概念</a>
<ul>
<li><a href="#org56643db">1.1. 基本程序结构</a>
<ul>
<li><a href="#orgbabc467">1.1.1. 主函数:程序运行的入口</a></li>
<li><a href="#orgfbfeb33">1.1.2. 引入外部类型</a></li>
<li><a href="#orgd941218">1.1.3. 引入外部依赖</a></li>
</ul>
</li>
<li><a href="#orgd10f27b">1.2. 变量与常量</a>
<ul>
<li><a href="#orgbef2280">1.2.1. 创建变量</a></li>
<li><a href="#org812d675">1.2.2. 创建常量</a></li>
<li><a href="#orgb1ab7b8">1.2.3. 变量的隐藏(shadow)</a></li>
<li><a href="#org3961ff5">1.2.4. 引用&amp;</a></li>
</ul>
</li>
<li><a href="#org5003eb0">1.3. 数据类型</a>
<ul>
<li><a href="#orga15926e">1.3.1. 类型操作</a></li>
<li><a href="#org4c09db0">1.3.2. 原生类型</a></li>
<li><a href="#org45a2647">1.3.3. 结构体(struct)</a></li>
<li><a href="#org202347f">1.3.4. 枚举enum</a></li>
<li><a href="#orgb33ba79">1.3.5. 通用集合类型</a></li>
</ul>
</li>
<li><a href="#org936340f">1.4. 函数与方法</a>
<ul>
<li><a href="#orgc82c74c">1.4.1. 函数定义</a></li>
<li><a href="#org094f38b">1.4.2. 函数调用</a></li>
<li><a href="#org1fa01a5">1.4.3. 发散函数</a></li>
<li><a href="#org5b379f0">1.4.4. 方法</a></li>
<li><a href="#orgc446135">1.4.5. 错误处理类型Result</a></li>
</ul>
</li>
<li><a href="#orge9bd4fe">1.5. 逻辑</a>
<ul>
<li><a href="#org4eb62a5">1.5.1. match:分支匹配</a></li>
<li><a href="#orge6a3356">1.5.2. if let:单支匹配</a></li>
<li><a href="#org0eb7909">1.5.3. 模式:用于值的匹配</a></li>
<li><a href="#org1fe95ae">1.5.4. loop:无限循环</a></li>
<li><a href="#orgbcfeafa">1.5.5. break:跳出循环</a></li>
<li><a href="#orgafb0a1b">1.5.6. continue:到标签循环</a></li>
<li><a href="#org58d7b5e">1.5.7. if:条件判断</a></li>
<li><a href="#org0099a82">1.5.8. while:条件为真时循环</a></li>
<li><a href="#org7fe3f2f">1.5.9. for:遍历列表</a></li>
<li><a href="#orgc77a072">1.5.10. 错误处理</a></li>
</ul>
</li>
<li><a href="#orgc91e7fa">1.6. 所有权(ownership)</a>
<ul>
<li><a href="#org89ffca1">1.6.1. 所有权概念</a></li>
<li><a href="#org6e19aa5">1.6.2. 引用(reference)</a></li>
<li><a href="#orgdf38a6d">1.6.3. 生命周期</a></li>
</ul>
</li>
<li><a href="#org1ff4c0b">1.7. 模块</a>
<ul>
<li><a href="#orge63773f">1.7.1. 定义库项目与模块</a></li>
<li><a href="#org9ad02de">1.7.2. 公有与私有</a></li>
<li><a href="#org55d1fdf">1.7.3. 引入到作用域</a></li>
</ul>
</li>
<li><a href="#org16c78e1">1.8. 泛型</a>
<ul>
<li><a href="#org635ee0d">1.8.1. 定义与使用泛型</a></li>
<li><a href="#org79b864f">1.8.2. trait:不同类型的共同方法实现接口</a></li>
<li><a href="#org83a47c5">1.8.3. 关联类型</a></li>
<li><a href="#org3cda352">1.8.4. 运算符重载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc4fe25a">2. 进阶知识</a>
<ul>
<li><a href="#orgd2da5b6">2.1. 测试</a></li>
<li><a href="#org6d8c102">2.2. 函数式</a>
<ul>
<li><a href="#org22ea688">2.2.1. 闭包:匿名函数</a></li>
</ul>
</li>
<li><a href="#org1c2d982">2.3. 迭代器</a>
<ul>
<li><a href="#orgbc338cb">2.3.1. 使用迭代器</a></li>
<li><a href="#org07efece">2.3.2. 自定义迭代器</a></li>
</ul>
</li>
<li><a href="#orgc040e6d">2.4. 智能指针</a>
<ul>
<li><a href="#org08f05ba">2.4.1. Box&lt;T&gt;:堆上存储数据</a></li>
<li><a href="#orgd4ac984">2.4.2. 自定义智能指针</a></li>
<li><a href="#org312d68c">2.4.3. Rc&lt;T&gt;:单线程引用计数指针</a></li>
<li><a href="#orgac9f525">2.4.4. RefCell&lt;T&gt;:内部可变模式</a></li>
<li><a href="#org65a1eb1">2.4.5. Weak&lt;T&gt;:弱引用计数指针</a></li>
</ul>
</li>
<li><a href="#orgb78ebe1">2.5. 并发与并行</a>
<ul>
<li><a href="#org2d1d0d8">2.5.1. 线程</a></li>
<li><a href="#org34e6d7e">2.5.2. 线程通信</a></li>
<li><a href="#org7539572">2.5.3. 共享状态</a></li>
<li><a href="#orgf5971b2">2.5.4. Rust语言内的并发trait</a></li>
</ul>
</li>
<li><a href="#org9f05223">2.6. 面向对象</a></li>
<li><a href="#orga18fb10">2.7. 属性</a>
<ul>
<li><a href="#orgcf90ffe">2.7.1. derive:自动实现一些泛型方法</a></li>
<li><a href="#orgdd690ff">2.7.2. 过程宏</a></li>
</ul>
</li>
<li><a href="#org8eae378">2.8. 宏</a>
<ul>
<li><a href="#org6aed1b7">2.8.1. 语法</a></li>
<li><a href="#org3e71ed9">2.8.2. 指示符</a></li>
</ul>
</li>
<li><a href="#org4ef7011">2.9. 不安全的Rust</a>
<ul>
<li><a href="#orgcb1018d">2.9.1. 裸指针</a></li>
<li><a href="#orga94e274">2.9.2. unsafe</a></li>
<li><a href="#org2bf0b2a">2.9.3. 创建安全抽象</a></li>
<li><a href="#org43eebe2">2.9.4. ffi:与C交互</a></li>
</ul>
</li>
<li><a href="#org56caee6">2.10. 高级函数</a>
<ul>
<li><a href="#orgaacb148">2.10.1. fn(T):函数指针</a></li>
<li><a href="#orgc4eed3d">2.10.2. 返回闭包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf78bb42">3. Cargo</a>
<ul>
<li><a href="#org71751c2">3.1. 基本命令</a></li>
<li><a href="#org9c228d3">3.2. 配置文件</a></li>
<li><a href="#orgdad3e5a">3.3. 项目注释和文档自动生成</a></li>
<li><a href="#orgf2bae4f">3.4. 发布</a></li>
</ul>
</li>
<li><a href="#org59aee1c">4. Rust 语法速查</a>
<ul>
<li><a href="#orge218910">4.1. link</a></li>
<li><a href="#org2b19377">4.2. 控制结构</a>
<ul>
<li><a href="#orgc4a728e">4.2.1. 基本程序</a></li>
<li><a href="#orged93d3d">4.2.2. 函数</a></li>
<li><a href="#orgfb379a4">4.2.3. 控制结构</a></li>
<li><a href="#org077b5c7">4.2.4. 模式匹配</a></li>
<li><a href="#org2699d79">4.2.5. 所有权</a></li>
</ul>
</li>
<li><a href="#org1bb9159">4.3. 数据类型</a>
<ul>
<li><a href="#org18aae7c">4.3.1. 标量类型</a></li>
<li><a href="#org359d918">4.3.2. 复合类型</a></li>
<li><a href="#orgd6595e1">4.3.3. 字符串 <code>std::string</code></a></li>
<li><a href="#orgc916484">4.3.4. 通用集合类型</a></li>
<li><a href="#orge527f2a">4.3.5. 结构体</a></li>
<li><a href="#org1dee1d2">4.3.6. 枚举</a></li>
<li><a href="#org6e21fcc">4.3.7. 智能指针</a></li>
</ul>
</li>
<li><a href="#orgba977c7">4.4. 泛型</a>
<ul>
<li><a href="#orgc89f1a0">4.4.1. trait</a></li>
<li><a href="#org4cd7bc3">4.4.2. 生命周期</a></li>
</ul>
</li>
<li><a href="#orgc9ace8f">4.5. 错误处理</a></li>
<li><a href="#orgcb3470c">4.6. I/O <code>std::io</code></a></li>
<li><a href="#org5380821">4.7. 文件系统 <code>use std::fs::File;</code></a></li>
<li><a href="#org259ab59">4.8. 函数式编程</a></li>
<li><a href="#org4c15a38">4.9. 并发</a></li>
<li><a href="#orgf8272ec">4.10. 不安全</a>
<ul>
<li><a href="#orgf6e9ccd">4.10.1. FFI</a></li>
</ul>
</li>
<li><a href="#org404febc">4.11. 宏</a></li>
<li><a href="#org8fd7398">4.12. 组织一个项目</a>
<ul>
<li><a href="#orgf4d974f">4.12.1. 模块系统</a></li>
<li><a href="#orgc37b142">4.12.2. Cargo</a></li>
<li><a href="#org02ead92">4.12.3. 测试</a></li>
</ul>
</li>
<li><a href="#org891d374">4.13. 程序模板</a>
<ul>
<li><a href="#org3d129dc">4.13.1. 模式匹配</a></li>
<li><a href="#org1ff0b9f">4.13.2. 结构体</a></li>
<li><a href="#org744b715">4.13.3. 枚举</a></li>
<li><a href="#org16f1dda">4.13.4. trait</a></li>
<li><a href="#org9a6ce79">4.13.5. 泛型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfe01dd7">5. Rust函数记录</a>
<ul>
<li><a href="#orgc2718a5">5.1. 常用函数</a></li>
<li><a href="#org3a25c9c">5.2. 常用宏</a></li>
<li><a href="#orgb58e9c7">5.3. 过程宏</a></li>
</ul>
</li>
<li><a href="#org4b0682c">6. 原始类型</a>
<ul>
<li><a href="#orgf477398">6.1. str:字符串</a></li>
</ul>
</li>
<li><a href="#org88cf15d">7. 标准库</a>
<ul>
<li><a href="#org9939d82">7.1. std::String:可变字符串</a></li>
<li><a href="#orgad5c229">7.2. std::collections::HashMap</a></li>
<li><a href="#orgba598ab">7.3. std::vec::Vec:可变数组</a></li>
<li><a href="#org0dd0759">7.4. std::io:标准输入输出</a></li>
<li><a href="#org5ef7acb">7.5. std::cmp:比较</a>
<ul>
<li><a href="#org2533a1a">7.5.1. std::cmp::Ordering:比较大小</a></li>
</ul>
</li>
<li><a href="#org561384d">7.6. std::env:命令行参数</a></li>
</ul>
</li>
<li><a href="#org4ec0ee8">8. 外部库</a>
<ul>
<li><a href="#orgb80ced2">8.1. regex:正则表达式</a></li>
</ul>
</li>
<li><a href="#orgc3f4ba7">9. 大体上与一般的正则表达式相同,但有一些特有写法</a>
<ul>
<li><a href="#org82ee0c9">9.1. rand:随机数生成</a></li>
</ul>
</li>
<li><a href="#org1169cb5">10. Rust 踩过的坑</a>
<ul>
<li><a href="#org68f064f">10.1. rust 编译成动态链接库供 c, python 使用</a>
<ul>
<li><a href="#org35ad4e2">10.1.1. rust</a></li>
<li><a href="#org0e4512c">10.1.2. c</a></li>
<li><a href="#org477913c">10.1.3. python</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-org9c2c1d4" class="outline-2">
<h2 id="org9c2c1d4"><span class="section-number-2">1</span> Rust教程学习:基本概念</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org56643db" class="outline-3">
<h3 id="org56643db"><span class="section-number-3">1.1</span> 基本程序结构</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-orgbabc467" class="outline-4">
<h4 id="orgbabc467"><span class="section-number-4">1.1.1</span> 主函数:程序运行的入口</h4>
<div class="outline-text-4" id="text-1-1-1">
<div class="org-src-container">
<pre class="src src-rust">fn main(){
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfbfeb33" class="outline-4">
<h4 id="orgfbfeb33"><span class="section-number-4">1.1.2</span> 引入外部类型</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
在源文件的开头
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::io
    ...
    io::stdin()
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd941218" class="outline-4">
<h4 id="orgd941218"><span class="section-number-4">1.1.3</span> 引入外部依赖</h4>
<div class="outline-text-4" id="text-1-1-3">
<div class="org-src-container">
<pre class="src src-rust">extern crate rand
use rand::io

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd10f27b" class="outline-3">
<h3 id="orgd10f27b"><span class="section-number-3">1.2</span> 变量与常量</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgbef2280" class="outline-4">
<h4 id="orgbef2280"><span class="section-number-4">1.2.1</span> 创建变量</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-rust">let foo = 5; //默认不可变
let mut bar = 5; //声明可变
</pre>
</div>
</div>
</div>
<div id="outline-container-org812d675" class="outline-4">
<h4 id="org812d675"><span class="section-number-4">1.2.2</span> 创建常量</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>按照规则常量全大写,而且常量不可变</li>
<li><code>const</code> 常量会在编译时内联,内存地址不定</li>
<li><code>static</code> 常量编译时固定指针,内存地址固定</li>
<li><code>const</code> 常量绝对不可变</li>
<li><code>static mut</code> 可变,但要用 <code>unsafe</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">const MA_B: u32 = 100;
static N: i32 = 5;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb1ab7b8" class="outline-4">
<h4 id="orgb1ab7b8"><span class="section-number-4">1.2.3</span> 变量的隐藏(shadow)</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
对同一个变量名重新定义时,不会出错只会使第一个变量被后来的隐藏,如果使用 <code>:</code> 声明类型,则不同类型可以共用同一个变量名
</p>
</div>
</div>
<div id="outline-container-org3961ff5" class="outline-4">
<h4 id="org3961ff5"><span class="section-number-4">1.2.4</span> 引用&amp;</h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">
<pre class="src src-rust">&amp;foo //默认不可变
    &amp;mut bar //声明可变
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5003eb0" class="outline-3">
<h3 id="org5003eb0"><span class="section-number-3">1.3</span> 数据类型</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orga15926e" class="outline-4">
<h4 id="orga15926e"><span class="section-number-4">1.3.1</span> 类型操作</h4>
<div class="outline-text-4" id="text-1-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>type a=i32</code></td>
<td class="org-left">类型别名</td>
</tr>

<tr>
<td class="org-left"><code>强制转换</code></td>
<td class="org-left">无显示语法,在调用参数,定义变量和返回参数时自动进行</td>
</tr>

<tr>
<td class="org-left"><code>let y = x as i64;</code></td>
<td class="org-left">安全类型转换,安全的意思是如果编译器认为这个转换不安全就不给你编译</td>
</tr>

<tr>
<td class="org-left"><code>mem::transmute::&lt;[u8; 4], u32&gt;(a);</code></td>
<td class="org-left">不安全的强制转换,需要 <code>unsafe</code></td>
</tr>

<tr>
<td class="org-left"><code>trait A{type N}</code></td>
<td class="org-left">关联类型,用 <code>type</code> 可以声明一个抽象的类型,等到后面实现具体方法时再进行实现</td>
</tr>

<tr>
<td class="org-left"><code>struct Foo&lt;T: ?Sized&gt; {}</code></td>
<td class="org-left">不定长类型,动态大小类型</td>
</tr>

<tr>
<td class="org-left"><code>A&lt;RHS=B&gt;</code></td>
<td class="org-left">默认类型参数</td>
</tr>

<tr>
<td class="org-left"><code>A&lt;!&gt;</code></td>
<td class="org-left">发散类型,或者叫任意类型</td>
</tr>
</tbody>
</table>
</div>

<ol class="org-ol">
<li><a id="org1b37c41"></a>默认类型参数<br />
<div class="outline-text-5" id="text-1-3-1-1">
<div class="org-src-container">
<pre class="src src-rust">
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org4c09db0" class="outline-4">
<h4 id="org4c09db0"><span class="section-number-4">1.3.2</span> 原生类型</h4>
<div class="outline-text-4" id="text-1-3-2">
</div>
<ol class="org-ol">
<li><a id="org69c02b3"></a>字面量数据类型<br />
<div class="outline-text-5" id="text-1-3-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>i32</code></td>
<td class="org-left">32位有符号数,9i32</td>
</tr>

<tr>
<td class="org-left"><code>u32</code></td>
<td class="org-left">32位无符号数,-8u32</td>
</tr>

<tr>
<td class="org-left"><code>f64</code></td>
<td class="org-left">64位双精度浮点数,3.4f64</td>
</tr>

<tr>
<td class="org-left"><code>bool</code></td>
<td class="org-left">布尔类型,'false'</td>
</tr>

<tr>
<td class="org-left"><code>char</code></td>
<td class="org-left">utf8字符,'三'</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org5f67d34"></a>元组<br />
<div class="outline-text-5" id="text-1-3-2-2">
<div class="org-src-container">
<pre class="src src-rust">let tup: (i32, f64, u8) = (500 ,5, 1) //定义
    let (x, y, z) = tup	//解构
    tup.0 //直接访问
</pre>
</div>
</div>
</li>
<li><a id="org52fc7d0"></a>数组array<br />
<div class="outline-text-5" id="text-1-3-2-3">
<p>
长度不可变,每个元素类型必须相同,当引用越界时会产生运行时错误,而不会访问外部内存
</p>
<div class="org-src-container">
<pre class="src src-rust">let a = [1,2,3];//声明
a[0]//引用
    &amp;a[0..1]//slide引用
</pre>
</div>
</div>
</li>

<li><a id="orgfefd93b"></a>slice<br />
<div class="outline-text-5" id="text-1-3-2-4">
<p>
获得字符串/数组的一部分,只是引用,如果不加引用将得到所有权,会出错
</p>
<div class="org-src-container">
<pre class="src src-rust">&amp;str
    &amp;"ssss"[0..2]
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org45a2647" class="outline-4">
<h4 id="org45a2647"><span class="section-number-4">1.3.3</span> 结构体(struct)</h4>
<div class="outline-text-4" id="text-1-3-3">
</div>
<ol class="org-ol">
<li><a id="orga2cf803"></a>结构体的定义与引用<br />
<div class="outline-text-5" id="text-1-3-3-1">
<div class="org-src-container">
<pre class="src src-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};


user1.email = String::from("anotheremail@example.com");
</pre>
</div>
</div>
</li>
<li><a id="org51eddc4"></a>结构体简化初始化写法<br />
<div class="outline-text-5" id="text-1-3-3-2">
<p>
当变量名与结构体字段同名时可用
</p>

<div class="org-src-container">
<pre class="src src-rust">fn build_user(email: String, username: String) -&gt; User {
    User {
	email,
	username,
	active: true,
	sign_in_count: 1,
    }
}
</pre>
</div>
</div>
</li>
<li><a id="org94ded05"></a>结构体更新语法<br />
<div class="outline-text-5" id="text-1-3-3-3">
<p>
可以从一个旧的结构体继承大部分数据
</p>
<div class="org-src-container">
<pre class="src src-rust">let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
</pre>
</div>
</div>
</li>

<li><a id="orgc1b1ef8"></a>无字段名的结构体<br />
<div class="outline-text-5" id="text-1-3-3-4">
<div class="org-src-container">
<pre class="src src-rust">
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org202347f" class="outline-4">
<h4 id="org202347f"><span class="section-number-4">1.3.4</span> 枚举enum</h4>
<div class="outline-text-4" id="text-1-3-4">
</div>
<ol class="org-ol">
<li><a id="orgd1a744b"></a>定义枚举<br />
<div class="outline-text-5" id="text-1-3-4-1">
<p>
枚举列出了所有可能的取值
</p>
<div class="org-src-container">
<pre class="src src-rust">
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
</pre>
</div>
</div>
</li>
<li><a id="org7e72e09"></a>空值枚举Option&lt;T&gt;<br />
<div class="outline-text-5" id="text-1-3-4-2">
<p>
一个量要么是某类型的,要么什么都不是
</p>
<div class="org-src-container">
<pre class="src src-rust">
enum Option&lt;T&gt; {
    Some(T),
    None,
};
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb33ba79" class="outline-4">
<h4 id="orgb33ba79"><span class="section-number-4">1.3.5</span> 通用集合类型</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
<ol class="org-ol">
<li><a id="orga60933f"></a>向量(vector)<br />
<div class="outline-text-5" id="text-1-3-5-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>let v: Vec&lt;i32&gt; = Vec::new();</code></td>
<td class="org-left">新建空的向量</td>
</tr>

<tr>
<td class="org-left"><code>let v = vec![1, 2, 3];</code></td>
<td class="org-left">新建带初值的向量</td>
</tr>

<tr>
<td class="org-left"><code>v.push(5);</code></td>
<td class="org-left">添加元素(要求是可变的)</td>
</tr>

<tr>
<td class="org-left"><code>let third: &amp;i32 = &amp;v[2];</code></td>
<td class="org-left">引用序号,越界将崩溃</td>
</tr>

<tr>
<td class="org-left"><code>let third: Option&lt;&amp;i32&gt; = v.get(2);</code></td>
<td class="org-left">引用序号,越界错误处理</td>
</tr>

<tr>
<td class="org-left"><code>for i in &amp;v {}</code></td>
<td class="org-left">遍历向量</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org63b659d"></a>字符串(String)<br />
<div class="outline-text-5" id="text-1-3-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>let mut s = String::new();</code></td>
<td class="org-left">新建空字符串</td>
</tr>

<tr>
<td class="org-left"><code>let s = String::from("initial contents");</code></td>
<td class="org-left">新建初值字符串</td>
</tr>

<tr>
<td class="org-left"><code>s.push_str("bar");</code></td>
<td class="org-left">追加字符串</td>
</tr>

<tr>
<td class="org-left"><code>s.push('l');</code></td>
<td class="org-left">追加字符</td>
</tr>

<tr>
<td class="org-left"><code>let s3 = s1 + &amp;s2;</code></td>
<td class="org-left">字符串连接</td>
</tr>

<tr>
<td class="org-left"><code>let s = format!("{}-{}-{}", s1, s2, s3);</code></td>
<td class="org-left">复杂字符串连接</td>
</tr>

<tr>
<td class="org-left"><code>for c in "नमस्ते".chars() {}</code></td>
<td class="org-left">字符串遍历</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org428f65b"></a>哈希(hash map)<br />
<div class="outline-text-5" id="text-1-3-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>use std::collections::HashMap;</code></td>
<td class="org-left">必须先从标准库引入HashMap</td>
</tr>

<tr>
<td class="org-left"><code>let mut scores = HashMap::new();</code></td>
<td class="org-left">新建空map,不存在初始化宏</td>
</tr>

<tr>
<td class="org-left"><code>scores.insert(String::from("Blue"), 10);</code></td>
<td class="org-left">插入新项,或覆盖旧的</td>
</tr>

<tr>
<td class="org-left"><code>let score = scores.get(&amp;team_name);</code></td>
<td class="org-left">获得键值</td>
</tr>

<tr>
<td class="org-left"><code>for (key, value) in &amp;scores {}</code></td>
<td class="org-left">遍历map</td>
</tr>

<tr>
<td class="org-left"><code>scores.entry(String::from("Yellow")).or_insert(50);</code></td>
<td class="org-left">只插入新的,不会覆盖</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org936340f" class="outline-3">
<h3 id="org936340f"><span class="section-number-3">1.4</span> 函数与方法</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgc82c74c" class="outline-4">
<h4 id="orgc82c74c"><span class="section-number-4">1.4.1</span> 函数定义</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>在源文件的任何地方都可以定义函数,不需要在开头声明,函数参数和返回值必须指定类型</li>
<li>不加分号的语句会产生返回值</li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">fn foo(x:i32) -&gt; i32{
    x
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org094f38b" class="outline-4">
<h4 id="org094f38b"><span class="section-number-4">1.4.2</span> 函数调用</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>函数名加括号是一般的调用方法 <code>f()</code></li>
<li>对象方法调用用点 <code>a.f()</code></li>
<li>关联函数(静态方法)调用用两冒号 <code>a::f()</code></li>
<li>指定泛型方法调用用尖括号语法 <code>&lt;type as trait&gt;::f()</code></li>
</ul>
</div>
</div>
<div id="outline-container-org1fa01a5" class="outline-4">
<h4 id="org1fa01a5"><span class="section-number-4">1.4.3</span> 发散函数</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
可以定义无返回值的函数,因为无返回值也可以认为是任何返回值的
</p>
<div class="org-src-container">
<pre class="src src-rust">fn diverges() -&gt; ! {
    panic!("This function never returns!");
}
let x: i32 = diverges();
let x: String = diverges();

</pre>
</div>
</div>
</div>
<div id="outline-container-org5b379f0" class="outline-4">
<h4 id="org5b379f0"><span class="section-number-4">1.4.4</span> 方法</h4>
<div class="outline-text-4" id="text-1-4-4">
</div>
<ol class="org-ol">
<li><a id="org7696db9"></a>定义方法<br />
<div class="outline-text-5" id="text-1-4-4-1">
<p>
方法是结构体的专有函数,先定义结构体再定义方法,方法的第一个参数总是 <code>&amp;self</code> 
</p>
<div class="org-src-container">
<pre class="src src-rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
	self.width * self.height
    }
}

r.area()
</pre>
</div>
</div>
</li>
<li><a id="org9599282"></a>关联函数::<br />
<div class="outline-text-5" id="text-1-4-4-2">
<p>
关联函数是 <code>&amp;self</code> 不作为参数的函数,静态方法
</p>
<div class="org-src-container">
<pre class="src src-rust">impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
	Rectangle { width: size, height: size }
    }
}
io::stdin() //两冒号表示与类型有关的函数,关联函数,静态方法
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgc446135" class="outline-4">
<h4 id="orgc446135"><span class="section-number-4">1.4.5</span> 错误处理类型Result</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
标准库中很多函数的返回值都是 <code>s::Result</code> 类型,可取的成员有 <code>Ok</code> , <code>Err</code> ,方法 <code>expect()</code> 导致程序崩溃并输出字符串
</p>
<div class="org-src-container">
<pre class="src src-rust">io::Result.expect("s")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge9bd4fe" class="outline-3">
<h3 id="orge9bd4fe"><span class="section-number-3">1.5</span> 逻辑</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org4eb62a5" class="outline-4">
<h4 id="org4eb62a5"><span class="section-number-4">1.5.1</span> match:分支匹配</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
对于枚举类型进行匹配,表达式的值与每个分支相匹配,必须穷尽所有可能全都列出来,用 <code>_</code> 表示默认匹配
</p>
<div class="org-src-container">
<pre class="src src-rust">match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
    _ =&gt; None
};
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge6a3356" class="outline-4">
<h4 id="orge6a3356"><span class="section-number-4">1.5.2</span> if let:单支匹配</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
当对枚举进行分支匹配时,只想考虑一种情况,使用这个
</p>
<div class="org-src-container">
<pre class="src src-rust">
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0eb7909" class="outline-4">
<h4 id="org0eb7909"><span class="section-number-4">1.5.3</span> 模式:用于值的匹配</h4>
<div class="outline-text-4" id="text-1-5-3">
</div>
<ol class="org-ol">
<li><a id="orgbe44e49"></a>使用模式的位置<br />
<div class="outline-text-5" id="text-1-5-3-1">
<ul class="org-ul">
<li><code>match</code></li>
<li><code>if let</code></li>
<li><code>while let</code></li>
<li><code>for</code></li>
<li><code>let</code></li>
<li>函数参数</li>
</ul>
<p>
注意所谓的refutable,也就是 <code>let`与`if let</code> 的区别,一个能处理匹配失效,一个不能
</p>
</div>
</li>
<li><a id="org1499bf0"></a>匹配语法<br />
<div class="outline-text-5" id="text-1-5-3-2">
<div class="org-src-container">
<pre class="src src-rust">match x {
    1 =&gt; println!("s")	//直接匹配单个值
	2 | 3 =&gt; println!("s") //竖线是或
	4 ... 10 =&gt; println!("s") //三个点用来匹配范围
	'a' ... 'j' =&gt; println("s") //字符也可以匹配范围
	_ =&gt; println!("s")	//匹配其他值
	Some(_) =&gt; println!("s")//下划线可以忽略部分值
	Some(ref a) =&gt; println!("s")//使用ref匹配引用,防止获得所有权
	Some(n) if n==2 =&gt; println!("s") //使用if进行有条件的匹配
	id @ 3 .. 7 =&gt; println!(id)//使用@绑定匹配值,在匹配后还能用这个值
}

let {x,y} = {x:1, y:2}	//第一种匹配方式
x==1;y==2;
let {x:a, y:b} = {x:1, y:2}//指定名字的匹配方式
a==1;b==2;
let {x:_, y:b} = {x:1, y:2}//下划线忽略值
b==2;
let {x:a, ..} = {x:1, y:2}//两点忽略剩余值
a==1;

</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org1fe95ae" class="outline-4">
<h4 id="org1fe95ae"><span class="section-number-4">1.5.4</span> loop:无限循环</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-rust">loop{

}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbcfeafa" class="outline-4">
<h4 id="orgbcfeafa"><span class="section-number-4">1.5.5</span> break:跳出循环</h4>
</div>

<div id="outline-container-orgafb0a1b" class="outline-4">
<h4 id="orgafb0a1b"><span class="section-number-4">1.5.6</span> continue:到标签循环</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
和goto很像
</p>
<div class="org-src-container">
<pre class="src src-rust">'outer: for x in 0..10 {
    'inner: for y in 0..10 {
	if x % 2 == 0 { continue 'outer; } // Continues the loop over  =x= .
	替换字符串       if y % 2 == 0 { continue 'inner; } // Continues the loop over  =y= .
	println!("x: {}, y: {}", x, y);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org58d7b5e" class="outline-4">
<h4 id="org58d7b5e"><span class="section-number-4">1.5.7</span> if:条件判断</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
在rust中要求必须是bool类型进行判断,不会对表达式进行类型转换
</p>
<div class="org-src-container">
<pre class="src src-rust">if 1==2{
    1
}else if 1&lt;2{
    2
}else {
    3
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0099a82" class="outline-4">
<h4 id="org0099a82"><span class="section-number-4">1.5.8</span> while:条件为真时循环</h4>
<div class="outline-text-4" id="text-1-5-8">
<div class="org-src-container">
<pre class="src src-rust">while c{

}
</pre>
</div>
</div>
</div>
<div id="outline-container-org7fe3f2f" class="outline-4">
<h4 id="org7fe3f2f"><span class="section-number-4">1.5.9</span> for:遍历列表</h4>
<div class="outline-text-4" id="text-1-5-9">
<ul class="org-ul">
<li>惰性列表要展开才能循环 <code>.rev()</code></li>
<li>想同时得到循环序号和内容用 <code>.enumerate()</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">for number in (1..4).rev() {
    println!("{}!", number);
}
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc77a072" class="outline-4">
<h4 id="orgc77a072"><span class="section-number-4">1.5.10</span> 错误处理</h4>
<div class="outline-text-4" id="text-1-5-10">
</div>
<ol class="org-ol">
<li><a id="orgab240f4"></a>panic!:不可恢复错误(bug)<br />
<div class="outline-text-5" id="text-1-5-10-1">
<p>
在项目设置文件中可以设置清理内存的方式,由系统清理内存可以减小编译后的体积
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main() {
    panic!("crash and burn");
}
</pre>
</div>
</div>
</li>
<li><a id="orgc802e5c"></a>Result:可恢复错误<br />
<div class="outline-text-5" id="text-1-5-10-2">
<p>
即理由match枚举进行错误处理
</p>
<div class="org-src-container">
<pre class="src src-rust">
</pre>
</div>
</div>
</li>
<li><a id="org1465a6c"></a>当错误时进行panic!<br />
<div class="outline-text-5" id="text-1-5-10-3">
<div class="org-src-container">
<pre class="src src-rust">
let f = File::open("hello.txt").unwrap();
let f = File::open("hello.txt").expect("Failed to open hello.txt");
</pre>
</div>
</div>
</li>
<li><a id="org35a1711"></a>传播错误:让调用者知道错误是什么<br />
<div class="outline-text-5" id="text-1-5-10-4">
<div class="org-src-container">
<pre class="src src-rust">let mut f = File::open("hello.txt")?;
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgc91e7fa" class="outline-3">
<h3 id="orgc91e7fa"><span class="section-number-3">1.6</span> 所有权(ownership)</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org89ffca1" class="outline-4">
<h4 id="org89ffca1"><span class="section-number-4">1.6.1</span> 所有权概念</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>当变量离开作用域时,自动调用 <code>drop()</code> ,删除变量</li>
<li>重新赋值let a=b时,在堆上的变量不会被拷贝,而栈上的量会新复制一个,对于指针,会进行移动,也就是复制一个指针,再把原来的删了,这样保证只有一个指针能指向内容.</li>
<li>当真的想进行深拷贝时,要显式调用 <code>clone()</code></li>
<li>所有权:当值赋给变量时进行移动,当离开作用域时释放掉</li>
<li>向闭包移动所有权用 <code>move</code> 标记</li>
</ul>
</div>
</div>
<div id="outline-container-org6e19aa5" class="outline-4">
<h4 id="org6e19aa5"><span class="section-number-4">1.6.2</span> 引用(reference)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>当只需要值不需要所有权时传引用 <code>&amp;a</code> ,且可变引用只能有一个,不可变引用可以有很多,可变引用和不可变引用也只能同时有一个</li>
<li>引用相当于先获得所有权,干一些事情,之后再把所有权还回去的过程</li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    42
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf38a6d" class="outline-4">
<h4 id="orgdf38a6d"><span class="section-number-4">1.6.3</span> 生命周期</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
生命周期主要是为了防止空指针和野指针,编译时检查引用变量的生命周期和所在区域的生命周期大小
</p>
</div>
<ol class="org-ol">
<li><a id="orgf6beeb8"></a>生命周期注解<br />
<div class="outline-text-5" id="text-1-6-3-1">
<p>
多个同时出现的生命周期注解,为了提示函数传入值的生命周期关系,当函数返回值与输入值存在生命周期关系时可用
</p>
<div class="org-src-container">
<pre class="src src-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</pre>
</div>
</div>
</li>
<li><a id="orgff43dd7"></a>方法生命周期<br />
<div class="outline-text-5" id="text-1-6-3-2">
<div class="org-src-container">
<pre class="src src-rust">
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {}
</pre>
</div>
</div>
</li>
<li><a id="org55a8700"></a>静态生命周期<br />
<div class="outline-text-5" id="text-1-6-3-3">
<div class="org-src-container">
<pre class="src src-rust">
let s: &amp;'static str = "I have a static lifetime.";
</pre>
</div>
</div>
</li>

<li><a id="org930fb73"></a>生命周期子类型<br />
<div class="outline-text-5" id="text-1-6-3-4">
<p>
也就是限定a的周期比b长的情况 <code>b:a</code> 
</p>
<div class="org-src-container">
<pre class="src src-rust">
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
</pre>
</div>
</div>
</li>
<li><a id="org4465f84"></a>生命周期约束<br />
<div class="outline-text-5" id="text-1-6-3-5">
<p>
也就是规定泛型的生命周期
</p>
<div class="org-src-container">
<pre class="src src-rust">
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org1ff4c0b" class="outline-3">
<h3 id="org1ff4c0b"><span class="section-number-3">1.7</span> 模块</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-orge63773f" class="outline-4">
<h4 id="orge63773f"><span class="section-number-4">1.7.1</span> 定义库项目与模块</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
在cargo中新建的项目默认就是库项目crate,只有声明 <code>--bin</code> 才会创建应用项目
</p>
<div class="org-src-container">
<pre class="src src-rust">//src/lib.rc
pub mod a;

//src/a/mod.rc
pub fn aa(){}
mod b{
    mod c{}
}
mod e;

//src/a/e.rc
fn e(){}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9ad02de" class="outline-4">
<h4 id="org9ad02de"><span class="section-number-4">1.7.2</span> 公有与私有</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
只有声明公有才能被外部调用,而且函数及其父模块都要是公有的才行
</p>
</div>
</div>

<div id="outline-container-org55d1fdf" class="outline-4">
<h4 id="org55d1fdf"><span class="section-number-4">1.7.3</span> 引入到作用域</h4>
<div class="outline-text-4" id="text-1-7-3">
<ul class="org-ul">
<li>使用 <code>use`,类似python的`from .. import ..</code> ;</li>
<li>可以引入所有函数 <code>use a::*</code></li>
<li>在模块中可以引入上一级的模块 <code>use supper::a</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">pub mod a {
    pub mod series {
	use supper::series;
	pub mod of {
	    pub fn nested_modules() {}
	    pub fn s(){}
	}
    }
}
enum b{e,c}
use a::series::of::nested_modules;
use e::* 
use a::series::of::{nested_modules,s};

fn main() {
    nested_modules();	
    e;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org16c78e1" class="outline-3">
<h3 id="org16c78e1"><span class="section-number-3">1.8</span> 泛型</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org635ee0d" class="outline-4">
<h4 id="org635ee0d"><span class="section-number-4">1.8.1</span> 定义与使用泛型</h4>
<div class="outline-text-4" id="text-1-8-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {}</code></td>
<td class="org-left">定义泛型函数</td>
</tr>

<tr>
<td class="org-left"><code>struct Point&lt;T&gt; {}</code></td>
<td class="org-left">定义泛型结构体</td>
</tr>

<tr>
<td class="org-left"><code>enum Result&lt;T, E&gt; {}</code></td>
<td class="org-left">定义泛型枚举</td>
</tr>

<tr>
<td class="org-left"><code>impl&lt;T&gt; Point&lt;T&gt; {}</code></td>
<td class="org-left">定义泛型方法</td>
</tr>

<tr>
<td class="org-left"><code>impl Point&lt;f32&gt; {}</code></td>
<td class="org-left">为某种类型专门定义方法</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-rust">use std::fmt::Debug;
#[derive(Debug)]
pub struct A&lt;T&gt;{
    pub s:T,
}
/// 对特定类型实现泛型函数
impl A&lt;String&gt; {
    pub fn new(s:String) -&gt; A&lt;String&gt;{
	A::&lt;String&gt;{//注意这里的两冒号
	    s,
	}
    }
}
/// 定义泛型trait
trait B&lt;T,U&gt; {
    /// 默认实现
    fn b(&amp;self,t:T,k:U) 
    where T:Debug,U:Debug{
	println!("{:?},{:?}",t,k)
    }
    /// 无实现,只声明
    fn c(T,U) where T:Debug,U:Debug;
}
/// 对特定类型实现trait
impl&lt;T,U&gt; B&lt;T,U&gt; for A&lt;T&gt;{
    fn c(t:T,d:U)where T:Debug,U:Debug{
	println!("{:?},{:?}",d,t);
    }
}

let a = A::new("S".to_string());
println!("{:?}", a);
a.b("s".to_string(),"d");
A::c("S".to_string(),"d")
</pre>
</div>
</div>
</div>

<div id="outline-container-org79b864f" class="outline-4">
<h4 id="org79b864f"><span class="section-number-4">1.8.2</span> trait:不同类型的共同方法实现接口</h4>
<div class="outline-text-4" id="text-1-8-2">
</div>
<ol class="org-ol">
<li><a id="org5401e15"></a>声明trait<br />
<div class="outline-text-5" id="text-1-8-2-1">
<div class="org-src-container">
<pre class="src src-rust">pub trait Summarizable : Foo { //继承另一个方法
    fn summary(&amp;self) -&gt; String;	//无默认实现的方法
    fn a(&amp;self) -&gt; str{...}	//有默认实现的方法
}
</pre>
</div>
</div>
</li>
<li><a id="orgab3a638"></a>实现trait<br />
<div class="outline-text-5" id="text-1-8-2-2">
<div class="org-src-container">
<pre class="src src-rust">impl Summarizable for NewsArticle {}//采用默认实现
impl Summarizable for Tweet {...}//不采用默认实现
</pre>
</div>
</div>
</li>
<li><a id="orgee3ecf3"></a>应用trait<br />
<div class="outline-text-5" id="text-1-8-2-3">
<p>
定义必须实现了某些方法的类型的泛型函数
</p>
<div class="org-src-container">
<pre class="src src-rust">// 第一种指定trait的方法
fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {}

// 用where语法指定trait
fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
where T: Display + Clone,
      U: Clone + Debug
{}

</pre>
</div>
</div>
</li>

<li><a id="orgf75b0a3"></a>trait继承<br />
<div class="outline-text-5" id="text-1-8-2-4">
<div class="org-src-container">
<pre class="src src-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
	let output = self.to_string();
	let len = output.len();
	println!("{}", "*".repeat(len + 4));
	println!("*{}*", " ".repeat(len + 2));
	println!("* {} *", output);
	println!("*{}*", " ".repeat(len + 2));
	println!("{}", "*".repeat(len + 4));
    }
}
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org83a47c5" class="outline-4">
<h4 id="org83a47c5"><span class="section-number-4">1.8.3</span> 关联类型</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
和泛型差不多,但某些时候写起来更清晰
</p>
<div class="org-src-container">
<pre class="src src-rust">
trait GGraph&lt;Node, Edge&gt; {
    // methods would go here
}
fn distance&lt;N, E, G: GGraph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {
}
trait AGraph {
    type Node;
    type Edge;

    // methods would go here
}
fn distance&lt;G: AGraph&gt;(graph: &amp;G, start: &amp;G::Node, end: &amp;G::Node) -&gt; u32 {
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3cda352" class="outline-4">
<h4 id="org3cda352"><span class="section-number-4">1.8.4</span> 运算符重载</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
只要是 <code>std::ops</code> 里的都可以重载
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
	Point {
	    x: self.x + other.x,
	    y: self.y + other.y,
	}
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
	       Point { x: 3, y: 3 });
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4fe25a" class="outline-2">
<h2 id="orgc4fe25a"><span class="section-number-2">2</span> 进阶知识</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgd2da5b6" class="outline-3">
<h3 id="orgd2da5b6"><span class="section-number-3">2.1</span> 测试</h3>
<div class="outline-text-3" id="text-2-1">
<p>
测试函数:
</p>
<div class="org-src-container">
<pre class="src src-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
	assert_eq!(2 + 2, 4);
    }
}
</pre>
</div>
<p>
使用测试函数注解 <code>#[test]</code> 声明一个测试,这些注解目前只是由编译器自己规定的,不能自定义
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>cargo test</code></td>
<td class="org-left">运行测试</td>
</tr>

<tr>
<td class="org-left"><code>assert_eq!(a,b)</code></td>
<td class="org-left">测试a==b</td>
</tr>

<tr>
<td class="org-left"><code>assert!(a)</code></td>
<td class="org-left">测试a==true</td>
</tr>

<tr>
<td class="org-left">=assert<sub>ne</sub>!(a,b)`</td>
<td class="org-left">测试`a!=b=</td>
</tr>

<tr>
<td class="org-left"><code>#[should_panic]</code></td>
<td class="org-left">测试是否成功产生了panic错误处理</td>
</tr>

<tr>
<td class="org-left"><code>#[ignore]</code></td>
<td class="org-left">忽略这个测试</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org6d8c102" class="outline-3">
<h3 id="org6d8c102"><span class="section-number-3">2.2</span> 函数式</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org22ea688" class="outline-4">
<h4 id="org22ea688"><span class="section-number-4">2.2.1</span> 闭包:匿名函数</h4>
<div class="outline-text-4" id="text-2-2-1">
</div>
<ol class="org-ol">
<li><a id="orgd8e5030"></a>基本语法<br />
<div class="outline-text-5" id="text-2-2-1-1">
<p>
把括号变成竖线即可,注意类型自动推断导致第一次调用时的类型就是全部的类型,单行可以不写大括号
</p>
<div class="org-src-container">
<pre class="src src-rust">let expensive_closure = |num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
let f = |x:i32|-&gt;i32 {x};
f(2)
</pre>
</div>
</div>
</li>
<li><a id="org8ac4ed5"></a>闭包的泛型trait<br />
<div class="outline-text-5" id="text-2-2-1-2">
<p>
闭包泛型为 <code>Fn`,`FnMut`,`FnOnce</code> 中的一个
利用结构体保存计算结果,结构体方法作匿名函数,实现惰性求值
先定义泛型结构体,再写泛型结构体的静态方法,把匿名函数(闭包)作为方法的参数
</p>
<div class="org-src-container">
<pre class="src src-rust">struct Cacher&lt;T&gt;
where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}

impl&lt;T&gt; Cacher&lt;T&gt;
where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
	Cacher {
	    calculation,
	    value: None,
	}
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
	match self.value {
	    Some(v) =&gt; v,
	    None =&gt; {
		let v = (self.calculation)(arg);
		self.value = Some(v);
		v
	    },
	}
    }
}
let mut expensive_result = Cacher::new(|num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
});
</pre>
</div>
</div>
</li>

<li><a id="org506cdac"></a>move:闭包获得所有权<br />
<div class="outline-text-5" id="text-2-2-1-3">
<p>
使用 <code>move</code> 关键字,让闭包强制获得所有权,用来实现迭代器
</p>
<div class="org-src-container">
<pre class="src src-rust">let equal_to_x = move |z| z == x;
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org1c2d982" class="outline-3">
<h3 id="org1c2d982"><span class="section-number-3">2.3</span> 迭代器</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-orgbc338cb" class="outline-4">
<h4 id="orgbc338cb"><span class="section-number-4">2.3.1</span> 使用迭代器</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
迭代器是零成本抽象之一,因而其速度很快
</p>

<p>
迭代器是惰性求值的,当调用创建函数创建迭代器时,并没有进行运算,只有当对迭代器调用消费函数时才会运行求值
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>.iter()</code></td>
<td class="org-left">创建迭代器,每项是不可变引用</td>
</tr>

<tr>
<td class="org-left"><code>.into_iter()</code></td>
<td class="org-left">创建迭代器,每项有所有权</td>
</tr>

<tr>
<td class="org-left"><code>.iter_mut()</code></td>
<td class="org-left">创建迭代器,可变引用</td>
</tr>

<tr>
<td class="org-left">=.next()`</td>
<td class="org-left">返回迭代器中的一个项,结束时返回`None=</td>
</tr>

<tr>
<td class="org-left"><code>.sum()</code></td>
<td class="org-left">获取所有项的总和</td>
</tr>

<tr>
<td class="org-left"><code>.map(Fn)</code></td>
<td class="org-left">迭代器适配器,对每个项运行函数,把结果形成新的迭代器</td>
</tr>

<tr>
<td class="org-left"><code>.collect()</code></td>
<td class="org-left">将迭代器的内容收集到数据结构中</td>
</tr>

<tr>
<td class="org-left">=.filter(Fn-&gt;bool)`</td>
<td class="org-left">迭代器适配器,对每项运行函数,返回`true= 的项将进入到结果迭代器中</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org07efece" class="outline-4">
<h4 id="org07efece"><span class="section-number-4">2.3.2</span> 自定义迭代器</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
只需要对结构体定义 <code>Iterator`trait的方法`next`即可,由于标准迭代器方法都用了`.next()</code> 方法,所以可以使用所有的迭代器方法
</p>
<div class="org-src-container">
<pre class="src src-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
	Counter { count: 0 }
    }
}
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
	self.count += 1;

	if self.count &lt; 6 {
	    Some(self.count)
	} else {
	    None
	}
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc040e6d" class="outline-3">
<h3 id="orgc040e6d"><span class="section-number-3">2.4</span> 智能指针</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org08f05ba" class="outline-4">
<h4 id="org08f05ba"><span class="section-number-4">2.4.1</span> Box&lt;T&gt;:堆上存储数据</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
由于Rust编译要求知道栈上空间大小,所以对于未知大小的数据可用,此时栈上的是指向堆上数据的指针
</p>
<div class="org-src-container">
<pre class="src src-rust">Box::new(1)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd4ac984" class="outline-4">
<h4 id="orgd4ac984"><span class="section-number-4">2.4.2</span> 自定义智能指针</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
当希望手动提前释放内存时可用 <code>std::mem::drop</code> 
</p>
<div class="org-src-container">
<pre class="src src-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
	MyBox(x)
    }
}
use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
	&amp;self.0
    }
}
impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
	println!("Dropping CustomSmartPointer with data  ={}= !", self.data);
    }
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org312d68c" class="outline-4">
<h4 id="org312d68c"><span class="section-number-4">2.4.3</span> Rc&lt;T&gt;:单线程引用计数指针</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
通过不可变的引用计数指针来在多个部分间共享内存数据
<code>new()`新建指针,`clone()</code> 增加计数,在作用域离开时自动删除计数
</p>
<div class="org-src-container">
<pre class="src src-rust">let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
let b = Cons(3, Rc::clone(&amp;a));
</pre>
</div>
</div>
</div>
<div id="outline-container-orgac9f525" class="outline-4">
<h4 id="orgac9f525"><span class="section-number-4">2.4.4</span> RefCell&lt;T&gt;:内部可变模式</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
只有内部方法可以改变值,对于外部函数仍是不可变的,组合 <code>Rc&lt;T&gt;`和`RefCell&lt;T&gt;</code> 可以得到多个所有者的可变数据结构
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::cell::RefCell;

struct MockMessenger {
    sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
}

impl MockMessenger {
    fn new() -&gt; MockMessenger {
	MockMessenger { sent_messages: RefCell::new(vec![]) }
    }
}

impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
	self.sent_messages.borrow_mut().push(String::from(message));
    }
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org65a1eb1" class="outline-4">
<h4 id="org65a1eb1"><span class="section-number-4">2.4.5</span> Weak&lt;T&gt;:弱引用计数指针</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
强引用计数有可能造成引用循环导致计数不为0的内存泄露,组合使用弱计数和强计数来避免引用循环
</p>
<div class="org-src-container">
<pre class="src src-rust">struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb78ebe1" class="outline-3">
<h3 id="orgb78ebe1"><span class="section-number-3">2.5</span> 并发与并行</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org2d1d0d8" class="outline-4">
<h4 id="org2d1d0d8"><span class="section-number-4">2.5.1</span> 线程</h4>
<div class="outline-text-4" id="text-2-5-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>std::thread</code></td>
<td class="org-left">标准库线程</td>
</tr>

<tr>
<td class="org-left"><code>thread::spawn(Fn)</code></td>
<td class="org-left">创建线程,传递一个闭包作为线程执行函数</td>
</tr>

<tr>
<td class="org-left"><code>thread::sleep(time::Duration)</code></td>
<td class="org-left">线程睡眠,参数为标准库time</td>
</tr>

<tr>
<td class="org-left"><code>thread.join().unwrap()</code></td>
<td class="org-left">在主线程中,将主线程阻塞直到所有子线程完成</td>
</tr>
</tbody>
</table>

<p>
在传递线程闭包时使用 <code>move</code> 关键字,能够将所有权给子线程,保证主线程不会再次释放同一个变量
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
	println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org34e6d7e" class="outline-4">
<h4 id="org34e6d7e"><span class="section-number-4">2.5.2</span> 线程通信</h4>
<div class="outline-text-4" id="text-2-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>std::sync::mpse</code></td>
<td class="org-left">多个生产者,一个消费者,多发送一接收</td>
</tr>

<tr>
<td class="org-left"><code>let (tx,rx)=mpsc::channel()</code></td>
<td class="org-left">新建通信通道</td>
</tr>

<tr>
<td class="org-left"><code>tx</code></td>
<td class="org-left">发送者</td>
</tr>

<tr>
<td class="org-left"><code>rx</code></td>
<td class="org-left">接收者</td>
</tr>

<tr>
<td class="org-left"><code>tx.send(val).unwrap()</code></td>
<td class="org-left">发送,发送后线程内失去所有权</td>
</tr>

<tr>
<td class="org-left"><code>rx.recv().unwrap()</code></td>
<td class="org-left">接收,阻塞直到收到内容</td>
</tr>

<tr>
<td class="org-left">=rx.try<sub>recv</sub>().unwrap()`</td>
<td class="org-left">立即接收,返回 <code>Result</code></td>
</tr>

<tr>
<td class="org-left"><code>tx1=mpsc::Sender::clone(&amp;tx)</code></td>
<td class="org-left">通过克隆来得到多个发送者</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-rust">

use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
	let val = String::from("hi");
	tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org7539572" class="outline-4">
<h4 id="org7539572"><span class="section-number-4">2.5.3</span> 共享状态</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
多个线程共享内存都拥有所有权,在访问数据时线程先获取锁操作之后再解锁
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>std::sync::Mutex</code></td>
<td class="org-left">标准库的互斥器</td>
</tr>

<tr>
<td class="org-left"><code>Mutex::new(T)</code></td>
<td class="org-left">新建一个互斥器</td>
</tr>

<tr>
<td class="org-left"><code>m.lock()</code></td>
<td class="org-left">获取锁</td>
</tr>

<tr>
<td class="org-left">=std::sync::Arc`</td>
<td class="org-left">原子引用计数,类似`Rc&lt;T&gt;=</td>
</tr>

<tr>
<td class="org-left"><code>Arc::clone()</code></td>
<td class="org-left">得到新的互斥器指针</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf5971b2" class="outline-4">
<h4 id="orgf5971b2"><span class="section-number-4">2.5.4</span> Rust语言内的并发trait</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
<code>Send</code> :表明类型的所有权可以在线程间进行传递
<code>Sync</code> :表明可以安全的在多线程中获得值的引用
</p>
</div>
</div>
</div>

<div id="outline-container-org9f05223" class="outline-3">
<h3 id="org9f05223"><span class="section-number-3">2.6</span> 面向对象</h3>
<div class="outline-text-3" id="text-2-6">
<p>
结构体类型-&gt;类
结构体方法-&gt;类方法
trait接口的类型继承-&gt;继承和多态
就是函数式里实现面向对象的技术,和Clojure差不多
</p>
</div>
</div>

<div id="outline-container-orga18fb10" class="outline-3">
<h3 id="orga18fb10"><span class="section-number-3">2.7</span> 属性</h3>
<div class="outline-text-3" id="text-2-7">
<p>
所有的属性都是编译器内建实现的,不能自己添加属性
</p>
</div>
<div id="outline-container-orgcf90ffe" class="outline-4">
<h4 id="orgcf90ffe"><span class="section-number-4">2.7.1</span> derive:自动实现一些泛型方法</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
目前只适用于: <code>Clone`,`Copy`,`Debug`,`Default`,`Eq`,`Hash`,`Ord`,`PartialEq`,`PartialOrd</code> 
</p>
<div class="org-src-container">
<pre class="src src-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!("{:?}", Foo);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd690ff" class="outline-4">
<h4 id="orgdd690ff"><span class="section-number-4">2.7.2</span> 过程宏</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
过程宏用来给 <code>struct`添加现成的`trait</code> 方法,他的行为是宏,但语法和属性相似
</p>
</div>
<ol class="org-ol">
<li><a id="org588fbd7"></a>创建过程宏<br />
<div class="outline-text-5" id="text-2-7-2-1">
<ul class="org-ul">
<li><code>proc_macro`:过程宏提取和创建,目前只有`proc_macro::TokenStream</code> ,用来把代码变成字符串,内置无依赖</li>
<li><code>syn`:rust语法解析器,需依赖`syn = "0.10.5"</code> ,具体用法参见文档</li>
<li><code>quote`:rust代码生成器,需依赖`quote = "0.3.10"`,`quote!</code> 可以像普通宏一样写代码,参加文档</li>
<li>编写过程为:代码生成字符串-&gt;字符串解析语法树-&gt;对语法树进行处理实现目标功能-&gt;将语法树还原成代码字符串</li>
<li>过程宏要在一个单独的lib里引入,在 <code>cargo`里写上`[lib] proc-macro = true</code> ,才能通过编译</li>
<li>在编写过程宏时,加入参数声明就可以进行自定义 <code>#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-rust">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloWorld)]
pub fn hello_world(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_world(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}

fn impl_hello_world(ast: &amp;syn::MacroInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
	impl HelloWorld for #name {
	    fn hello_world() {
		println!("Hello, World! My name is {}", stringify!(#name));
	    }
	}
    }
}

</pre>
</div>
</div>
</li>

<li><a id="orgd2b5c61"></a>使用过程宏<br />
<div class="outline-text-5" id="text-2-7-2-2">
<p>
从lib中引入宏并定义好trait接口,具体实现交给宏完成
</p>
<div class="org-src-container">
<pre class="src src-rust">#[macro_use]
extern crate hello_world_derive;

trait HelloWorld {
    fn hello_world();
}

#[derive(HelloWorld)]
struct FrenchToast;

#[derive(HelloWorld)]
struct Waffles;

fn main() {
    FrenchToast::hello_world();
    Waffles::hello_world();
}

</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org8eae378" class="outline-3">
<h3 id="org8eae378"><span class="section-number-3">2.8</span> 宏</h3>
<div class="outline-text-3" id="text-2-8">
</div>
<div id="outline-container-org6aed1b7" class="outline-4">
<h4 id="org6aed1b7"><span class="section-number-4">2.8.1</span> 语法</h4>
<div class="outline-text-4" id="text-2-8-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">=macro<sub>rules</sub>! m { (&#x2026;.)=&gt;{&#x2026;.}; }`</td>
<td class="org-left">定义宏,匹配箭头后面可以是`(),{},[]= ,每个分支都以分号结束</td>
</tr>

<tr>
<td class="org-left"><code>$(e1,e2,..)</code></td>
<td class="org-left">匹配任何表达式模板都可以</td>
</tr>

<tr>
<td class="org-left">=$x:expr`</td>
<td class="org-left">匹配任意表达式并绑定在`x= 上,指定匹配的内容</td>
</tr>

<tr>
<td class="org-left"><code>$x</code></td>
<td class="org-left">在宏里引用绑定的表达式</td>
</tr>

<tr>
<td class="org-left"><code>$(),+</code></td>
<td class="org-left">表示上一个匹配部分重复出现一次或多次,且这些部分以逗号隔开</td>
</tr>

<tr>
<td class="org-left"><code>$(),*</code></td>
<td class="org-left">表示上一个匹配部分重复出现零次或多次,且这些部分以逗号隔开</td>
</tr>

<tr>
<td class="org-left"><code>$()*</code></td>
<td class="org-left">表示这个表达式重复零次或多次,且这些表达式直接相邻,表达式里可以有换行</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-rust">macro_rules! o_O {
    (
	$(
	    $x:expr; [ $( $y:expr ),* ]
	);*
    ) =&gt; {
	&amp;[ $($( $x + $y ),*),* ]
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e71ed9" class="outline-4">
<h4 id="org3e71ed9"><span class="section-number-4">2.8.2</span> 指示符</h4>
<div class="outline-text-4" id="text-2-8-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">ident</td>
<td class="org-left">一个标识符。</td>
<td class="org-left">x，foo</td>
</tr>

<tr>
<td class="org-left">path</td>
<td class="org-left">一个受限的名字。</td>
<td class="org-left">T::SpecialA</td>
</tr>

<tr>
<td class="org-left">expr</td>
<td class="org-left">一个表达式。</td>
<td class="org-left">2 + 2；if true then { 1 } else { 2 }；f(42)</td>
</tr>

<tr>
<td class="org-left">ty</td>
<td class="org-left">一个类型。</td>
<td class="org-left">i32；Vec&lt;(char, String)&gt;；&amp;T</td>
</tr>

<tr>
<td class="org-left">pat</td>
<td class="org-left">一个模式。</td>
<td class="org-left">Some(t)；(17, 'a')；_</td>
</tr>

<tr>
<td class="org-left">stmt</td>
<td class="org-left">一个单独语句。</td>
<td class="org-left">let x = 3</td>
</tr>

<tr>
<td class="org-left">block</td>
<td class="org-left">一个大括号界定的语句序列，或者一个表达式。</td>
<td class="org-left">{ log(error, "hi"); return 12; }</td>
</tr>

<tr>
<td class="org-left">item</td>
<td class="org-left">一个项。</td>
<td class="org-left">fn foo() { }，struct Bar</td>
</tr>

<tr>
<td class="org-left">meta</td>
<td class="org-left">一个“元数据项”，可以在属性中找到。</td>
<td class="org-left">cfg(target<sub>os</sub> = "windows")</td>
</tr>

<tr>
<td class="org-left">tt</td>
<td class="org-left">一个单独的记号树</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org4ef7011" class="outline-3">
<h3 id="org4ef7011"><span class="section-number-3">2.9</span> 不安全的Rust</h3>
<div class="outline-text-3" id="text-2-9">
</div>
<div id="outline-container-orgcb1018d" class="outline-4">
<h4 id="orgcb1018d"><span class="section-number-4">2.9.1</span> 裸指针</h4>
<div class="outline-text-4" id="text-2-9-1">
<ul class="org-ul">
<li><code>*const`和`*mut</code> 是裸指针,创建裸指针是安全的,但解引用裸指针不安全</li>
<li>裸指针没有生命周期和所有权</li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga94e274" class="outline-4">
<h4 id="orga94e274"><span class="section-number-4">2.9.2</span> unsafe</h4>
<div class="outline-text-4" id="text-2-9-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>unsafe fn a{}</code></td>
<td class="org-left">声明不安全函数</td>
</tr>

<tr>
<td class="org-left"><code>unsafe{}</code></td>
<td class="org-left">声明不安全块</td>
</tr>

<tr>
<td class="org-left"><code>unsafe trait A{}</code></td>
<td class="org-left">声明不安全接口</td>
</tr>

<tr>
<td class="org-left"><code>unsafe impl B for A{}</code></td>
<td class="org-left">声明不安全方法</td>
</tr>
</tbody>
</table>
<p>
在不安全块中只能够做三件事
</p>
</div>
</div>

<div id="outline-container-org2bf0b2a" class="outline-4">
<h4 id="org2bf0b2a"><span class="section-number-4">2.9.3</span> 创建安全抽象</h4>
<div class="outline-text-4" id="text-2-9-3">
<p>
只要一个函数的输入输出都是rust的,只在内部用了unsafe,也是安全的
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
	(slice::from_raw_parts_mut(ptr, mid),
	 slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org43eebe2" class="outline-4">
<h4 id="org43eebe2"><span class="section-number-4">2.9.4</span> ffi:与C交互</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
c类型很多在 <code>libc`里定义:`extern crate libc;</code> 
</p>
</div>
<ol class="org-ol">
<li><a id="org4cdb024"></a>调用外部函数<br />
<div class="outline-text-5" id="text-2-9-4-1">
<ul class="org-ul">
<li><code>#[link(name</code>"libname",kind="")]= :指定引入的c库及类型,动态(不写kind),静态(static),osx动态(framework)</li>
<li>目前支持的ABI有: <code>stdcall`,`aapcs`,`cdecl`,`fastcall`,`Rust`,`rust-intrinsic`,`system`,`C`,`win64`,`sysv64</code></li>
<li>可变参数用 <code>...</code> 表示,但在普通的rust里不支持这样</li>
<li>对于空指针用 <code>None`代替,即`Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;`相当于 C 类型`int (*)(int)</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-rust"># #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = "snappy")]
extern "C" {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn foo(x: i32, ...);
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}
</pre>
</div>
</div>
</li>
<li><a id="org77da71e"></a>导出接口到C<br />
<div class="outline-text-5" id="text-2-9-4-2">
<ul class="org-ul">
<li><code>#[no_mangle]</code> :保留函数名</li>
<li>如果有可能发生 <code>panic!`,要在`catch_unwind(|| {})</code> 闭包中执行</li>
</ul>
<div class="org-src-container">
<pre class="src src-rust">#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org56caee6" class="outline-3">
<h3 id="org56caee6"><span class="section-number-3">2.10</span> 高级函数</h3>
<div class="outline-text-3" id="text-2-10">
</div>
<div id="outline-container-orgaacb148" class="outline-4">
<h4 id="orgaacb148"><span class="section-number-4">2.10.1</span> fn(T):函数指针</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
函数的参数是函数:
</p>
<div class="org-src-container">
<pre class="src src-rust">fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4eed3d" class="outline-4">
<h4 id="orgc4eed3d"><span class="section-number-4">2.10.2</span> 返回闭包</h4>
<div class="outline-text-4" id="text-2-10-2">
<p>
函数的返回值还是函数,必须用 <code>Box&lt;T&gt;</code> 把它放在堆上
</p>
<div class="org-src-container">
<pre class="src src-rust">fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf78bb42" class="outline-2">
<h2 id="orgf78bb42"><span class="section-number-2">3</span> Cargo</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org71751c2" class="outline-3">
<h3 id="org71751c2"><span class="section-number-3">3.1</span> 基本命令</h3>
<div class="outline-text-3" id="text-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">命令</td>
<td class="org-left">作用</td>
</tr>

<tr>
<td class="org-left"><code>cargo new hello --bin</code></td>
<td class="org-left">创建新项目同时创建了 <code>cargo.toml</code> 和 <code>git</code> 仓库</td>
</tr>

<tr>
<td class="org-left"><code>cargo build</code></td>
<td class="org-left">编译项目</td>
</tr>

<tr>
<td class="org-left"><code>cargo run</code></td>
<td class="org-left">编译并运行项目</td>
</tr>

<tr>
<td class="org-left"><code>cargo build --release</code></td>
<td class="org-left">优化编译</td>
</tr>

<tr>
<td class="org-left"><code>cargo test</code></td>
<td class="org-left">运行测试</td>
</tr>

<tr>
<td class="org-left"><code>cargo doc --open</code></td>
<td class="org-left">自动生成文档网页</td>
</tr>

<tr>
<td class="org-left"><code>cargo install</code></td>
<td class="org-left">安装包或者扩展</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org9c228d3" class="outline-3">
<h3 id="org9c228d3"><span class="section-number-3">3.2</span> 配置文件</h3>
<div class="outline-text-3" id="text-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">name</td>
<td class="org-left">项目名</td>
</tr>

<tr>
<td class="org-left">version</td>
<td class="org-left">版本号</td>
</tr>

<tr>
<td class="org-left">authors</td>
<td class="org-left">作者信息</td>
</tr>

<tr>
<td class="org-left">dependencies</td>
<td class="org-left">依赖库,版本号表示&gt;=指定小版本</td>
</tr>

<tr>
<td class="org-left">opt-level</td>
<td class="org-left">优化级别,不优化为0,最大优化为3</td>
</tr>

<tr>
<td class="org-left">workspace</td>
<td class="org-left">工作空间</td>
</tr>

<tr>
<td class="org-left">member</td>
<td class="org-left">子项目</td>
</tr>
</tbody>
</table>

<p>
配置文件 <code>Cargo.toml</code> 写法:
</p>
<div class="org-src-container">
<pre class="src src-toml">[package]
name = "gb"
version = "0.1.0"
authors = ["chimez &lt;chimez@163.com&gt;"]

[dependencies]
rand = "0.3.14"
adder = { path = "../add-one" }	//子项目依赖

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3

[workspace]
members = [
    "adder",
]
</pre>
</div>
<p>
目录结构
</p>
<pre class="example">
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target

</pre>
</div>
</div>

<div id="outline-container-orgdad3e5a" class="outline-3">
<h3 id="orgdad3e5a"><span class="section-number-3">3.3</span> 项目注释和文档自动生成</h3>
<div class="outline-text-3" id="text-3-3">
<pre class="example">
//! 整个文件的注释,markdown
/// 下面的函数的注释,markdown
// 普通的代码注释,不会被生成网页
</pre>

<p>
工作空间
在一个项目里可以创建多个子项目
</p>
</div>
</div>

<div id="outline-container-orgf2bae4f" class="outline-3">
<h3 id="orgf2bae4f"><span class="section-number-3">3.4</span> 发布</h3>
</div>
</div>
<div id="outline-container-org59aee1c" class="outline-2">
<h2 id="org59aee1c"><span class="section-number-2">4</span> Rust 语法速查</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge218910" class="outline-3">
<h3 id="orge218910"><span class="section-number-3">4.1</span> link</h3>
<div class="outline-text-3" id="text-4-1">
</div>
</div>
<div id="outline-container-org2b19377" class="outline-3">
<h3 id="org2b19377"><span class="section-number-3">4.2</span> 控制结构</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgc4a728e" class="outline-4">
<h4 id="orgc4a728e"><span class="section-number-4">4.2.1</span> 基本程序</h4>
<div class="outline-text-4" id="text-4-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">变量声明</td>
<td class="org-left"><code>let</code>, <code>let mut</code>, <code>const</code>, <code>static</code>, <code>static mut</code></td>
</tr>

<tr>
<td class="org-left">注释</td>
<td class="org-left"><code>//</code>, <code>///</code>, <code>//!</code>, <code>/*...*/</code>, <code>/*!...*/</code>, <code>/**...*/</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orged93d3d" class="outline-4">
<h4 id="orged93d3d"><span class="section-number-4">4.2.2</span> 函数</h4>
<div class="outline-text-4" id="text-4-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义函数</td>
<td class="org-left"><code>fn f(x:i8)-&gt;i8{}</code></td>
</tr>

<tr>
<td class="org-left">入口函数</td>
<td class="org-left"><code>main</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgfb379a4" class="outline-4">
<h4 id="orgfb379a4"><span class="section-number-4">4.2.3</span> 控制结构</h4>
<div class="outline-text-4" id="text-4-2-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">条件判断</td>
<td class="org-left"><code>if-else if-else</code>, <code>match</code>, <code>if let-else</code></td>
</tr>

<tr>
<td class="org-left">循环</td>
<td class="org-left"><code>loop</code>, <code>while</code>, <code>for-in</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org077b5c7" class="outline-4">
<h4 id="org077b5c7"><span class="section-number-4">4.2.4</span> 模式匹配</h4>
<div class="outline-text-4" id="text-4-2-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">可以用的地方</td>
<td class="org-left"><code>match</code>, <code>if let</code>, <code>while let</code>, <code>for</code>, <code>let</code>, 函数参数</td>
</tr>

<tr>
<td class="org-left">可以匹配的东西</td>
<td class="org-left"><code>1</code>, <code>Some(x)</code>, <code>1 ¦ 2</code>, <code>1 ... 5</code>, <code>_</code>, <code>_x</code>, <code>..</code>, <code>..=</code>, <code>ref</code>, <code>ref mut</code>, <code>Some(x) if x &lt; 5</code>, <code>id: id_variable @ 3...7</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2699d79" class="outline-4">
<h4 id="org2699d79"><span class="section-number-4">4.2.5</span> 所有权</h4>
<div class="outline-text-4" id="text-4-2-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">作用域与所有权</td>
<td class="org-left"><code>{}</code></td>
</tr>

<tr>
<td class="org-left">引用与借用</td>
<td class="org-left"><code>&amp;</code>, <code>&amp;mut</code>, <code>*</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org1bb9159" class="outline-3">
<h3 id="org1bb9159"><span class="section-number-3">4.3</span> 数据类型</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org18aae7c" class="outline-4">
<h4 id="org18aae7c"><span class="section-number-4">4.3.1</span> 标量类型</h4>
<div class="outline-text-4" id="text-4-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">有符号整型</td>
<td class="org-left"><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td>
</tr>

<tr>
<td class="org-left">无符号整型</td>
<td class="org-left"><code>u8</code>,  <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td>
</tr>

<tr>
<td class="org-left">整型字面值</td>
<td class="org-left"><code>98_222</code>, <code>0xff</code>, <code>0o77</code>, <code>0b1111_0000</code>, <code>b'A'</code></td>
</tr>

<tr>
<td class="org-left">浮点型</td>
<td class="org-left"><code>f32</code>, <code>f64</code></td>
</tr>

<tr>
<td class="org-left">数字运算符</td>
<td class="org-left"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>+=</code></td>
</tr>

<tr>
<td class="org-left">布尔类型</td>
<td class="org-left"><code>bool</code>, <code>true</code>, <code>false</code></td>
</tr>

<tr>
<td class="org-left">字符类型</td>
<td class="org-left"><code>char</code>, <code>'z'</code>, <code>&amp;str</code>, <code>"slice"</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org359d918" class="outline-4">
<h4 id="org359d918"><span class="section-number-4">4.3.2</span> 复合类型</h4>
<div class="outline-text-4" id="text-4-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">元组</td>
<td class="org-left"><code>(i32, f64, u8)</code></td>
</tr>

<tr>
<td class="org-left">数组</td>
<td class="org-left"><code>[1, 2]</code></td>
</tr>

<tr>
<td class="org-left">数组方法</td>
<td class="org-left"><code>iter</code>, <code>enumerate</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd6595e1" class="outline-4">
<h4 id="orgd6595e1"><span class="section-number-4">4.3.3</span> 字符串 <code>std::string</code></h4>
<div class="outline-text-4" id="text-4-3-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">创建</td>
<td class="org-left"><code>String::from</code>, <code>new</code>, <code>clone</code>, <code>format!</code>, <code>"".to_string()</code></td>
</tr>

<tr>
<td class="org-left">修改</td>
<td class="org-left"><code>push_str</code>, <code>push</code>, <code>+</code>, <code>clear</code></td>
</tr>

<tr>
<td class="org-left">转换</td>
<td class="org-left"><code>as_bytes</code>, <code>chars</code>, <code>bytes</code></td>
</tr>

<tr>
<td class="org-left">获取信息</td>
<td class="org-left"><code>len</code></td>
</tr>

<tr>
<td class="org-left">slice</td>
<td class="org-left"><code>&amp;str</code>, <code>"slice"</code>, <code>&amp;s[0..2]</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc916484" class="outline-4">
<h4 id="orgc916484"><span class="section-number-4">4.3.4</span> 通用集合类型</h4>
<div class="outline-text-4" id="text-4-3-4">
</div>
<ol class="org-ol">
<li><a id="orgbb88996"></a>向量 <code>Vec&lt;T&gt;</code><br />
<div class="outline-text-5" id="text-4-3-4-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">创建</td>
<td class="org-left"><code>Vec::new()</code>, <code>vec![1, 2]</code></td>
</tr>

<tr>
<td class="org-left">获取数据</td>
<td class="org-left"><code>v.get(2)</code>, <code>&amp;v[2]</code></td>
</tr>

<tr>
<td class="org-left">修改</td>
<td class="org-left"><code>push</code>, <code>pop</code></td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org6dae3ec"></a>HashMap <code>HashMap&lt;_,_&gt;</code><br />
<div class="outline-text-5" id="text-4-3-4-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">创建</td>
<td class="org-left"><code>new</code>, <code>collect</code></td>
</tr>

<tr>
<td class="org-left">修改</td>
<td class="org-left"><code>insert</code>, <code>or_insert</code></td>
</tr>

<tr>
<td class="org-left">获取信息</td>
<td class="org-left"><code>get</code>, <code>entry</code></td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-orge527f2a" class="outline-4">
<h4 id="orge527f2a"><span class="section-number-4">4.3.5</span> 结构体</h4>
<div class="outline-text-4" id="text-4-3-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义</td>
<td class="org-left"><code>struct S{x:i8}</code>, <code>struct S(i8)</code></td>
</tr>

<tr>
<td class="org-left">创建实例</td>
<td class="org-left"><code>S{x:1, y, ..S0,}</code>, <code>S(1)</code></td>
</tr>

<tr>
<td class="org-left">获取值</td>
<td class="org-left"><code>S.x</code></td>
</tr>

<tr>
<td class="org-left">方法</td>
<td class="org-left"><code>impl S{fn}</code>, <code>&amp;self</code>, <code>&amp;mut self</code>, <code>S.mathod</code>, <code>S::function</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1dee1d2" class="outline-4">
<h4 id="org1dee1d2"><span class="section-number-4">4.3.6</span> 枚举</h4>
<div class="outline-text-4" id="text-4-3-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义</td>
<td class="org-left"><code>enum E{A, B{x:i8}, C(i8,i8)}</code></td>
</tr>

<tr>
<td class="org-left">获取值</td>
<td class="org-left"><code>E::A</code></td>
</tr>

<tr>
<td class="org-left">方法</td>
<td class="org-left"><code>impl E{fn}</code>, <code>&amp;self</code>, <code>&amp;mut self</code>, <code>E.mathod</code>, <code>E::function</code></td>
</tr>

<tr>
<td class="org-left"><code>Option</code></td>
<td class="org-left"><code>enum Option&lt;T&gt;{Some(T), None}</code>, <code>Some(1)</code>, <code>None</code></td>
</tr>

<tr>
<td class="org-left">模式匹配</td>
<td class="org-left"><code>match E{Some(ref x)=&gt;(), None=&gt;None, _=&gt;()}</code>, <code>if let Some(1)=E{}else{}</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org6e21fcc" class="outline-4">
<h4 id="org6e21fcc"><span class="section-number-4">4.3.7</span> 智能指针</h4>
<div class="outline-text-4" id="text-4-3-7">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">智能指针们</td>
<td class="org-left"><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code>, <code>Weak&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code></td>
</tr>

<tr>
<td class="org-left">定义</td>
<td class="org-left"><code>impl&lt;T&gt; Deref for S&lt;T&gt;{type Target = T; fn deref(&amp;self) -&gt; &amp;T {&amp;self.0 }}</code>, <code>impl Drop for S{fn drop(&amp;mut self){}}</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgba977c7" class="outline-3">
<h3 id="orgba977c7"><span class="section-number-3">4.4</span> 泛型</h3>
<div class="outline-text-3" id="text-4-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义泛型版本的&#x2026;</td>
<td class="org-left"><code>fn f&lt;T&gt;()-&gt;T{}</code>, <code>struct S&lt;T&gt;{x:T}</code>, <code>enum E&lt;T&gt;{X(T)}</code>, <code>impl&lt;T&gt; S&lt;T&gt;{}</code>, <code>impl S&lt;T&gt;{}</code></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgc89f1a0" class="outline-4">
<h4 id="orgc89f1a0"><span class="section-number-4">4.4.1</span> trait</h4>
<div class="outline-text-4" id="text-4-4-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义</td>
<td class="org-left"><code>pub trait Tt {fn f(&amp;self) -&gt; i8; fn g()-&gt;{}}</code></td>
</tr>

<tr>
<td class="org-left">实现</td>
<td class="org-left"><code>impl Tt for S{}</code></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/book/2018-edition/ch10-02-traits.html#traits-as-arguments">存在类型</a></td>
<td class="org-left"><code>f()-&gt;impl Trait</code></td>
</tr>

<tr>
<td class="org-left">trait bounds</td>
<td class="org-left"><code>fn f&lt;T:Tt1+Tt2&gt;(t:T) -&gt; i8{}</code>, <code>fn f&lt;T&gt;(t:T)-&gt;i8 where T:Tt1+Tt2{}</code>, <code>impl&lt;T:Tt0&gt; Tt for T{}</code></td>
</tr>

<tr>
<td class="org-left">关联类型</td>
<td class="org-left"><code>type Item;</code>,</td>
</tr>

<tr>
<td class="org-left">运算符重载</td>
<td class="org-left"><code>std::ops</code>, <code>Add</code>, <code>AddAssign</code>,</td>
</tr>

<tr>
<td class="org-left">完全限定语法</td>
<td class="org-left"><code>&lt;A as B&gt;::f()</code></td>
</tr>

<tr>
<td class="org-left">上级 trait</td>
<td class="org-left"><code>trait Tt: SuperTt {}</code></td>
</tr>

<tr>
<td class="org-left">类型别名</td>
<td class="org-left"><code>type Thunk = Box&lt;Fn() + Send + 'static&gt;;</code></td>
</tr>

<tr>
<td class="org-left">never type</td>
<td class="org-left"><code>!</code></td>
</tr>

<tr>
<td class="org-left">动态大小类型</td>
<td class="org-left"><code>&lt;T: Sized&gt;</code>, <code>&lt;T: ?Sized&gt;</code></td>
</tr>

<tr>
<td class="org-left">derive</td>
<td class="org-left"><code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>, <code>Ord</code>, <code>Clone</code>, <code>Copy</code>, <code>Hash</code>, <code>Default</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4cd7bc3" class="outline-4">
<h4 id="org4cd7bc3"><span class="section-number-4">4.4.2</span> 生命周期</h4>
<div class="outline-text-4" id="text-4-4-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">表示方法</td>
<td class="org-left"><code>&amp;'a i8</code>, <code>&amp;'b mut i8</code>, <code>&amp;'static i8</code></td>
</tr>

<tr>
<td class="org-left">生命周期注解</td>
<td class="org-left"><code>fn f&lt;'a&gt;(x:&amp;'a str) -&gt; &amp;'a str{}</code>, <code>struct S&lt;'a&gt;{x:&amp;'a i8}</code></td>
</tr>

<tr>
<td class="org-left">生命周期 bound</td>
<td class="org-left"><code>&lt;'c, 's: 'c&gt;</code>, <code>&lt;T: 'static&gt;</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgc9ace8f" class="outline-3">
<h3 id="orgc9ace8f"><span class="section-number-3">4.5</span> 错误处理</h3>
<div class="outline-text-3" id="text-4-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">直接崩溃</td>
<td class="org-left"><code>panic!("")</code>, <code>unwrap</code>, <code>expect</code></td>
</tr>

<tr>
<td class="org-left">尝试恢复</td>
<td class="org-left"><code>enum Result&lt;T,E&gt;{Ok(T),Err(E),}</code>, <code>?</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgcb3470c" class="outline-3">
<h3 id="orgcb3470c"><span class="section-number-3">4.6</span> I/O <code>std::io</code></h3>
<div class="outline-text-3" id="text-4-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>println!</code></td>
<td class="org-left"><code>println!("{},{:?},{:#?}",x,Debug,Debug)</code></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/index.html#ioresult"><code>io::Result</code></a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>traits</b></td>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>(trait)read</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>(trait)write</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>(trait)seek</code></a>, <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>(trait)BufRead</code></a></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>(trait)read</code></a></td>
<td class="org-left"><code>read_to_end</code>, <code>read_to_string</code>, <code>read_exact</code>, <code>by_ref</code>, <code>bytes</code>, <code>chars</code></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>(trait)write</code></a></td>
<td class="org-left"><code>writh</code>, <code>flush</code>, <code>write_all</code>, <code>write_fmt</code>, <code>by_ref</code></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>(trait)seek</code></a></td>
<td class="org-left"><code>seek</code></td>
</tr>

<tr>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>(trait)BufRead</code></a></td>
<td class="org-left"><code>fill_buf</code>, <code>comsume</code>, <code>read_until</code>, <code>read_line</code>, <code>split</code>, <code>lines</code></td>
</tr>

<tr>
<td class="org-left"><b>从/到buffer</b></td>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>(struct)BufReader</code></a>, <a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html"><code>(struct)BufWriter</code></a></td>
</tr>

<tr>
<td class="org-left"><b>从/到标准I/O</b></td>
<td class="org-left"><a href="https://doc.rust-lang.org/std/io/fn.stdout.html"><code>stdout</code></a> , <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>stdin</code></a>, <code>lock</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5380821" class="outline-3">
<h3 id="org5380821"><span class="section-number-3">4.7</span> 文件系统 <code>use std::fs::File;</code></h3>
<div class="outline-text-3" id="text-4-7">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">打开文件</td>
<td class="org-left"><code>open</code></td>
</tr>

<tr>
<td class="org-left">创建</td>
<td class="org-left"><code>create</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org259ab59" class="outline-3">
<h3 id="org259ab59"><span class="section-number-3">4.8</span> 函数式编程</h3>
<div class="outline-text-3" id="text-4-8">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">匿名函数</td>
<td class="org-left"><code>let f = ¦num: u32¦ -&gt; i8{}</code></td>
</tr>

<tr>
<td class="org-left">泛型</td>
<td class="org-left"><code>Fn(u32) -&gt; u32</code>, <code>FnMut</code>, <code>FnOnce</code></td>
</tr>

<tr>
<td class="org-left">获取所有权</td>
<td class="org-left"><code>move ¦x¦ x;</code></td>
</tr>

<tr>
<td class="org-left">定义迭代器</td>
<td class="org-left"><code>impl Iterator for S{type Item=u32; fn next(&amp;mut self)-&gt;Option&lt;Self::Item&gt;{}</code></td>
</tr>

<tr>
<td class="org-left">使用迭代器</td>
<td class="org-left"><code>next</code>, <code>map</code>, <code>collect</code>, <code>filter</code>, <code>zip</code></td>
</tr>

<tr>
<td class="org-left">函数指针</td>
<td class="org-left"><code>&lt;f: fn(i32) -&gt; i32&gt;</code></td>
</tr>

<tr>
<td class="org-left">返回闭包</td>
<td class="org-left"><code>Box&lt;Fn(i32) -&gt; i32&gt;</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4c15a38" class="outline-3">
<h3 id="org4c15a38"><span class="section-number-3">4.9</span> 并发</h3>
<div class="outline-text-3" id="text-4-9">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">创建/删除线程</td>
<td class="org-left"><code>std::thread</code>, <code>thread::spawn</code>, <code>join</code>,</td>
</tr>

<tr>
<td class="org-left">消息传递</td>
<td class="org-left"><code>std::sync::mpsc</code>, <code>mpsc::channel</code>, <code>send</code>, <code>recv</code>, <code>mpsc::Sender::clone</code>, <code>thread::sleep</code></td>
</tr>

<tr>
<td class="org-left">互斥器</td>
<td class="org-left"><code>std::sync::Mutex</code>, <code>lock</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf8272ec" class="outline-3">
<h3 id="orgf8272ec"><span class="section-number-3">4.10</span> 不安全</h3>
<div class="outline-text-3" id="text-4-10">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">裸指针</td>
<td class="org-left"><code>let x = &amp;num as *const i32</code>, <code>let y = &amp;mut num as *mut i32</code>, <code>unsafe{*x}</code></td>
</tr>

<tr>
<td class="org-left">函数</td>
<td class="org-left"><code>unsafe fn f(){}</code>, <code>unsafe{f()}</code></td>
</tr>

<tr>
<td class="org-left">调用外部代码</td>
<td class="org-left"><code>extern "C" {fn abs(input: i32) -&gt; i32;}</code>, <code>unsafe{abs(1)}</code></td>
</tr>

<tr>
<td class="org-left">可变的静态变量</td>
<td class="org-left"><code>static mut COUNTER: u32 = 0;</code>, <code>unsafe { COUNTER += inc; }</code>, <code>unsafe { println!("COUNTER: {}", COUNTER); }</code></td>
</tr>

<tr>
<td class="org-left">不安全的trait</td>
<td class="org-left"><code>unsafe trait Foo {};</code>, <code>unsafe impl Foo for i32 {}</code></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgf6e9ccd" class="outline-4">
<h4 id="orgf6e9ccd"><span class="section-number-4">4.10.1</span> FFI</h4>
</div>
</div>

<div id="outline-container-org404febc" class="outline-3">
<h3 id="org404febc"><span class="section-number-3">4.11</span> 宏</h3>
<div class="outline-text-3" id="text-4-11">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">使用宏</td>
<td class="org-left"><code>#[macro_use]</code></td>
</tr>

<tr>
<td class="org-left">定义宏</td>
<td class="org-left"><code>#[macro_export]</code>, <code>macro_rules!</code>,</td>
</tr>

<tr>
<td class="org-left">匹配规则</td>
<td class="org-left"><code>()=&gt;{}</code>, <code>$(),</code>, <code>$x:expr</code>, <code>*</code></td>
</tr>

<tr>
<td class="org-left">derive宏</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8fd7398" class="outline-3">
<h3 id="org8fd7398"><span class="section-number-3">4.12</span> 组织一个项目</h3>
<div class="outline-text-3" id="text-4-12">
</div>
<div id="outline-container-orgf4d974f" class="outline-4">
<h4 id="orgf4d974f"><span class="section-number-4">4.12.1</span> 模块系统</h4>
<div class="outline-text-4" id="text-4-12-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">定义模块</td>
<td class="org-left"><code>mod M{}</code>, <code>mod M;</code>, <code>pub mod M;</code></td>
</tr>

<tr>
<td class="org-left">使用模块与函数</td>
<td class="org-left"><code>extern crate C;</code>, <code>use C0::C1;</code>, <code>use super::*</code></td>
</tr>

<tr>
<td class="org-left">定义函数</td>
<td class="org-left"><code>pub fn</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc37b142" class="outline-4">
<h4 id="orgc37b142"><span class="section-number-4">4.12.2</span> Cargo</h4>
<div class="outline-text-4" id="text-4-12-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">新建项目</td>
<td class="org-left"><code>cargo new</code></td>
</tr>

<tr>
<td class="org-left">构建项目</td>
<td class="org-left"><code>cargo build</code>, <code>cargo run</code></td>
</tr>

<tr>
<td class="org-left">运行测试</td>
<td class="org-left"><code>cargo test</code></td>
</tr>

<tr>
<td class="org-left">安装</td>
<td class="org-left"><code>cargo install</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org02ead92" class="outline-4">
<h4 id="org02ead92"><span class="section-number-4">4.12.3</span> 测试</h4>
<div class="outline-text-4" id="text-4-12-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">标题</th>
<th scope="col" class="org-left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">注解</td>
<td class="org-left"><code>#[cfg(test)]</code>, <code>#[test]</code>, <code>#[should_panic(expected="e")]</code></td>
</tr>

<tr>
<td class="org-left">宏</td>
<td class="org-left"><code>assert_eq!</code>, <code>assert_ne!</code>, <code>assert!</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org891d374" class="outline-3">
<h3 id="org891d374"><span class="section-number-3">4.13</span> 程序模板</h3>
<div class="outline-text-3" id="text-4-13">
</div>
<div id="outline-container-org3d129dc" class="outline-4">
<h4 id="org3d129dc"><span class="section-number-4">4.13.1</span> 模式匹配</h4>
<div class="outline-text-4" id="text-4-13-1">
<div class="org-src-container">
<pre class="src src-rust">match x {
    1 =&gt; println!("one"),
    2|3 =&gt; println!("two"),
    3 ... 4 if x &gt;0  =&gt; println!("three"),
    Some(k) =&gt; println!("{}", k),
    Point { x: a, y: _, z: ref c, m: ref mut d, n, p: e @ 3...7, _, q: f, ..  } =&gt; println!("{},{},{},{},{},{},{}",a,b,c,*d,n,e,f),
    _ =&gt; println!("anything"),
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ff0b9f" class="outline-4">
<h4 id="org1ff0b9f"><span class="section-number-4">4.13.2</span> 结构体</h4>
<div class="outline-text-4" id="text-4-13-2">
<div class="org-src-container">
<pre class="src src-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}; 
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
	self.width * self.height
    }
    fn square(size: u32) -&gt; Rectangle {
	Rectangle { width: size, height: size }
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org744b715" class="outline-4">
<h4 id="org744b715"><span class="section-number-4">4.13.3</span> 枚举</h4>
<div class="outline-text-4" id="text-4-13-3">
<div class="org-src-container">
<pre class="src src-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org16f1dda" class="outline-4">
<h4 id="org16f1dda"><span class="section-number-4">4.13.4</span> trait</h4>
<div class="outline-text-4" id="text-4-13-4">
<div class="org-src-container">
<pre class="src src-rust">
pub trait Summarizable {
    fn summary1(&amp;self) -&gt; String;
    fn summary2(&amp;self) -&gt; String {
	String::from("(Read more...)")
    }
}
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
	format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org9a6ce79" class="outline-4">
<h4 id="org9a6ce79"><span class="section-number-4">4.13.5</span> 泛型</h4>
<div class="outline-text-4" id="text-4-13-5">
</div>
<ol class="org-ol">
<li><a id="org5b4320b"></a>泛型版本的函数<br />
<div class="outline-text-5" id="text-4-13-5-1">
<div class="org-src-container">
<pre class="src src-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
	if item &gt; largest {
	    largest = item;
	}
    }

    largest
}
</pre>
</div>
</div>
</li>

<li><a id="org25c0307"></a>泛型版本的结构体<br />
<div class="outline-text-5" id="text-4-13-5-2">
<div class="org-src-container">
<pre class="src src-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}
</pre>
</div>
</div>
</li>

<li><a id="orgd8be257"></a>泛型版本的枚举<br />
<div class="outline-text-5" id="text-4-13-5-3">
<div class="org-src-container">
<pre class="src src-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</pre>
</div>
</div>
</li>

<li><a id="orge4c6bc7"></a>泛型版本的方法<br />
<div class="outline-text-5" id="text-4-13-5-4">
<div class="org-src-container">
<pre class="src src-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
	Point {
	    x: self.x,
	    y: other.y,
	}
    }
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgfe01dd7" class="outline-2">
<h2 id="orgfe01dd7"><span class="section-number-2">5</span> Rust函数记录</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgc2718a5" class="outline-3">
<h3 id="orgc2718a5"><span class="section-number-3">5.1</span> 常用函数</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<code>fn</code> :定义函数
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main (){

}
</pre>
</div>
<p>
<code>println!</code> :打印输出
</p>
<div class="org-src-container">
<pre class="src src-rust">println!("str")
</pre>
</div>
<p>
<code>use</code> :引入类型
</p>
<div class="org-src-container">
<pre class="src src-rust">use std::io
...
io::stdin()
</pre>
</div>
<p>
<code>extern crate rand;</code> 引入外部库
</p>
</div>
</div>

<div id="outline-container-org3a25c9c" class="outline-3">
<h3 id="org3a25c9c"><span class="section-number-3">5.2</span> 常用宏</h3>
<div class="outline-text-3" id="text-5-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>panic!("str")</code></td>
<td class="org-left">导致崩溃并输出信息</td>
</tr>

<tr>
<td class="org-left">=vec![1,2,3]`</td>
<td class="org-left">字面量创建`vec&lt;T&gt;=</td>
</tr>

<tr>
<td class="org-left"><code>assert!(a)</code></td>
<td class="org-left">判断布尔值</td>
</tr>

<tr>
<td class="org-left"><code>assert_eq!(a,b)</code></td>
<td class="org-left">判断二值相等</td>
</tr>

<tr>
<td class="org-left">=try!(fn)`</td>
<td class="org-left">执行函数返回`Result&lt;T,E&gt;`的`T`或`E=</td>
</tr>

<tr>
<td class="org-left"><code>unreachable!()</code></td>
<td class="org-left">执行到这里就崩溃,放在不该被执行到的地方</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb58e9c7" class="outline-3">
<h3 id="orgb58e9c7"><span class="section-number-3">5.3</span> 过程宏</h3>
<div class="outline-text-3" id="text-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">=#[derive(PartialEq)]`</td>
<td class="org-left">添加相等`===</td>
</tr>

<tr>
<td class="org-left">=#[derive(Clone)]`</td>
<td class="org-left">添加`.clone()=</td>
</tr>

<tr>
<td class="org-left">=#[derive(Debug)]`</td>
<td class="org-left">添加`print!("{:?}",a)`的`:?=</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org4b0682c" class="outline-2">
<h2 id="org4b0682c"><span class="section-number-2">6</span> 原始类型</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgf477398" class="outline-3">
<h3 id="orgf477398"><span class="section-number-3">6.1</span> str:字符串</h3>
<div class="outline-text-3" id="text-6-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>"s".trim()</code></td>
<td class="org-left">去除开头结尾的空白\t</td>
</tr>

<tr>
<td class="org-left">="s".parse()`</td>
<td class="org-left">转换成数字类型,返回`String::Result=</td>
</tr>

<tr>
<td class="org-left"><code>"s".replace("old","new")</code></td>
<td class="org-left">替换字符串</td>
</tr>

<tr>
<td class="org-left"><code>"s".to_string();1.to_string();</code></td>
<td class="org-left">将各种东西转换成String</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org88cf15d" class="outline-2">
<h2 id="org88cf15d"><span class="section-number-2">7</span> 标准库</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org9939d82" class="outline-3">
<h3 id="org9939d82"><span class="section-number-3">7.1</span> std::String:可变字符串</h3>
<div class="outline-text-3" id="text-7-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>String::new()</code></td>
<td class="org-left">新建实例</td>
</tr>

<tr>
<td class="org-left"><code>String::from("a")</code></td>
<td class="org-left">创建字符串</td>
</tr>

<tr>
<td class="org-left"><code>string.as_str()</code></td>
<td class="org-left">转换成字符串str</td>
</tr>

<tr>
<td class="org-left"><code>string.as_mut_str()</code></td>
<td class="org-left">转换成可变str</td>
</tr>

<tr>
<td class="org-left"><code>string.push_str("a")</code></td>
<td class="org-left">追加字符串</td>
</tr>

<tr>
<td class="org-left"><code>format!("{}-{}",a,b)</code></td>
<td class="org-left">字符串格式化连接,返回String</td>
</tr>

<tr>
<td class="org-left"><code>let (first,last) = s.split_at(2)</code></td>
<td class="org-left">从标号开始分割</td>
</tr>

<tr>
<td class="org-left"><code>"s".split(</code> &vert; <code>c</code> &vert; <code>c == ' ');</code></td>
<td class="org-left">传入匿名函数规则,分割字符串</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgad5c229" class="outline-3">
<h3 id="orgad5c229"><span class="section-number-3">7.2</span> std::collections::HashMap</h3>
<div class="outline-text-3" id="text-7-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>use std::collections::HashMap;</code></td>
<td class="org-left">需要先引入库才能用</td>
</tr>

<tr>
<td class="org-left"><code>let map:HashMap&lt;&amp;str,i32&gt; = HashMap::new();</code></td>
<td class="org-left">新建必须指定类型,没有字面量创建宏可用,可以借助array生成</td>
</tr>

<tr>
<td class="org-left"><code>map.instrt("a",2)</code></td>
<td class="org-left">只能一个个插入值</td>
</tr>

<tr>
<td class="org-left"><code>for (key, val) in map.iter() {}</code></td>
<td class="org-left">遍历键值对</td>
</tr>

<tr>
<td class="org-left"><code>map.iter_mut()</code></td>
<td class="org-left">遍历键值对,可变</td>
</tr>

<tr>
<td class="org-left"><code>for i in map.keys(){}</code></td>
<td class="org-left">遍历键</td>
</tr>

<tr>
<td class="org-left"><code>for i in map.values(){}</code></td>
<td class="org-left">遍历值</td>
</tr>

<tr>
<td class="org-left"><code>for i in map.values_mut(){*i}</code></td>
<td class="org-left">遍历值,可变</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgba598ab" class="outline-3">
<h3 id="orgba598ab"><span class="section-number-3">7.3</span> std::vec::Vec:可变数组</h3>
<div class="outline-text-3" id="text-7-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>vec![1]</code></td>
<td class="org-left">新建数组字面量宏</td>
</tr>

<tr>
<td class="org-left"><code>let vec: Vec&lt;i32&gt; = Vec::new();</code></td>
<td class="org-left">新建空Vec</td>
</tr>

<tr>
<td class="org-left"><code>vec.push(1)</code></td>
<td class="org-left">在末尾添加元素</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org0dd0759" class="outline-3">
<h3 id="org0dd0759"><span class="section-number-3">7.4</span> std::io:标准输入输出</h3>
<div class="outline-text-3" id="text-7-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>std::fs::File</code></td>
<td class="org-left">文件处理</td>
</tr>

<tr>
<td class="org-left"><code>std::io::prelude::*</code></td>
<td class="org-left">io相关方法</td>
</tr>

<tr>
<td class="org-left"><code>let mut f = File::open(filename).expect("file not found");</code></td>
<td class="org-left">载入文件</td>
</tr>

<tr>
<td class="org-left"><code>let mut contents = String::new();</code></td>
<td class="org-left">预创建文件内容读取</td>
</tr>

<tr>
<td class="org-left"><code>f.read_to_string(&amp;mut contents).expect("e");</code></td>
<td class="org-left">读取文件</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-rust">use std::io
is::stdin().read_line(&amp;mut guess)
</pre>
</div>
</div>
</div>
<div id="outline-container-org5ef7acb" class="outline-3">
<h3 id="org5ef7acb"><span class="section-number-3">7.5</span> std::cmp:比较</h3>
<div class="outline-text-3" id="text-7-5">
</div>
<div id="outline-container-org2533a1a" class="outline-4">
<h4 id="org2533a1a"><span class="section-number-4">7.5.1</span> std::cmp::Ordering:比较大小</h4>
<div class="outline-text-4" id="text-7-5-1">
<div class="org-src-container">
<pre class="src src-rust">use std::cmp::Ordering
match "s".cmp(&amp;s){
	Ordering::Less =&gt; println!("l")
	Ordering::Greater =&gt; println!("g")
	Ordering::Equl =&gt; println!("e")
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org561384d" class="outline-3">
<h3 id="org561384d"><span class="section-number-3">7.6</span> std::env:命令行参数</h3>
</div>
</div>

<div id="outline-container-org4ec0ee8" class="outline-2">
<h2 id="org4ec0ee8"><span class="section-number-2">8</span> 外部库</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgb80ced2" class="outline-3">
<h3 id="orgb80ced2"><span class="section-number-3">8.1</span> regex:正则表达式</h3>
<div class="outline-text-3" id="text-8-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>regex = "0.2"</code></td>
<td class="org-left">先要引入依赖</td>
</tr>

<tr>
<td class="org-left"><code>extern crate regex;use regex::Regex;</code></td>
<td class="org-left">再引入库和函数</td>
</tr>

<tr>
<td class="org-left"><code>let re = Regex::new(r"").unwrap()</code></td>
<td class="org-left">创建正则文本</td>
</tr>

<tr>
<td class="org-left"><code>RE.is_match(text)</code></td>
<td class="org-left">返回bool,检查是否完全匹配</td>
</tr>

<tr>
<td class="org-left"><code>for cap in re.captures_iter(text) {&amp;cap[1]}</code></td>
<td class="org-left">返回含有匹配项列表的迭代器</td>
</tr>

<tr>
<td class="org-left"><code>let after = re.replace_all(before, "$m/$d/$y");</code></td>
<td class="org-left">替换</td>
</tr>

<tr>
<td class="org-left">=Regex::new(r"(?x)  (?P&lt;y&gt;\d{4}) # the year ")`</td>
<td class="org-left">使用`(?x)= 开启忽略空白的模式,可以用来写注释</td>
</tr>

<tr>
<td class="org-left"><code>let mat = re.find("ΔδΔ").unwrap();</code></td>
<td class="org-left">搜索返回位置</td>
</tr>

<tr>
<td class="org-left"><code>mat.start()==6,mat.end()==10</code></td>
<td class="org-left">返回的内容</td>
</tr>

<tr>
<td class="org-left"><code>(?P&lt;name&gt;exp)</code></td>
<td class="org-left">命名的匹配表达式</td>
</tr>

<tr>
<td class="org-left"><code>(?:exp)</code></td>
<td class="org-left">不获取的表达式</td>
</tr>

<tr>
<td class="org-left"><code>(?flag)</code></td>
<td class="org-left">设置一个标记</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgc3f4ba7" class="outline-2">
<h2 id="orgc3f4ba7"><span class="section-number-2">9</span> 大体上与一般的正则表达式相同,但有一些特有写法</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">
<pre class="src src-rust">extern crate regex;
use regex::Regex;
let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
assert!(re.is_match("2014-01-01"));
</pre>
</div>
</div>
<div id="outline-container-org82ee0c9" class="outline-3">
<h3 id="org82ee0c9"><span class="section-number-3">9.1</span> rand:随机数生成</h3>
<div class="outline-text-3" id="text-9-1">
<p>
<code>rand = "0.3.14"</code> 
</p>
<div class="org-src-container">
<pre class="src src-rust">extern crate rand; //引入外部库
use rand::Rng;	//trait
rand::thread_rng().gen_range(1,101) //调用随机数生成器的整数生成方法
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1169cb5" class="outline-2">
<h2 id="org1169cb5"><span class="section-number-2">10</span> Rust 踩过的坑</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org68f064f" class="outline-3">
<h3 id="org68f064f"><span class="section-number-3">10.1</span> rust 编译成动态链接库供 c, python 使用</h3>
<div class="outline-text-3" id="text-10-1">
</div>
<div id="outline-container-org35ad4e2" class="outline-4">
<h4 id="org35ad4e2"><span class="section-number-4">10.1.1</span> rust</h4>
<div class="outline-text-4" id="text-10-1-1">
</div>
<ol class="org-ol">
<li><a id="org0425189"></a>项目指定<br />
<ol class="org-ol">
<li><a id="orga6832f4"></a>使用 cargo<br />
<div class="outline-text-6" id="text-10-1-1-1-1">
<ol class="org-ol">
<li>引入 linc 库</li>
<li>指定 lib 类型为 "cdylib"</li>
<li>编译正常为 <code>cargo build</code></li>
</ol>
<div class="org-src-container">
<pre class="src src-rust">[dependencies]
    libc = "0.2"

    [lib]
    name="f"
    crate-type=["cdylib"]
</pre>
</div>
</div>
</li>

<li><a id="org9b411cc"></a>使用 rustc<br />
<div class="outline-text-6" id="text-10-1-1-1-2">
<ol class="org-ol">
<li><p>
在源码中加入
</p>
<div class="org-src-container">
<pre class="src src-rust">#![crate_type = "cdylib"]
</pre>
</div></li>
<li>编译为 <code>rustc a.rs</code></li>
</ol>
</div>
</li>
</ol>
</li>

<li><a id="orgdc43cdc"></a>代码修改<br />
<ol class="org-ol">
<li><a id="org2e2a8ee"></a>类型<br />
<div class="outline-text-6" id="text-10-1-1-2-1">
<ol class="org-ol">
<li>使用 <code>libc</code> 库 <code>extern crate libc;</code></li>
</ol>
</div>
</li>
<li><a id="org9f3fac8"></a>函数声明<br />
<div class="outline-text-6" id="text-10-1-1-2-2">
<div class="org-src-container">
<pre class="src src-rust">#[no_mangle]
pub extern "C" fn f(x:i64) -&gt; f64{}
</pre>
</div>
</div>
</li>
<li><a id="org7b3bc98"></a>使用 c 语言风格：通过指针改变数组值来传递变量<br />
<div class="outline-text-6" id="text-10-1-1-2-3">
<ol class="org-ol">
<li>定义参数 <code>*mut [f64;4]</code></li>
<li>函数中使用值 <code>(*res)</code></li>
<li>rust 代码中使用 <code>f(&amp;mut a)</code></li>
</ol>
</div>
<ol class="org-ol">
<li><a id="org995bf4c"></a>rust 代码<br />
<div class="outline-text-7" id="text-10-1-1-2-3-1">
<div class="org-src-container">
<pre class="src src-rust">unsafe {
    let mut a: [f64; 4] = [1.0, 2.0, 3.0, 4.0];
    f(&amp;mut a);
};
#[no_mangle]
pub unsafe extern "C" fn f(result: *mut [f64; 4]) {
    (*result) = [1.1, 2.2, 3.3, 4.4];
}
</pre>
</div>
</div>
</li>
<li><a id="orgf980b54"></a>c 头文件<br />
<div class="outline-text-7" id="text-10-1-1-2-3-2">
<div class="org-src-container">
<pre class="src src-c">#ifndef F_H
#define F_H

void f(double result[]);

#endif
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org0e4512c" class="outline-4">
<h4 id="org0e4512c"><span class="section-number-4">10.1.2</span> c</h4>
<div class="outline-text-4" id="text-10-1-2">
<ol class="org-ol">
<li><p>
示例的 rust 代码， <code>a.rs</code>
</p>
<div class="org-src-container">
<pre class="src src-rust">#![crate_type = "cdylib"]
#[no_mangle]
pub extern "C" fn foo() -&gt; i32 {
    123
}
</pre>
</div></li>

<li>编译 <code>rustc a.rs</code> 得到 <code>liba.so</code></li>

<li><p>
编写头文件 <code>a.h</code>
</p>
<div class="org-src-container">
<pre class="src src-rust">#ifndef A_H
#define A_H

int foo();

#endif
</pre>
</div></li>

<li><p>
编写 c 文件 <code>a.c</code>
</p>
<div class="org-src-container">
<pre class="src src-c">#include "a.h"
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
  printf("asd%d",foo());
  return 0;
}

</pre>
</div></li>

<li><p>
gcc 编译 
</p>
<div class="org-src-container">
<pre class="src src-bash">gcc a.c -L . -l a -Wl,-rpath=./        
</pre>
</div>

<ol class="org-ol">
<li><code>-L</code> 指定 <code>so</code> 文件的路径</li>

<li><code>-l</code> 指定 <code>lib**.so</code> 中 ** 的名字</li>

<li><code>-Wl,-rpath=./</code> 指定运行时加载 <code>liba.so</code> 的路径</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org477913c" class="outline-4">
<h4 id="org477913c"><span class="section-number-4">10.1.3</span> python</h4>
<div class="outline-text-4" id="text-10-1-3">
</div>
<ol class="org-ol">
<li><a id="org68eed37"></a>ctypes 方法<br />
<ol class="org-ol">
<li><a id="orgcbe2c63"></a>基本过程<br />
<div class="outline-text-6" id="text-10-1-3-1-1">
<ol class="org-ol">
<li>使用 <code>ctypes.CDLL("./libf.so")</code> 打开 so 文件</li>
<li>使用 <code>libf.f.restype=ctypes.type</code> 指定函数的返回值类型</li>
<li>复杂的返回值类型需要继承 <code>ctypes.Structure</code> 来构造</li>
<li>传入的参数类型需要通过 <code>ctypes.c_double(1)</code> 等转换</li>
<li>类型转换和调用开销极大</li>
</ol>
</div>
</li>
<li><a id="org05931e3"></a>完整示例<br />
<div class="outline-text-6" id="text-10-1-3-1-2">
<div class="org-src-container">
<pre class="src src-python">import ctypes


class Float64_4(ctypes.Structure):
    _fields_ = [("array", ctypes.c_double * 4)]


libf = ctypes.CDLL("./libf.so")


def cf(t, y, Delta, omega, c, A, epslion_0):
    a_r, a_i, b_r, b_i = y
    libf.f.restype = Float64_4
    res = libf.f(
	ctypes.c_double(a_r), ctypes.c_double(a_i), ctypes.c_double(b_r),
	ctypes.c_double(b_i), ctypes.c_double(t), ctypes.c_double(Delta),
	ctypes.c_double(omega), ctypes.c_double(c), ctypes.c_double(A),
	ctypes.c_double(epslion_0))
    return res.array[:]


cf(1, [1, 2, 3, 4], 1, 2, 3, 4, 5)
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="org0f86d3c"></a>cython 方法<br />
<div class="outline-text-5" id="text-10-1-3-2">
<ol class="org-ol">
<li><p>
示例的 rust 代码， <code>a.rs</code>
</p>
<div class="org-src-container">
<pre class="src src-rust">#![crate_type = "cdylib"]
#[no_mangle]
pub extern "C" fn foo() -&gt; i32 {
    123
}
</pre>
</div></li>
<li>编译 <code>rustc a.rs</code> 得到 <code>liba.so</code></li>
<li><p>
编写头文件 <code>a.h</code>
</p>
<div class="org-src-container">
<pre class="src src-rust">#ifndef A_H
#define A_H

int foo();

#endif
</pre>
</div></li>
<li><p>
根据头文件编写 cython 头文件 <code>a.pxd</code>
</p>
<div class="org-src-container">
<pre class="src src-python">cdef inline void a():
print "a"

cdef extern from "a.h":
int foo()
</pre>
</div></li>
<li><p>
编写 cython <code>b.pyx</code>
</p>
<div class="org-src-container">
<pre class="src src-python">cimport a

def b():
    a.foo()
    print("asd",a.a(),a.foo())
</pre>
</div></li>
<li><p>
编写 <code>setup.py</code>
</p>
<div class="org-src-container">
<pre class="src src-python">from distutils.core import setup
from distutils.extension import Extension
from Cython.Build import cythonize

setup(
    ext_modules = cythonize([Extension("b", ["b.pyx"],
				       libraries=["a"],
				       runtime_library_dirs=["."],
				       library_dirs=["."])])
)
</pre>
</div></li>
<li><p>
编译 
</p>
<div class="org-src-container">
<pre class="src src-bash">python3 setup.py build_ext -i      
</pre>
</div></li>
<li><p>
测试，在 python 中直接执行， 把 <code>liba.so</code> 和生成的 <code>b.cython.so</code> 复制到同一个文件夹即可
</p>
<div class="org-src-container">
<pre class="src src-python">import b
b.b()
</pre>
</div></li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-12-19 Sat 14:08</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
