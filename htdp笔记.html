<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-27 Sun 17:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HtDP笔记</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">HtDP笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2036f63">1. 设计程序的基本原则</a>
<ul>
<li><a href="#org94804b9">1.1. 基本原则</a></li>
<li><a href="#orge00dba5">1.2. 程序的类型</a></li>
</ul>
</li>
<li><a href="#orgbb30127">2. 设计基本的函数：固定大小数据</a>
<ul>
<li><a href="#org3fec3c8">2.1. 区间、枚举</a>
<ul>
<li><a href="#org891ff97">2.1.1. 区间</a></li>
<li><a href="#orgdc03fed">2.1.2. 枚举</a></li>
<li><a href="#orge3b93cd">2.1.3. 对设计程序过程的修改</a></li>
<li><a href="#orgbeec3e8">2.1.4. 有限状态自动机</a></li>
</ul>
</li>
<li><a href="#orgfd6f9f6">2.2. 结构体</a>
<ul>
<li><a href="#orgbcd7941">2.2.1. 使用结构体设计函数</a></li>
</ul>
</li>
<li><a href="#org3c5f563">2.3. 设计函数的基本方法</a>
<ul>
<li><a href="#orgd2bfa8d">2.3.1. 信息和数据的关系</a></li>
<li><a href="#orgf4580c7">2.3.2. 数据定义</a></li>
<li><a href="#org19fa892">2.3.3. 设计过程</a></li>
</ul>
</li>
<li><a href="#orgff872b4">2.4. 领域知识</a></li>
<li><a href="#orgd7fce04">2.5. 从函数到程序</a></li>
<li><a href="#org248e10f">2.6. 关于测试</a></li>
<li><a href="#orgf24f160">2.7. 设计交互式程序的基本方法</a>
<ul>
<li><a href="#org01b4899">2.7.1. 定义常量</a></li>
<li><a href="#org9357f18">2.7.2. 定义世界数据和世界信息</a></li>
<li><a href="#org699fcfe">2.7.3. 列愿望清单</a></li>
<li><a href="#org18b1687">2.7.4. 主函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgef6682f">3. 设计结构递归函数：任意大数据</a>
<ul>
<li><a href="#orgb66ba1b">3.1. 列表</a></li>
<li><a href="#orgcfdf125">3.2. 为自引用数据设计函数的方法</a>
<ul>
<li><a href="#orgc482e1c">3.2.1. 定义列表</a></li>
<li><a href="#orgb05382c">3.2.2. 签名、目的陈述和函数头</a></li>
<li><a href="#org1dae39c">3.2.3. 函数示例</a></li>
<li><a href="#orgd377d84">3.2.4. 函数模板</a></li>
<li><a href="#orgc75b3c3">3.2.5. 实现函数</a></li>
</ul>
</li>
<li><a href="#org904dfb7">3.3. 集合</a></li>
<li><a href="#orgb33d247">3.4. 通过组合进行设计</a></li>
</ul>
</li>
<li><a href="#org0696fbf">4. 设计与使用抽象的通用函数</a>
<ul>
<li><a href="#org944938b">4.1. 设计抽象</a>
<ul>
<li><a href="#org39dd60d">4.1.1. 设计步骤</a></li>
<li><a href="#org3341c8f">4.1.2. 设计通用签名</a></li>
</ul>
</li>
<li><a href="#org3727b9b">4.2. 使用抽象函数进行设计</a></li>
<li><a href="#org2b4b76e">4.3. 无名函数 Lambda</a></li>
</ul>
</li>
<li><a href="#org9a64d93">5. 设计互引用数据类型与函数</a>
<ul>
<li><a href="#org86d3929">5.1. 使用相互引用的数据进行设计</a></li>
<li><a href="#org2371dce">5.2. 设计处理多个复杂参数的函数</a></li>
</ul>
</li>
<li><a href="#orgf0e7264">6. 生成递归与算法</a>
<ul>
<li><a href="#orga635e6a">6.1. 设计算法</a>
<ul>
<li><a href="#org348ff57">6.1.1. 设计步骤</a></li>
<li><a href="#org14f4134">6.1.2. 终止</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org887ead4">7. 带有累加器的递归函数</a>
<ul>
<li><a href="#org08409b1">7.1. 设计有累加器的函数</a>
<ul>
<li><a href="#orgecadda1">7.1.1. 认识到需要累加器</a></li>
<li><a href="#orgae416b5">7.1.2. 添加累加器</a></li>
<li><a href="#org75a3b23">7.1.3. 把函数翻译成累加器版本</a></li>
<li><a href="#orgb7a2c46">7.1.4. 例子：求和函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="https://htdp.org/">https://htdp.org/</a>
</p>

<p>
好的程序员设计程序，差的程序员不断修改程序直到它看起来能运行。
</p>

<p>
设计过程是二维的，一方面是设计程序的过程，从一步到下一步，另一方面是解释所选择的数据表示方式如何影响设计的过程。
</p>
<div id="outline-container-org2036f63" class="outline-2">
<h2 id="org2036f63"><span class="section-number-2">1</span> 设计程序的基本原则</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org94804b9" class="outline-3">
<h3 id="org94804b9"><span class="section-number-3">1.1</span> 基本原则</h3>
<div class="outline-text-3" id="text-1-1">
<p>
系统设计的步骤
</p>
<ol class="org-ol">
<li>从分析问题到定义数据：明确要表达的信息和在选定的语言中如何表示它。用公式描述数据的定义并用例子刻画它。</li>
<li>签名、目的声明和标题：声明所需要的函数消费和产生哪种数据。用公式精确地回答函数计算了什么。定义一个满足签名要求的占位代码。</li>
<li>函数例子：解决那些用来说明函数目的的例子。</li>
<li>函数模板：把数据定义翻译成函数的提纲。</li>
<li>函数定义：填上函数模板中缺的部分。利用上目的声明和例子。</li>
<li>测试：把例子表述成测试，并确保函数可以通过所有测试。这样做来发现错误。测试也是帮助别人需要时阅读和理解定义的补充例子，对任何严肃的程序总是会出现这种需求的。</li>
</ol>

<p>
这些步骤可以用来提高表达能力，即：
</p>
<ol class="org-ol">
<li>分析问题陈述，通常就叫做问题这一个词。</li>
<li>抽象地提取和表述它的本质。</li>
<li>用例子刻画这个本质。</li>
<li>基于这个分析做提纲和计划。</li>
<li>根据预期产出评估结果。</li>
<li>根据失败的检查和测试来修改产品。</li>
</ol>
<p>
每一步都需要分析、精确、描述、聚焦重点并关注细节。
</p>
</div>
</div>
<div id="outline-container-orge00dba5" class="outline-3">
<h3 id="orge00dba5"><span class="section-number-3">1.2</span> 程序的类型</h3>
<div class="outline-text-3" id="text-1-2">
<p>
任何编程语言都包括描述数据的部分和操作数据的部分。
</p>

<p>
为每一个任务创建一个函数。
</p>

<p>
为每一个常量定义一个常量。
</p>

<p>
程序分成两种：
</p>
<ul class="org-ul">
<li>批处理程序：主函数一次性获得所有输入并计算出结果。主函数由各种辅助函数组成。</li>
<li>交互式程序：主函数先得到一些输入计算一些结果，然后再得到一些输入接着计算，循环往复。输入出现时称之为事件，交互式程序也叫做事件驱动程序。主函数用一个表达式来描述哪种事件对应哪个函数，这些函数叫做事件处理函数。</li>
</ul>

<p>
写程序包括一系列额外工作，而不只是应付了事地让程序能运行就够了，因为程序不是一天就能写完的，时间长了没有说明文档就没人能看懂这是在做什么。程序的需求和逻辑也一直在不断变化，好的文档和好的程序清晰地对应起来，那么对文档的修改就能很容易地变成对程序的修改。
</p>
</div>
</div>
</div>
<div id="outline-container-orgbb30127" class="outline-2">
<h2 id="orgbb30127"><span class="section-number-2">2</span> 设计基本的函数：固定大小数据</h2>
<div class="outline-text-2" id="text-2">
<p>
用来表示信息的基本数据类型有：数字、字符串、图像和布尔值。
这些量都可以被看作一个单位大小，也叫做原子数据。
</p>
</div>
<div id="outline-container-org3fec3c8" class="outline-3">
<h3 id="org3fec3c8"><span class="section-number-3">2.1</span> 区间、枚举</h3>
<div class="outline-text-3" id="text-2-1">
<p>
为了设计对基本类型加以限制的程序，需要引入其它的数据类型。
对于有限个数据采用枚举，对于无限多的数据可使用区间。
</p>
</div>
<div id="outline-container-org891ff97" class="outline-4">
<h4 id="org891ff97"><span class="section-number-4">2.1.1</span> 区间</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
区间可以用 <code>cond</code> 或者 <code>if</code> 的组合来表示，大于某个数或者小于某个数等等。
</p>
</div>
</div>

<div id="outline-container-orgdc03fed" class="outline-4">
<h4 id="orgdc03fed"><span class="section-number-4">2.1.2</span> 枚举</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
枚举和区间一样只是把大于小于换成等于判断。
</p>
</div>
</div>

<div id="outline-container-orge3b93cd" class="outline-4">
<h4 id="orge3b93cd"><span class="section-number-4">2.1.3</span> 对设计程序过程的修改</h4>
<div class="outline-text-4" id="text-2-1-3">
<ol class="org-ol">
<li>定义数据时要定义区间</li>
<li>签名、目的声明和函数头不变</li>
<li>函数例子要选择区间内的所有内容</li>
<li>函数模板中的条件数量和定义数据时的一样多</li>
<li>实现函数时每个区间都要实现</li>
<li>测试要覆盖所有部分</li>
</ol>
</div>
</div>

<div id="outline-container-orgbeec3e8" class="outline-4">
<h4 id="orgbeec3e8"><span class="section-number-4">2.1.4</span> 有限状态自动机</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
有限状态自动机 （finite state machines (FSM), also known as finite state automata (FSA)) 是包括几个状态和状态之间转移的系统。
</p>

<p>
要创建一个有限状态自动机，首先要选择一些对可能的状态的数据表示，这些状态是系统会发生变化的那些部分而不是不变的那些。
</p>

<p>
除了需要对系统状态信息转换成数据之外，也需要将驱动状态改变的信号转换成数据。
</p>

<p>
知道了如何表示系统的状态和如何从一个状态到下一个转换，以及系统每一次变化的方向。我们可以写下需要设计的函数的签名、目的陈述和占位程序。即状态转移函数和渲染函数。
</p>
</div>
</div>
</div>

<div id="outline-container-orgfd6f9f6" class="outline-3">
<h3 id="orgfd6f9f6"><span class="section-number-3">2.2</span> 结构体</h3>
<div class="outline-text-3" id="text-2-2">
<p>
当需要用一个数据储存多个信息的时候使用结构。
一般的语言不会提供现成的结构，所以要自己定义结构类型（structure type definition），结构包括一些数据，这些数据叫做字段（fields）。
定义一个结构时实际上定义了三种函数：
</p>
<ol class="org-ol">
<li>构造函数：用来创建结构体，把参数作为字段 <code>make-xxx</code></li>
<li>选择器：用来选择出结构体中的字段 <code>xxx-a,xxx-b</code></li>
<li>结构体谓词：用来判断某个量是否属于结构体 <code>xxx?</code></li>
</ol>

<p>
结构体类型定义时要写清楚对应的类型和解释信息的方法，例如：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #2aa198;">(</span>define-struct posn [x y]<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">A Posn is a structure: </span>
<span style="color: #93a1a1;">;   </span><span style="color: #93a1a1;">(make-posn Number Number)</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">interpretation a point x pixels from left, y from top</span>
</pre>
</div>

<p>
如果一个函数要处理嵌套的结构体，那么应该为嵌套的每一级都单独写一个函数。
</p>

<p>
结构体数据定义的目的是给集合和字段合适的名字，因为函数总是一次处理一个或几个字段而不是所有，所以字段名字应该合适，并且方便引用。
</p>

<p>
在定义结构体类型的时候有必要给出几个例子，并且涵盖各种情况。
</p>
</div>
<div id="outline-container-orgbcd7941" class="outline-4">
<h4 id="orgbcd7941"><span class="section-number-4">2.2.1</span> 使用结构体设计函数</h4>
<div class="outline-text-4" id="text-2-2-1">
</div>
<ol class="org-ol">
<li><a id="org87cc34a"></a>定义结构体<br />
<div class="outline-text-5" id="text-2-2-1-1">
<p>
定义结构体时，整体对应一个实在对象，而字段对应它的属性。
定义字段时应该同时指出它的类型，并附带一些例子：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #2aa198;">(</span>define-struct r3 [x y z]<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">An R3 is a structure:</span>
<span style="color: #93a1a1;">;   </span><span style="color: #93a1a1;">(make-r3 Number Number Number)</span>
 
<span style="color: #2aa198;">(</span>define ex1 <span style="color: #b58900;">(</span>make-r3 1 2 13<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>define ex2 <span style="color: #b58900;">(</span>make-r3 -1 0 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org2f74706"></a>签名、目的声明和函数头<br />
<div class="outline-text-5" id="text-2-2-1-2">
<p>
这步不变
</p>
</div>
</li>

<li><a id="orgb1d8ec5"></a>使用例子创建函数例子<br />
<div class="outline-text-5" id="text-2-2-1-3">
<p>
不变
</p>
</div>
</li>

<li><a id="org581510d"></a>函数模板<br />
<div class="outline-text-5" id="text-2-2-1-4">
<p>
一般来说函数总是要对结构体的每个字段进行操作的，所以可以先写下来选择器。
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">R3 -&gt; Number </span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">determines the distance of p to the origin </span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>r3-distance-to-0 p<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>... <span style="color: #268bd2;">(</span>r3-x p<span style="color: #268bd2;">)</span> ... <span style="color: #268bd2;">(</span>r3-y p<span style="color: #268bd2;">)</span> ... <span style="color: #268bd2;">(</span>r3-z p<span style="color: #268bd2;">)</span> ...<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org22786b1"></a>实现函数<br />
<div class="outline-text-5" id="text-2-2-1-5">
<p>
不变，注意对结构体选择器的操作。
</p>
</div>
</li>

<li><a id="org4fa0352"></a>测试<br />
<div class="outline-text-5" id="text-2-2-1-6">
<p>
不变，注意涵盖结构体的例子。
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3c5f563" class="outline-3">
<h3 id="org3c5f563"><span class="section-number-3">2.3</span> 设计函数的基本方法</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-orgd2bfa8d" class="outline-4">
<h4 id="orgd2bfa8d"><span class="section-number-4">2.3.1</span> 信息和数据的关系</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
信息是描述世界的关键部分，程序实际上就是在处理信息。但是为了程序能够处理信息，需要把信息转变成程序语言的某种数据形式才可以。
</p>

<p>
将简单的信息转变成数据很容易，但是对于复杂的信息，想把它变成数据就需要很多程序设计的知识了，例如解析器（parser）。
软件工程中常用 model-view-controller(MVC) 的方式把数据处理过程从解析信息变成数据和把数据变成信息中分离出来。
首先只关注于数据处理过程，至于数据和信息之间如何转换留待以后学习。
</p>
</div>
</div>

<div id="outline-container-orgf4580c7" class="outline-4">
<h4 id="orgf4580c7"><span class="section-number-4">2.3.2</span> 数据定义</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
鉴于数据和信息的核心地位，程序设计首先要从两者之间的联系出发。
首先，我们要决定如何使用我们的编程语言来把信息表示为数据，以及如何把数据解释成信息。
例如：42这个数字是数据，作为信息它可以表示温度、像素、数目、尺寸等等。但在一个特定的程序中它只有一种唯一的解释方法。
由于关于信息的知识对每个阅读程序的人都很重要，我们得把它以注释的形式写下来，这步叫做 <b>数据定义</b> 。
</p>

<p>
数据定义的目的有二，一是要用一个有意义的词来命名数据，二是告诉读者如何创建这类数据，以及某个任意的东西是否属于这类数据。
</p>
</div>
</div>

<div id="outline-container-org19fa892" class="outline-4">
<h4 id="org19fa892"><span class="section-number-4">2.3.3</span> 设计过程</h4>
<div class="outline-text-4" id="text-2-3-3">
</div>
<ol class="org-ol">
<li><a id="orgb9a35ae"></a>解释你打算怎么把信息表示为数据。<br />
<div class="outline-text-5" id="text-2-3-3-1">
<p>
一行注释就够了。
为你认为至关重要的数据类制定数据定义。
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">We use numbers to represent centimeters. </span>
</pre>
</div>
</div>
</li>

<li><a id="org767def5"></a>写下签名、目的声明和函数头<br />
<div class="outline-text-5" id="text-2-3-3-2">
<p>
函数签名是告诉读者你设计的函数要有多少个输入以及产生什么类型。
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">String -&gt; Number</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Temperature -&gt; String</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Number String Image -&gt; Image</span>
</pre>
</div>

<p>
目的声明也是一句注释，要在一行之内说明白函数的目的，即回答这个函数计算了什么东西，这个问题。
阅读函数的人应该不用读函数就能知道这个函数干了什么。
应该写两个目的声明，一个是为了那些要修改函数的人写的，另一个是为了那些要使用函数的人写的。
</p>

<p>
函数头是简化的函数定义，也就是占位代码，给签名里的类型选择一个变量名。然后返回一个类型符合的东西。
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>f a-string<span style="color: #b58900;">)</span> 0<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>g n<span style="color: #b58900;">)</span> <span style="color: #2aa198;">"a"</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>h num str img<span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>empty-scene 100 100<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
完整示例：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Number String Image -&gt; Image </span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">adds s to img,</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">y pixels from the top and 10 from the left </span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>add-image y s img<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>empty-scene 100 100<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org01794d5"></a>通过一些功能示例来说明签名和目的声明。<br />
<div class="outline-text-5" id="text-2-3-3-3">
<p>
要构建一个功能示例，请从签名的每个输入类型中选择一条数据，然后确定您希望获得的结果
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Number -&gt; Number</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">computes the area of a square with side len </span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">given: 2, expect: 4</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">given: 7, expect: 49</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>area-of-square len<span style="color: #b58900;">)</span> 0<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org6b26d77"></a>盘点清单，写函数体的模板<br />
<div class="outline-text-5" id="text-2-3-3-4">
<p>
想想都有什么东西是要被计算的，简单的函数里就只有参数。还有全局变量。
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>area-of-square len<span style="color: #b58900;">)</span>
   <span style="color: #b58900;">(</span>... len ...<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org74b6014"></a>写程序<br />
<div class="outline-text-5" id="text-2-3-3-5">
<p>
把函数实现了。
例1：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Number -&gt; Number</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">computes the area of a square with side len </span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">given: 2, expect: 4</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">given: 7, expect: 49</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>area-of-square len<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>sqr len<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
例2，设计过程：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">Number String Image -&gt; Image</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">adds s to img, y pixels from top, 10 pixels to the left</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">given: </span>
<span style="color: #93a1a1;">;    </span><span style="color: #93a1a1;">5 for y, </span>
<span style="color: #93a1a1;">;    </span><span style="color: #93a1a1;">"hello" for s, and</span>
<span style="color: #93a1a1;">;    </span><span style="color: #93a1a1;">(empty-scene 100 100) for img</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">expected: </span>
<span style="color: #93a1a1;">;    </span><span style="color: #93a1a1;">(place-image (text "hello" 10 "red") 10 5 ...)</span>
<span style="color: #93a1a1;">;    </span><span style="color: #93a1a1;">where ... is (empty-scene 100 100)</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>add-image y s img<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>place-image <span style="color: #268bd2;">(</span>text s 10 <span style="color: #2aa198;">"red"</span><span style="color: #268bd2;">)</span> 10 y img<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org100faf8"></a>运行并测试结果<br />
<div class="outline-text-5" id="text-2-3-3-6">
<p>
如果程序的结果和期望值不一样，可能错误的地方有：
</p>
<ol class="org-ol">
<li>例子给的预期结果错了</li>
<li>函数逻辑写错了，即 bug</li>
<li>例子和函数都错了</li>
</ol>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgff872b4" class="outline-3">
<h3 id="orgff872b4"><span class="section-number-3">2.4</span> 领域知识</h3>
<div class="outline-text-3" id="text-2-4">
<p>
编码写出来一个函数需要下面两种领域知识：
</p>
<ol class="org-ol">
<li>其它领域的知识：物理学、音乐等等</li>
<li>所选语言的库函数知识：是否有足够的函数实现需要的功能</li>
</ol>
<p>
在进行数据定义的步骤时就用到了其它领域的知识，而对于复杂的数据类型，就需要计算机科学的知识了。
</p>
</div>
</div>

<div id="outline-container-orgd7fce04" class="outline-3">
<h3 id="orgd7fce04"><span class="section-number-3">2.5</span> 从函数到程序</h3>
<div class="outline-text-3" id="text-2-5">
<p>
一个程序总是要包括很多函数的，可以列一个愿望清单，包括各种实现的功能，这个清单要包括有意义的函数名、类型签名和目的陈述。
对交互式程序的设计可以把事件处理函数、停止函数和场景渲染函数加进去。
清单完成的时候程序就写完了。
</p>
</div>
</div>

<div id="outline-container-org248e10f" class="outline-3">
<h3 id="org248e10f"><span class="section-number-3">2.6</span> 关于测试</h3>
<div class="outline-text-3" id="text-2-6">
<p>
测试是一项劳动密集型的繁重任务，很容易怕麻烦就略过测试，但这最终会导致问题并拖延进展，因此测试要尽量自动化进行。
</p>

<p>
对函数的测试称之为单元测试 （unit testing） ，上手任何一门语言首要任务就是搞清楚怎么进行单元测试。
</p>
</div>
</div>

<div id="outline-container-orgf24f160" class="outline-3">
<h3 id="orgf24f160"><span class="section-number-3">2.7</span> 设计交互式程序的基本方法</h3>
<div class="outline-text-3" id="text-2-7">
<p>
交互式的程序，随着输入变化会不断改变程序的状态并影响输出。
</p>

<p>
设计世界程序和设计函数一样，是系统性的从问题陈述到实际工作的程序的过程，包括三个大步骤和一个小步骤：
</p>
</div>

<div id="outline-container-org01b4899" class="outline-4">
<h4 id="org01b4899"><span class="section-number-4">2.7.1</span> 定义常量</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
对所有可能涉及到的不随实际变化的量都定义一个常量。
常量有两种：
</p>
<ol class="org-ol">
<li>物理常量：指的是那些描述这个世界具体特性的量，与真实世界的常量类似，程序总是用到它们，但不会修改它们。</li>
<li>图形常量：指的是那些要被显示出来的东西，这些常量共同组成了完整的渲染输入，通常程序要计算它们，并且会涉及到物理常量和其他的图形常量</li>
</ol>
<p>
要给常量写注释。
</p>
</div>
</div>

<div id="outline-container-org9357f18" class="outline-4">
<h4 id="org9357f18"><span class="section-number-4">2.7.2</span> 定义世界数据和世界信息</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
那些会随着时间和事件变化的属性就是世界的当前状态。
要为所有可能的世界状态开发一个数据表示，用注释写清楚怎么解读这些数据。
属性变化有很多，选择其中那些基本的简单的作为世界状态。
</p>
</div>
</div>

<div id="outline-container-org699fcfe" class="outline-4">
<h4 id="org699fcfe"><span class="section-number-4">2.7.3</span> 列愿望清单</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
有了世界数据，就要定义一系列的函数，例如将世界状态展示出来的渲染函数、响应事件修改状态的事件处理函数和满足一定条件时终止程序的函数等。
</p>
</div>
</div>

<div id="outline-container-org18b1687" class="outline-4">
<h4 id="org18b1687"><span class="section-number-4">2.7.4</span> 主函数</h4>
<div class="outline-text-4" id="text-2-7-4">
<p>
最终需要一个主函数，主函数不需要设计也不需要测试，只是用来启动程序的。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgef6682f" class="outline-2">
<h2 id="orgef6682f"><span class="section-number-2">3</span> 设计结构递归函数：任意大数据</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgb66ba1b" class="outline-3">
<h3 id="orgb66ba1b"><span class="section-number-3">3.1</span> 列表</h3>
<div class="outline-text-3" id="text-3-1">
<p>
列表(list)不是一种创建数据的方法，而是一种表达数据定义的方法。    
列表是能放下一系列不确定数量的原子数据构成的，它是从空列表 <code>'()</code> 逐渐向前连接其它量 <code>(cons 'a '())</code> 生成的。
所以列表的定义是自引用的，例如：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">A List-of-names is one of: </span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">&#8211; '()</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">&#8211; (cons String List-of-names)</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">interpretation a list of invitees, by last name</span>
</pre>
</div>

<p>
列表涉及到的基本单元有：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>'()</code></td>
<td class="org-left">特殊的值，指空列表</td>
</tr>

<tr>
<td class="org-left"><code>empty?</code></td>
<td class="org-left">用来判断是否是空列表的谓词</td>
</tr>

<tr>
<td class="org-left"><code>cons</code></td>
<td class="org-left">用来创建列表的构造函数</td>
</tr>

<tr>
<td class="org-left"><code>first</code></td>
<td class="org-left">用来提取出最后添加的项的选择器</td>
</tr>

<tr>
<td class="org-left"><code>rest</code></td>
<td class="org-left">用来提取剩下的列表的选择器</td>
</tr>

<tr>
<td class="org-left"><code>cons?</code></td>
<td class="org-left">用来判断是否是 <code>cons</code> 的实例的谓词</td>
</tr>
</tbody>
</table>

<p>
由于列表的定义是自引用的，因此对列表的操作函数往往也是自引用的，即递归的。这种由自引用的数据定义导致的递归叫做自然递归(natural recursion)。
</p>

<p>
例如在列表上的搜索：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">List-of-names -&gt; Boolean</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">determines whether "Flatt" occurs on alon</span>
<span style="color: #2aa198;">(</span>check-expect
  <span style="color: #b58900;">(</span>contains-flatt? <span style="color: #268bd2;">(</span>cons <span style="color: #2aa198;">"X"</span> <span style="color: #6c71c4;">(</span>cons <span style="color: #2aa198;">"Y"</span>  <span style="color: #859900;">(</span>cons <span style="color: #2aa198;">"Z"</span> '<span style="color: #b58900;">()</span><span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
  #false<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>check-expect
  <span style="color: #b58900;">(</span>contains-flatt? <span style="color: #268bd2;">(</span>cons <span style="color: #2aa198;">"A"</span> <span style="color: #6c71c4;">(</span>cons <span style="color: #2aa198;">"Flatt"</span> <span style="color: #859900;">(</span>cons <span style="color: #2aa198;">"C"</span> '<span style="color: #b58900;">()</span><span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
  #true<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>contains-flatt? alon<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">cond</span>
    [<span style="color: #268bd2;">(</span>empty? alon<span style="color: #268bd2;">)</span> #false]
    [<span style="color: #268bd2;">(</span>cons? alon<span style="color: #268bd2;">)</span>
     <span style="color: #268bd2;">(</span>or <span style="color: #6c71c4;">(</span>string=? <span style="color: #859900;">(</span>first alon<span style="color: #859900;">)</span> <span style="color: #2aa198;">"Flatt"</span><span style="color: #6c71c4;">)</span>
         <span style="color: #6c71c4;">(</span>contains-flatt? <span style="color: #859900;">(</span>rest alon<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #cb4b16; font-weight: bold;">]</span><span style="color: #b58900; font-weight: bold;">)</span><span style="color: #2aa198; font-weight: bold;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcfdf125" class="outline-3">
<h3 id="orgcfdf125"><span class="section-number-3">3.2</span> 为自引用数据设计函数的方法</h3>
<div class="outline-text-3" id="text-3-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">步骤</td>
<td class="org-left">产出</td>
<td class="org-left">行动</td>
</tr>

<tr>
<td class="org-left">问题分析</td>
<td class="org-left">数据定义</td>
<td class="org-left">为信息开发一个数据表示；为信息的特别项创建例子并把数据解释为信息；指出自引用</td>
</tr>

<tr>
<td class="org-left">头</td>
<td class="org-left">签名、目的、模糊的定义</td>
<td class="org-left">使用定义好的名字写下来签名；描写精确的目的陈述；从特别的范围创建产出特定值的模糊的定义</td>
</tr>

<tr>
<td class="org-left">例子</td>
<td class="org-left">例子和测试</td>
<td class="org-left">做几个例子，数据定义的每个语句至少一个</td>
</tr>

<tr>
<td class="org-left">模板</td>
<td class="org-left">函数模板</td>
<td class="org-left">把数据定义翻译成模板；每个数据语句就有一个条件语句；指向结构体的条件要有选择器；每个自引用一个自然递归</td>
</tr>

<tr>
<td class="org-left">定义</td>
<td class="org-left">详细的函数定义</td>
<td class="org-left">找到能把条件语句中的值和期望的结果组合起来的函数</td>
</tr>

<tr>
<td class="org-left">测试</td>
<td class="org-left">有效的测试</td>
<td class="org-left">把例子变成测试并运行</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgc482e1c" class="outline-4">
<h4 id="orgc482e1c"><span class="section-number-4">3.2.1</span> 定义列表</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
如果问题涉及到了任意大小的数据，那么就需要自引用数据定义来表示它。
一个有效的自引用数据定义包括两个条件，一是它必须至少有两项，二是至少有一项不指代回数据类型自身。
为了检查数据定义得是否正确，需要举出一些例子，只少要写出来三项。
</p>
</div>
</div>
<div id="outline-container-orgb05382c" class="outline-4">
<h4 id="orgb05382c"><span class="section-number-4">3.2.2</span> 签名、目的陈述和函数头</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
没有变化，但写目的陈述时要注意写清楚函数要计算的目的，而不是函数是怎么实现的。
</p>
</div>
</div>
<div id="outline-container-org1dae39c" class="outline-4">
<h4 id="org1dae39c"><span class="section-number-4">3.2.3</span> 函数示例</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
要多写几项，0项、1项、2项等
</p>
</div>
</div>
<div id="outline-container-orgd377d84" class="outline-4">
<h4 id="orgd377d84"><span class="section-number-4">3.2.4</span> 函数模板</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
自引用数据的定义与结构体类似，因此可以用同样的步骤把结构体定义翻译成函数模板，一般来说 <code>cond</code> 语句的数量是一样多的。而且函数的结构与数据的结构应该相同，如果数据里第i项是自引用，函数里第i项也应该是自引用。
</p>

<p>
可以通过回答下面一些问题来指导把数据定义翻译成模板的过程：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">数据定义能否区分数据的不同子类别？</td>
<td class="org-left">模板需要与数据定义区分出的子类别一样多的判断语句</td>
</tr>

<tr>
<td class="org-left">子类之间有什么不同？</td>
<td class="org-left">用不同点来给每个判断语句写条件</td>
</tr>

<tr>
<td class="org-left">有哪个语句处理结构体值了吗？</td>
<td class="org-left">如果有，就给语句增加适当的选择器</td>
</tr>

<tr>
<td class="org-left">数据定义使用自引用了吗？</td>
<td class="org-left">为模板添加与数据定义的自引用对应的自然递归</td>
</tr>

<tr>
<td class="org-left">如果数据定义指向了其它数据定义，指向其它数据定义的交叉引用指向了哪里？</td>
<td class="org-left">使用其它的数据定义对应的模板</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgc75b3c3" class="outline-4">
<h4 id="orgc75b3c3"><span class="section-number-4">3.2.5</span> 实现函数</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
就按照模板把该填上的都填上，使用和示例里给的公式写完函数，然后就是“信仰的飞跃”，函数一定会和我们想的一样工作的，在数学上这是因为归纳法。
</p>

<p>
非递归语句的答案应该在函数示例里自然出现，如果没有就改进示例。
递归语句中的选择器应该在数据定义里给出。
使用函数的目的陈述觉得递归的值，而不是如何计算这个值，如果目的陈述没有给出这个值，就应该改进目的陈述。
</p>

<p>
如果哪里卡住了，就把函数示例组合排列一下。
如果递归需要其它的未完成的辅助函数或递归的模板，就假设函数已经完成了，直接使用函数的结果即可。
</p>
</div>
</div>
</div>
<div id="outline-container-org904dfb7" class="outline-3">
<h3 id="org904dfb7"><span class="section-number-3">3.3</span> 集合</h3>
<div class="outline-text-3" id="text-3-3">
<p>
集合和列表的区别在于集合中一个元素只能出现一次，而且是无序的。
集合不是必须的基本类型，可以由列表代替实现。
</p>
</div>
</div>
<div id="outline-container-orgb33d247" class="outline-3">
<h3 id="orgb33d247"><span class="section-number-3">3.4</span> 通过组合进行设计</h3>
<div class="outline-text-3" id="text-3-4">
<p>
程序是一系列定义的集合：结构类型定义、数据定义、常量定义和函数定义。指导设计的原则是：
</p>

<p>
为每个任务设计一个函数。为问题中量之间的每个依赖关系写一个辅助函数定义。
</p>

<p>
这部分的另一个对辅助函数的指导意见是：
</p>

<p>
为每个数据定义设计一个函数模板。当一个数据定义指向另一个数据定义时写一个辅助函数定义。
</p>

<p>
复杂的问题需要分解为单独的问题。 分解问题时，需要两部分：解决单独问题的函数和将这些分开的函数组合为一个函数的数据定义。 为了确保您在花了很多时间在单独的程序上之后，函数组合可以正常工作，您需要制定愿望清单以及所需的数据定义。
</p>

<p>
分解-组合设计方法对于问题陈述显式或隐式提及辅助任务的情况、和对需要与其它任意大的数据交互的函数的编码都很有用
</p>

<p>
而一般的问题有时候比解决问题陈述中描述的特定问题更容易。
</p>
</div>
</div>
</div>
<div id="outline-container-org0696fbf" class="outline-2">
<h2 id="org0696fbf"><span class="section-number-2">4</span> 设计与使用抽象的通用函数</h2>
<div class="outline-text-2" id="text-4">
<p>
抽象的目的是消除重复，本质上就是把相似的部分用参数代替。
</p>
</div>
<div id="outline-container-org944938b" class="outline-3">
<h3 id="org944938b"><span class="section-number-3">4.1</span> 设计抽象</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org39dd60d" class="outline-4">
<h4 id="org39dd60d"><span class="section-number-4">4.1.1</span> 设计步骤</h4>
<div class="outline-text-4" id="text-4-1-1">
<ol class="org-ol">
<li>比较相似处:函数定义的某处相似就标记这个位置，如果多处相似，就把相似的东西写到同一行里。</li>
<li>进行抽象:进行抽象就是把有关联的相似的部分用新名字替代。</li>
<li>测试：测试时要保证被抽象的原始函数都通过测试。</li>
<li>签名:抽象时引入的新参量需要对应的合适的签名，也就是类型。</li>
</ol>
</div>
</div>

<div id="outline-container-org3341c8f" class="outline-4">
<h4 id="org3341c8f"><span class="section-number-4">4.1.2</span> 设计通用签名</h4>
<div class="outline-text-4" id="text-4-1-2">
<ol class="org-ol">
<li>比较两个相似的函数定义，找到签名中的相似处，并做标记。</li>
<li>设计函数的抽象，引入新的参数，并给抽象后的函数创建签名</li>
<li>检查函数的抽象是否影响到了签名，把签名的不同部分提出来</li>
<li>测试抽象的签名能否回到原来的样子</li>
</ol>

<p>
例：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">[List-of Number] -&gt; [List-of Number]</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">[List-of String] -&gt; [List-of String]</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">&#21464;&#25104;</span>
<span style="color: #93a1a1;">; </span><span style="color: #93a1a1;">[X Y] [List-of X] -&gt; [List-of Y]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3727b9b" class="outline-3">
<h3 id="org3727b9b"><span class="section-number-3">4.2</span> 使用抽象函数进行设计</h3>
<div class="outline-text-3" id="text-4-2">
<p>
这是关于如何在设计实现函数时利用已有的抽象函数的方法。
</p>

<ol class="org-ol">
<li>遵循设计函数的前三步：把问题陈述变成签名、目的陈述、例子和占位代码</li>
<li>利用签名和目的陈述得到匹配的抽象：即抽象的目的比函数的目的更一般，可以先考虑抽象的函数应该得到一个更一般的输出。</li>
<li>写函数模板：为了能重用抽象要使用局部定义（~local~ ）。目的有二，一是要标记对什么进行了抽象，二是要定义辅助函数的签名、目的和头等。</li>
<li>实现局部定义的辅助函数。</li>
<li>测试。</li>
</ol>
</div>
</div>

<div id="outline-container-org2b4b76e" class="outline-3">
<h3 id="org2b4b76e"><span class="section-number-3">4.3</span> 无名函数 Lambda</h3>
<div class="outline-text-3" id="text-4-3">
<p>
函数也是值，它们也能表示信息。
</p>

<p>
一般定义值的集合的方法是列出所有可能的元素，也可以使用函数的方法，定义一个能判断某值是否在集合中的函数，这样这个函数就代表了这个集合本身。
</p>
</div>
</div>
</div>
<div id="outline-container-org9a64d93" class="outline-2">
<h2 id="org9a64d93"><span class="section-number-2">5</span> 设计互引用数据类型与函数</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org86d3929" class="outline-3">
<h3 id="org86d3929"><span class="section-number-3">5.1</span> 使用相互引用的数据进行设计</h3>
<div class="outline-text-3" id="text-5-1">
<p>
与自引用的数据设计方法类似。
</p>
<ol class="org-ol">
<li>问题陈述中提到了需要其它类型的数据时，就需要相互引用的数据类型了。同样要标记出引用其它数据的部分。创建示例时要从不包括任何数据的子句开始构造，确保能够按照设计的方式创建示例。</li>
<li>关键的变化是需要创建与数据定义一样多的函数，每个函数只处理一个数据类型，剩下的部分都一样，要创建签名、目的陈述和函数头。</li>
<li>处理示例，特别是数据定义中相互引用的部分。</li>
<li>为每个函数设计模板。把数据定义中相互引用的部分转化成函数的相互调用。</li>
<li>实现函数。从那些不含引用的条件分支开始，然后再处理相互引用的分支。</li>
<li>测试。如果有问题，会出现两个错误，一个在主函数里，一个在辅助函数里，应该通过一个地方的修改就能解决它。</li>
</ol>
</div>
</div>

<div id="outline-container-org2371dce" class="outline-3">
<h3 id="org2371dce"><span class="section-number-3">5.2</span> 设计处理多个复杂参数的函数</h3>
<div class="outline-text-3" id="text-5-2">
<p>
与那些只处理一个参数的函数的设计方法没什么区别。只是会遇到下面三种情况：
</p>
<ol class="org-ol">
<li>如果一个参数起主导作用，就把另一个参数当作原子类型。</li>
<li>如果两个参数的类型或大小必须一样，需要同步的处理它们，那么就选择一个参数，围绕它组织函数，并同时遍历另一个参数。</li>
<li>如果两个参数之间没有明显关系，就必须用例子分析所有可能的情况，列出一个二维的表格来实现函数模板</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgf0e7264" class="outline-2">
<h2 id="orgf0e7264"><span class="section-number-2">6</span> 生成递归与算法</h2>
<div class="outline-text-2" id="text-6">
<p>
对于复杂的问题，依赖数据类型的结构递归不能解决问题，需要使用生成递归，也就是算法来解决问题。
结构递归和生成递归的区别在于一个依赖于系统特定的数据结构，另一个不依赖数据结构而是需要对问题本质的洞察和数学能力。
遇到问题时通常应该选择结构递归方法，这更简单，效率也可接受。只有当结构递归真的很慢或无法解决时才应该考虑生成递归。差的生成递归设计甚至比结构递归还慢。
</p>
</div>
<div id="outline-container-orga635e6a" class="outline-3">
<h3 id="orga635e6a"><span class="section-number-3">6.1</span> 设计算法</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org348ff57" class="outline-4">
<h4 id="org348ff57"><span class="section-number-4">6.1.1</span> 设计步骤</h4>
<div class="outline-text-4" id="text-6-1-1">
<ol class="org-ol">
<li>和之前一样得把问题信息表示为数据。不同的数据表示方法会影响对计算过程的思考，所以需要考虑一个合适的表示方法。</li>
<li>我们仍然需要签名、函数头和目的陈述。因为生成递归与数据定义没关系，所以目的陈述及要说明函数计算了什么，还要说怎么计算。</li>
<li>解释如何计算函数示例会有用的。结构递归中的例子只说明了要得到的结果，生成递归则要解释计算过程背后的想法。</li>
<li>为算法设计模板。粗略地说，设计算法要区分两种问题：一种是很平凡可解的问题和不那么平凡的问题。如果给定的问题容易求解（空列表），算法就是产出相应的解。对于复杂的问题（有很多项的列表），算法通常要生成对于给定的问题相同的问题，递归地求解它们，然后把解组合起来。</li>
<li>实现函数，需要解决以下几个问题：
<ol class="org-ol">
<li>什么是平凡就能求解的问题</li>
<li>怎么求解平凡的问题</li>
<li>算法如何产生一个比原来问题容易解决的新问题。产生的新问题有多少个。</li>
<li>给定问题的解和新问题的解一样吗。或者，是否需要把结果组合起来得到原问题的解。如果需要组合，从原问题的数据中是否需要什么东西</li>
</ol></li>
<li>测试。</li>
</ol>

<p>
通用函数模板：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>generative-recursive-fun problem<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">cond</span>
   [<span style="color: #268bd2;">(</span>trivially-solvable? problem<span style="color: #268bd2;">)</span>
    <span style="color: #268bd2;">(</span>determine-solution problem<span style="color: #268bd2;">)</span>]
   [else
    <span style="color: #268bd2;">(</span>combine-solutions
     ... problem ...
     <span style="color: #6c71c4;">(</span>generative-recursive-fun
      <span style="color: #859900;">(</span>generate-problem-1 problem<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span>
     ...
     <span style="color: #6c71c4;">(</span>generative-recursive-fun
      <span style="color: #859900;">(</span>generate-problem-n problem<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #cb4b16; font-weight: bold;">]</span><span style="color: #b58900; font-weight: bold;">)</span><span style="color: #2aa198; font-weight: bold;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org14f4134" class="outline-4">
<h4 id="org14f4134"><span class="section-number-4">6.1.2</span> 终止</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
在数据结构上递归，数据总是越来越小，总会停止。
但是对于生成递归，有可能不停止，进入无限循环。
所以需要增加一些限制确保递归能够停止。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">步骤</th>
<th scope="col" class="org-left">产出</th>
<th scope="col" class="org-left">行动</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">问题分析</td>
<td class="org-left">数据表示和定义</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">头</td>
<td class="org-left">目的陈述，包括如何计算</td>
<td class="org-left">解释函数计算什么和如何计算出结果</td>
</tr>

<tr>
<td class="org-left">例子</td>
<td class="org-left">例子和测试</td>
<td class="org-left">用计算方法处理几个例子</td>
</tr>

<tr>
<td class="org-left">模板</td>
<td class="org-left">固定的模板</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">定义</td>
<td class="org-left">实现函数</td>
<td class="org-left">平凡可解问题的条件；平凡情况的答案；确定如何为非平凡问题生成新的问题；使用辅助函数；确定如何把生成的问题的解组合成原问题的解</td>
</tr>

<tr>
<td class="org-left">测试</td>
<td class="org-left">发现问题</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">终止</td>
<td class="org-left">1.每个递归调用的大小限制，或2.期望终止的例子</td>
<td class="org-left">调查问题的数据是否会每个递归越来越小；找到让函数停止的例子</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-org887ead4" class="outline-2">
<h2 id="org887ead4"><span class="section-number-2">7</span> 带有累加器的递归函数</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org08409b1" class="outline-3">
<h3 id="org08409b1"><span class="section-number-3">7.1</span> 设计有累加器的函数</h3>
<div class="outline-text-3" id="text-7-1">
<p>
在递归中会发生信息的损失，这使得只能解决上下文无关的问题，对依赖背景知识的问题需要设计还有累加器的函数。
同时有累加器的递归函数也是尾递归函数，可以提高运行速度。
</p>
</div>
<div id="outline-container-orgecadda1" class="outline-4">
<h4 id="orgecadda1"><span class="section-number-4">7.1.1</span> 认识到需要累加器</h4>
<div class="outline-text-4" id="text-7-1-1">
<ol class="org-ol">
<li>如果结构递归函数使用辅助递归函数遍历自然递归的结果，就需要累加器参数。</li>
<li>对生成递归函数更难判断，需要指导算法能否为输入提供我们想要的结果。</li>
</ol>
</div>
</div>
<div id="outline-container-orgae416b5" class="outline-4">
<h4 id="orgae416b5"><span class="section-number-4">7.1.2</span> 添加累加器</h4>
<div class="outline-text-4" id="text-7-1-2">
<ol class="org-ol">
<li>确定累加器所要表示的信息，使用哪种数据，以及信息是怎样作为数据被使用的
<ol class="org-ol">
<li>创建一个累加器模板。简述一个函数的手动计算值来理解累加器的本质</li>
<li>确定累加器记录的信息。写一句话表达累加器作为辅助函数的参数和原参数之间的关系，这个关系是不变的，也叫做不变量</li>
<li>使用不变量得到辅助函数的初参数</li>
<li>使用不变量确定如何为辅助函数中的递归调用计算累加器的值</li>
</ol></li>
<li>为设计辅助函数使用累加器的知识。对结构递归函数，累加器的值一般用作非递归的基本语句里。对生成递归函数，累加器的值用作已有的基本语句里、新的基本语句里或递归语句里都可能。</li>
</ol>

<p>
关键就是精确描述累加器的作用。
</p>

<p>
累加器模板
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">Domain -&gt; Range </span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>function d0<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>local <span style="color: #268bd2;">(</span><span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">Domain AccuDomain -&gt; Range</span>
          <span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">accumulator ...</span>
          <span style="color: #6c71c4;">(</span>define <span style="color: #859900;">(</span>function/a d a<span style="color: #859900;">)</span>
            ...<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
         <span style="color: #268bd2;">(</span>function/a d0 a0<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org75a3b23" class="outline-4">
<h4 id="org75a3b23"><span class="section-number-4">7.1.3</span> 把函数翻译成累加器版本</h4>
<div class="outline-text-4" id="text-7-1-3">
<p>
清楚的表达累加器的作用很困难。所以需要自己练习。
</p>

<p>
从累加器陈述中得到
</p>
<ol class="org-ol">
<li>累加器的初值</li>
<li>如何在迭代中维护它</li>
<li>如何利用累加器的知识</li>
</ol>
</div>
</div>
<div id="outline-container-orgb7a2c46" class="outline-4">
<h4 id="orgb7a2c46"><span class="section-number-4">7.1.4</span> 例子：求和函数</h4>
<div class="outline-text-4" id="text-7-1-4">
<p>
求和函数，普通递归版本
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">List-of-Number -&gt; Number</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>sum l<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">cond</span>
   [<span style="color: #268bd2;">(</span>empty? l<span style="color: #268bd2;">)</span> 0]
   [else <span style="color: #268bd2;">(</span>+ <span style="color: #6c71c4;">(</span>first l<span style="color: #6c71c4;">)</span>
            <span style="color: #6c71c4;">(</span>sum <span style="color: #859900;">(</span>rest l<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #cb4b16; font-weight: bold;">]</span><span style="color: #b58900; font-weight: bold;">)</span><span style="color: #2aa198; font-weight: bold;">)</span>
</pre>
</div>

<p>
求和函数，累加器版本
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">List-of-Number -&gt; Number</span>
<span style="color: #2aa198;">(</span>define <span style="color: #b58900;">(</span>sum l0<span style="color: #b58900;">)</span>
  <span style="color: #b58900;">(</span>local <span style="color: #268bd2;">(</span><span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">[List-of-Number, Number] -&gt; Number</span>
          <span style="color: #93a1a1;">;; </span><span style="color: #93a1a1;">accumulator</span>
          <span style="color: #6c71c4;">(</span>define <span style="color: #859900;">(</span>sum/a l a<span style="color: #859900;">)</span>
            <span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">cond</span>
             [<span style="color: #b58900;">(</span>empty? l<span style="color: #b58900;">)</span> a]
             [else <span style="color: #b58900;">(</span>sum/a <span style="color: #268bd2;">(</span>rest l<span style="color: #268bd2;">)</span>
                          <span style="color: #268bd2;">(</span>+ <span style="color: #6c71c4;">(</span>first l<span style="color: #6c71c4;">)</span> a<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #cb4b16; font-weight: bold;">]</span><span style="color: #859900; font-weight: bold;">)</span><span style="color: #6c71c4; font-weight: bold;">)</span><span style="color: #268bd2; font-weight: bold;">)</span>
         <span style="color: #268bd2;">(</span>sum/a l0 0<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
可以看到累加器版本积累了所有的运算结果，所以递归不需回溯就能返回结果，运算速度更快了。
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-09-27 Sun 17:23</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
