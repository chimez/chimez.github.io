<!doctype html>
<html lang="zh-cn">
	<head>
		<!-- Required meta tags -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

		<!-- Template -->
		<link rel="Stylesheet" type="text/css" href="../css/main.css" />
		<title>re-frame</title>
	</head>

	<body>
		<div class="container">

			<nav class="navbar navbar-expand-lg sticky-top navbar-light bg-light">
				<a class="navbar-brand" href="../index.html">Chimez</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>

				<div class="collapse navbar-collapse" id="navbarTogglerDemo02">
					<ul class="navbar-nav mr-auto mt-2 mt-lg-0">
						<li class="nav-item active">
							<a class="nav-link" href="../articles_index.html">文章列表 <span class="sr-only">(current)</span></a>
					</ul>
					<form class="form-inline my-2 my-lg-0">
						<input class="form-control mr-sm-2" type="search" placeholder="Search">
						<button class="btn btn-outline-success my-2 my-sm-0" type="button">Search</button>
					</form>
				</div>
			</nav>

			<div class="row">
				
<p>
<div class="col-md-3 article-toc d-none d-md-block">
</p>
<div id="Contents" class="toc"><h1 id="Contents">Contents</h1></div>
<ul>
<li>
<a href="re-frame.html#re-frame">re-frame</a>

<ul>
<li>
<a href="re-frame.html#re-frame-安装与原理">安装与原理</a>

<ul>
<li>
<a href="re-frame.html#re-frame-安装与原理-加入依赖">加入依赖</a>

<li>
<a href="re-frame.html#re-frame-安装与原理-设计思想">设计思想</a>

</ul>
<li>
<a href="re-frame.html#re-frame-基本使用">基本使用</a>

<ul>
<li>
<a href="re-frame.html#re-frame-基本使用-app-db应用状态设计">app-db应用状态设计</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第一步：定义事件">第一步：定义事件</a>

<ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第一步：定义事件-事件的数据结构">事件的数据结构</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第一步：定义事件-dispatch 发送事件">dispatch 发送事件</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第一步：定义事件-dispatch原理，事件队列的实现">dispatch原理，事件队列的实现</a>

</ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数">第二步：为每个事件编写并注册事件处理函数</a>

<ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-事件处理函数">事件处理函数</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-注册事件处理函数">注册事件处理函数</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-例子">例子</a>

</ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第三步：效应处理">第三步：效应处理</a>

<ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第三步：效应处理-reg-event-fx:可以产生副作用的事件绑定">reg-event-fx:可以产生副作用的事件绑定</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第三步：效应处理-reg-fx：定义效应处理函数">reg-fx：定义效应处理函数</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第三步：效应处理-do-fx:执行一个副作用">do-fx:执行一个副作用</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第三步：效应处理-reg-cofx与inject-cofx：初始化应用时执行副作用">reg-cofx与inject-cofx：初始化应用时执行副作用</a>

</ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第四步：订阅处理&#47;查询函数">第四步：订阅处理/查询函数</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第五步：视图函数，Reagent">第五步：视图函数，Reagent</a>

<ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第五步：视图函数，Reagent-subscribe定义查询量">subscribe定义查询量</a>

<li>
<a href="re-frame.html#re-frame-基本使用-第五步：视图函数，Reagent-定义视图函数（Reagent组件）">定义视图函数（Reagent组件）</a>

</ul>
<li>
<a href="re-frame.html#re-frame-基本使用-第六步：DOM与运行循环">第六步：DOM与运行循环</a>

</ul>
<li>
<a href="re-frame.html#re-frame-其他事项">其他事项</a>

<ul>
<li>
<a href="re-frame.html#re-frame-其他事项-推荐的项目结构">推荐的项目结构</a>

<li>
<a href="re-frame.html#re-frame-其他事项-拦截器, interceptors">拦截器, interceptors</a>

</ul>
</ul>
</ul>

<p>
</div>
<div class="col-md-9 article-main">
</p>
<div id="re-frame"><h1 id="re-frame">re-frame</h1></div>
<p>
re-frame是基于reagent的用于创建单页应用的函数式框架
</p>
<div id="re-frame-安装与原理"><h2 id="安装与原理">安装与原理</h2></div>
<div id="re-frame-安装与原理-加入依赖"><h3 id="加入依赖">加入依赖</h3></div>
<pre class="clojure">
[reagent "0.8.0-alpha2"]
[re-frame "0.10.1"]
</pre>
<div id="re-frame-安装与原理-设计思想"><h3 id="设计思想">设计思想</h3></div>
<p>
re-frame采用事件驱动，在主循环里分为六个连续的部分
</p>
<ol>
<li>
事件发生：定义组件上能产生的事件并构造事件信息

<li>
事件处理：绑定事件和处理函数

<li>
效果处理：执行事件处理函数改变应用状态

<li>
查询：获取当前状态对应的信息

<li>
视图：展示/更新组件，reagent

<li>
DOM：由react完成，操作DOM

</ol>

<div id="re-frame-基本使用"><h2 id="基本使用">基本使用</h2></div>
<p>
这里介绍构建单页应用的基本流程，以<code>example/simple</code>为例，动态显示一个数字时钟，并可以改变颜色
</p>
<div id="re-frame-基本使用-app-db应用状态设计"><h3 id="app-db应用状态设计">app-db应用状态设计</h3></div>
<p>
在这个例子中，只有两个状态：要显示的时间和时钟颜色
<code>app-db</code>应包括以下内容:
</p>
<pre class="clojure">
{:time       (js/Date.)  ;; current time for display
 :time-color "=f88"}     ;; the colour in which the time should be shown=
</pre>
<p>
&gt; 在re-frame中，应用状态由框架自己进行管理，并称为app-db，类似一个内存数据库，创建app-db在第二步中进行
</p>

<div id="re-frame-基本使用-第一步：定义事件"><h3 id="第一步：定义事件">第一步：定义事件</h3></div>
<div id="re-frame-基本使用-第一步：定义事件-事件的数据结构"><h4 id="事件的数据结构">事件的数据结构</h4></div>
<p>
在re-frame中事件是一个单纯的数据,不会把回调函数放进去，用向量来表示，第一项是符号，说明事件的类型，之后的东西都是可选的，可以为事件提供详细信息,下面是一些例子：
</p>
<pre class="clojure">
[:delete-item 42]
[:admit-to-being-satoshi false]
[:dressing/put-pants-on  "velour flares" {:method :left-leg-first :belt false}]
</pre>
<div id="re-frame-基本使用-第一步：定义事件-dispatch 发送事件"><h4 id="dispatch 发送事件">dispatch 发送事件</h4></div>
<p>
使用re-frame/dispatch 函数来发送一个事件
</p>
<pre class="clojure">
   (rf/dispatch [:event-id  value1 value2])

</pre>
<p>
在任何函数里对dispatch求值就发送了一个事件
</p>
<pre class="clojure">
(defn dispatch-timer-event
  []
  (let [now (js/Date.)]
    (rf/dispatch [:timer now])))  ;; &lt;-- dispatch used

;; call the dispatching function every second
(defonce do-timer (js/setInterval dispatch-timer-event 1000))

</pre>

<div id="re-frame-基本使用-第一步：定义事件-dispatch原理，事件队列的实现"><h4 id="dispatch原理，事件队列的实现">dispatch原理，事件队列的实现</h4></div>
<p>
调用dispatch会把事件放进消息队列里，由router对队列里的事件进行处理，因此事件是异步的
router和事件队列由re-frame内部实现，自己只需要定义事件处理函数并注册它，就可以了
router的功能：
</p>
<ol>
<li>
检查事件向量的第一个元素

<li>
查询哪个事件处理函数来处理这个事件

<li>
调用这个事件处理函数

</ol>

<div id="re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数"><h3 id="第二步：为每个事件编写并注册事件处理函数">第二步：为每个事件编写并注册事件处理函数</h3></div>
<p>
在这个应用里有三个事件<code>:intitalize :time-color-change :timer</code>,所以要写三个事件处理函数
</p>
<div id="re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-事件处理函数"><h4 id="事件处理函数">事件处理函数</h4></div>
<p>
事件处理函数输入两个参数<code>coeffects event</code>即应用状态和事件，返回<code>effects</code>即状态要发生的改变,结构如下
</p>
<pre class="clojure">
(def fun [db event]
  {:a "new a"
   :b "new b"})
</pre>
<div id="re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-注册事件处理函数"><h4 id="注册事件处理函数">注册事件处理函数</h4></div>
<p>
re-frame提供了两个注册函数<code>reg-event-fx, reg-event-db</code>，前者处理多个<code>coeffects</code>返回多个<code>effects</code>,后者只处理一个，更简单
<code>reg-event-db</code>格式如下
</p>
<pre class="clojure">
(rf/reg-event-db
  :the-event-id
  the-event-handler-fn)
</pre>

<div id="re-frame-基本使用-第二步：为每个事件编写并注册事件处理函数-例子"><h4 id="例子">例子</h4></div>
<ol>
<li>
更新状态使用<code>-&gt;</code>宏和<code>assoc</code>函数

<li>
忽略参数使用下划线

<li>
可以对<code>event</code>向量直接解构

</ol>

<pre class="clojure">
(rf/reg-event-db              ;; sets up initial application state
  :initialize
  (fn [_ _]                   ;; the two parameters are not important here, so use _
    {:time (js/Date.)         ;; What it returns becomes the new application state
     :time-color "=f88"}))    ;; so the application state will initially be a map with two keys=

(rf/reg-event-db
  :initialize
  (fn [db _]                 ;; we use db this time, so name it
    (-&gt; db
      (assoc :time (js/Date.))
      (assoc :time-color "=f88")))=

(rf/reg-event-db                 ;; usage:  (rf/dispatch [:timer a-js-Date])
  :timer
  (fn [db [_ new-time]]          ;; &lt;-- de-structure the event vector
    (assoc db :time new-time)))  ;; compute and return the new application state

(rf/reg-event-db
  :time-color-change            ;; usage:  (rf/dispatch [:time-color-change 34562])
  (fn [db [_ new-color-value]]
    (assoc db :time-color new-color-value)))   ;; compute and return the new application state

</pre>

<div id="re-frame-基本使用-第三步：效应处理"><h3 id="第三步：效应处理">第三步：效应处理</h3></div>
<p>
对于只是更新应用状态的简单的效应，re-frame自动进行处理，不需要写程序。
对于其他副作用，需要编写处理函数。
常见的副作用有：Ajax，数据库，服务器通信等。
</p>

<div id="re-frame-基本使用-第三步：效应处理-reg-event-fx:可以产生副作用的事件绑定"><h4 id="reg-event-fx:可以产生副作用的事件绑定">reg-event-fx:可以产生副作用的事件绑定</h4></div>
<p>
与<code>reg-event-db</code>相比，<code>-fx</code>可以自己指定效应函数，语法为：
</p>
<pre class="clojure">
(reg-event-fx              ;; -fx registration, not -db registration
  :my-event
  (fn [cofx [_ a]]        ;; 1st argument is coeffects, instead of db
    {:db       (assoc (:db cofx) :flag  a)
     :dispatch [:do-something-else 3]}))   ;; return effects
</pre>

<div id="re-frame-基本使用-第三步：效应处理-reg-fx：定义效应处理函数"><h4 id="reg-fx：定义效应处理函数">reg-fx：定义效应处理函数</h4></div>
<p>
效应函数只有一个输入值，以db这一内置效应函数为例，语法为：
</p>
<pre class="clojure">
(reg-fx
  :db
  (fn [value]
    (reset! re-frame.db/app-db value)))
</pre>

<p>
&gt; 可以看出<code>reg-event-db</code>只不过是一种常用的副作用函数
</p>

<div id="re-frame-基本使用-第三步：效应处理-do-fx:执行一个副作用"><h4 id="do-fx:执行一个副作用">do-fx:执行一个副作用</h4></div>
<pre class="clojure">
(reg-event-fx
  :some-id
  [debug (path :right)]     ;; &lt;-- two interceptors, apparently
  (fn [cofx _]
     {})                    ;; &lt;-- imagine returned effects here

[do-fx debug (path :right)]

</pre>

<div id="re-frame-基本使用-第三步：效应处理-reg-cofx与inject-cofx：初始化应用时执行副作用"><h4 id="reg-cofx与inject-cofx：初始化应用时执行副作用">reg-cofx与inject-cofx：初始化应用时执行副作用</h4></div>
<p>
<code>reg-cofx</code>与<code>inject-cofx</code>能够在应用刚刚启动时执行副作用
</p>


<div id="re-frame-基本使用-第四步：订阅处理&#47;查询函数"><h3 id="第四步：订阅处理&#47;查询函数">第四步：订阅处理/查询函数</h3></div>
<p>
查询函数的输入值是应用状态，返回值是查询量的值，每一次应用状态发生改变就执行一遍查询函数，由于查询之间的关系，可以创建一个查询树，根是<code>app-db</code>叶子是视图组件的数值
使用<code>re-frame/reg-sub</code>注册查询函数：
</p>
<pre class="clojure">
(rf/reg-sub
  :some-query-id  ;; query id (used later in subscribe)
  a-query-fn)     ;; the function which will compute the query

</pre>
<p>
简单的例子：
</p>
<pre class="clojure">
(rf/reg-sub
  :time
  (fn [db _]     ;; db is current app state. 2nd unused param is query vector
    (:time db))) ;; return a query computation over the application state

(rf/reg-sub
  :time-color
  (fn [db _]
    (:time-color db)))
</pre>

<div id="re-frame-基本使用-第五步：视图函数，Reagent"><h3 id="第五步：视图函数，Reagent">第五步：视图函数，Reagent</h3></div>
<div id="re-frame-基本使用-第五步：视图函数，Reagent-subscribe定义查询量"><h4 id="subscribe定义查询量">subscribe定义查询量</h4></div>
<p>
只有一个全局的函数来定义在视图中显示量<code>re-frame/subscribe</code>，只有一个包含查询量id的向量作为参数，返回值是一个ratom，使用@取出值，（来自Reagent）
语法为：
</p>
<pre class="clojure">
(rf/subscribe  [query-id some optional query parameters])

</pre>
<p>
可以将它想象成一个SQL查询
</p>
<div id="re-frame-基本使用-第五步：视图函数，Reagent-定义视图函数（Reagent组件）"><h4 id="定义视图函数（Reagent组件）">定义视图函数（Reagent组件）</h4></div>
<p>
语法与Reagent相同，只不过是加入了定义查询量的<code>subscribe</code>和定义事件的<code>dispatch</code>
例子：
</p>
<pre class="clojure">
(defn clock
  []
  [:div.example-clock
   {:style {:color @(rf/subscribe [:time-color])}}
   (-&gt; @(rf/subscribe [:time])
       .toTimeString
       (clojure.string/split " ")
       first)])

(defn color-input
  []
  [:div.color-input
   "Time color: "
   [:input {:type "text"
            :value @(rf/subscribe [:time-color])        ;; subscribe
            :on-change =(rf/dispatch [:time-color-change (-&gt; % .-target .-value)])}]])  ;; &lt;---=

</pre>

<p>
&gt; 由于组件间可以继承通信，所以只需要在几个组件里有<code>subscribe</code>就足够了
&gt; 不要在组件中直接访问<code>app-db</code>,数据只能通过<code>subscrube</code>传递
</p>

<div id="re-frame-基本使用-第六步：DOM与运行循环"><h3 id="第六步：DOM与运行循环">第六步：DOM与运行循环</h3></div>
<p>
由于DOM是由Reagent实现的，所以只需要触发初始化事件并选一个节点渲染开始就可以了
</p>
<pre class="clojure">
(defn ^:export run
  []
  (rf/dispatch-sync [:initialize]) ;; puts a value into application state
  (reagent/render [ui]             ;; mount the application's ui into '&lt;div id="app" /&gt;'
                  (js/document.getElementById "app")))
</pre>

<div id="re-frame-其他事项"><h2 id="其他事项">其他事项</h2></div>
<div id="re-frame-其他事项-推荐的项目结构"><h3 id="推荐的项目结构">推荐的项目结构</h3></div>
<p>
开发顺序:
</p>
<ol>
<li>
设计数据结构,<code>db.cljs</code>

<li>
设计视图,<code>views.vljs</code>

<li>
写事件处理函数,<code>events.cljs</code>

<li>
写数据提取函数,<code>subs.cljs</code>

</ol>

<p>
}}}
src
├── core.cljs   &lt;--- entry point, plus history
├── db.cljs     &lt;--- data related  (data layer)
├── subs.cljs   &lt;--- subscription handlers  (query layer)
├── views.cljs  &lt;--- reagent  components (view layer)
└── events.cljs &lt;--- event handlers (control/update layer)
</p>

<p>
}}}
</p>


<div id="re-frame-其他事项-拦截器, interceptors"><h3 id="拦截器, interceptors">拦截器, interceptors</h3></div>

		</div>
		<nav class="navbar">
			<span class="navbar-text">
				Page created on 2018-01-31
			</span>
		</nav>

	</div>

	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- highlight.js -->
	<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
	<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
	<script>
		$(document).ready(function() {
			$('pre').each(function(i, block) {
				hljs.highlightBlock(block);
			});
			$('.article-toc ul li ul li ul li ul').hide();
		});
	</script>
	<!-- MathJax -->
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" src="../js/search.js"></script>
</body>
</html>
