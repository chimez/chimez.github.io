<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-27 Sun 17:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>clojure</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="chimez" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">clojure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org22eef14">1. Clojure学习笔记</a>
<ul>
<li><a href="#org848d015">1.1. 基本语法</a>
<ul>
<li><a href="#orge2a041a">1.1.1. 基本要素</a></li>
<li><a href="#orgde44934">1.1.2. 函数</a></li>
<li><a href="#orge2af345">1.1.3. 局部和闭包</a></li>
<li><a href="#org04c4abb">1.1.4. Java 互操作</a></li>
<li><a href="#orgb2a16b7">1.1.5. 顺序集合</a></li>
<li><a href="#org5d03df3">1.1.6. 哈希集合</a></li>
<li><a href="#orgb128ea5">1.1.7. 流程控制</a></li>
<li><a href="#org5935f1e">1.1.8. 异常</a></li>
<li><a href="#orgb339a08">1.1.9. 宏</a></li>
<li><a href="#org48f7fc2">1.1.10. 常用的函数和宏</a></li>
</ul>
</li>
<li><a href="#org80fa7de">1.2. 高级语法</a>
<ul>
<li><a href="#org9f7ca71">1.2.1. 自定义数据类型 Datatypes</a></li>
<li><a href="#org217aa7b">1.2.2. Sequences 算法系列</a></li>
<li><a href="#orgbe1022e">1.2.3. 临时数据结构：用可变数据进行优化</a></li>
<li><a href="#org7b4c378">1.2.4. 转换器：将变换算法组合起来</a></li>
<li><a href="#org26bc45a">1.2.5. 多重方法和层级：运行时多态的方法</a></li>
<li><a href="#orgf8f7042">1.2.6. 协议：对接口进行抽象</a></li>
<li><a href="#org4804578">1.2.7. 元数据：表达数据类型信息</a></li>
<li><a href="#org1f9af8f">1.2.8. 命名空间与使用库</a></li>
<li><a href="#org531cf8a">1.2.9. 改变值</a></li>
<li><a href="#org6458291">1.2.10. reducer：从旧态到新态</a></li>
<li><a href="#org05b0d93">1.2.11. Java互操作</a></li>
<li><a href="#orgfd5311b">1.2.12. 编译成Class</a></li>
</ul>
</li>
<li><a href="#org6a4e01b">1.3. 内置库</a>
<ul>
<li><a href="#orgecec189">1.3.1. Java工具库</a></li>
<li><a href="#org53943bd">1.3.2. clojure.reflect:反射信息</a></li>
<li><a href="#orgac3eb87">1.3.3. clojure.repl:REPL有用的工具</a></li>
<li><a href="#orgefe6dff">1.3.4. clojure.set:set相关算法</a></li>
<li><a href="#orgfd8f6d4">1.3.5. clojure.string:处理字符串</a></li>
<li><a href="#orgbbfc852">1.3.6. clojure.test:单元测试框架</a></li>
<li><a href="#orgb0a8277">1.3.7. clojure.walk:遍历和操作最近数据结构</a></li>
<li><a href="#org44cf905">1.3.8. clojure.xml:xml处理</a></li>
<li><a href="#org8e387c6">1.3.9. clojure.zip:纯函数的树编辑</a></li>
<li><a href="#org3f326b9">1.3.10. 依赖处理与命令行工具</a></li>
</ul>
</li>
<li><a href="#org9d20f52">1.4. 相关项目</a>
<ul>
<li><a href="#org1a8b247">1.4.1. ring</a></li>
<li><a href="#org46fc7ef">1.4.2. compojure</a></li>
<li><a href="#org3d13540">1.4.3. enlive</a></li>
<li><a href="#orgf3da48f">1.4.4. hiccup</a></li>
</ul>
</li>
<li><a href="#org8011861">1.5. leiningen:依赖管理</a></li>
<li><a href="#org00eabd8">1.6. ClojureScript：JS</a></li>
</ul>
</li>
<li><a href="#orge72f8ad">2. Clojure参考</a>
<ul>
<li><a href="#org6c9605c">2.1. 基本的程序</a>
<ul>
<li><a href="#org9170367">2.1.1. 特殊形式</a></li>
<li><a href="#org27abd57">2.1.2. 文档与注释</a></li>
<li><a href="#org3676c5f">2.1.3. 基本数据类型</a></li>
<li><a href="#org97abf2e">2.1.4. 集合数据类型</a></li>
<li><a href="#org70a4285">2.1.5. 基本控制流程</a></li>
<li><a href="#orga43d56b">2.1.6. 编写简单的宏</a></li>
</ul>
</li>
<li><a href="#org54783c4">2.2. 函数式编程</a>
<ul>
<li><a href="#org7da2421">2.2.1. 宏</a></li>
<li><a href="#orgd588d62">2.2.2. 高阶函数与函数式算法基本思想</a></li>
<li><a href="#org8c31f30">2.2.3. 列表及其算法</a></li>
<li><a href="#org0948351">2.2.4. 数据结构</a></li>
<li><a href="#org8e0cf65">2.2.5. 瞬态数据结构</a></li>
</ul>
</li>
<li><a href="#org2551759">2.3. 提高抽象度</a>
<ul>
<li><a href="#orgc11b5c1">2.3.1. 协议</a></li>
<li><a href="#org1e5f42a">2.3.2. 数据类型</a></li>
<li><a href="#org625ed27">2.3.3. 记录类型</a></li>
<li><a href="#org7a1c412">2.3.4. 多重方法和层级：运行时多态的方法</a></li>
<li><a href="#org7d7c906">2.3.5. 函数转换器</a></li>
<li><a href="#orgdc5a30d">2.3.6. 并发</a></li>
<li><a href="#org5748d9b">2.3.7. 原子类型</a></li>
<li><a href="#orgdad9f3f">2.3.8. 引用与事务</a></li>
<li><a href="#org7a8cb84">2.3.9. 代理与异步</a></li>
</ul>
</li>
<li><a href="#org03b5422">2.4. 组织一个项目</a>
<ul>
<li><a href="#org9a5a2cc">2.4.1. 命名空间</a></li>
<li><a href="#org2789997">2.4.2. 库</a></li>
<li><a href="#orga97c835">2.4.3. 变量与环境</a></li>
</ul>
</li>
<li><a href="#org7aa5e4b">2.5. 真实的程序总要用到的东西</a>
<ul>
<li><a href="#org927a360">2.5.1. I/O</a></li>
<li><a href="#org0620db6">2.5.2. Java互操作</a></li>
<li><a href="#org0dbda5d">2.5.3. 正则表达式</a></li>
<li><a href="#org1e1a678">2.5.4. 元数据</a></li>
<li><a href="#org9e329ac">2.5.5. 测试</a></li>
<li><a href="#org42b7e38">2.5.6. 依赖与命令行工具</a></li>
<li><a href="#org75f15d8">2.5.7. Spec</a></li>
<li><a href="#org8b4238d">2.5.8. Zippers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org71fd23a">3. Clojure算法笔记</a></li>
<li><a href="#org8314757">4. Leiningen使用</a>
<ul>
<li><a href="#orgc225174">4.1. 安装</a></li>
<li><a href="#org67baac1">4.2. </a></li>
</ul>
</li>
<li><a href="#org9a7c7c2">5. spec</a>
<ul>
<li><a href="#orgafca6f1">5.1. 安装与应用</a></li>
<li><a href="#org716a0f1">5.2. 基本使用</a>
<ul>
<li><a href="#org5b78325">5.2.1. 定义规范</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>





<div id="outline-container-org22eef14" class="outline-2">
<h2 id="org22eef14"><span class="section-number-2">1</span> Clojure学习笔记</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org848d015" class="outline-3">
<h3 id="org848d015"><span class="section-number-3">1.1</span> 基本语法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<a href="https://clojure.org/api/cheatsheet">https://clojure.org/api/cheatsheet</a>
</p>
</div>
<div id="outline-container-orge2a041a" class="outline-4">
<h4 id="orge2a041a"><span class="section-number-4">1.1.1</span> 基本要素</h4>
<div class="outline-text-4" id="text-1-1-1">
</div>
<ol class="org-ol">
<li><a id="org3462fbf"></a>字面量<br />
<div class="outline-text-5" id="text-1-1-1-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">表示</td>
<td class="org-left">含义</td>
</tr>

<tr>
<td class="org-left">数字类型</td>
<td class="org-left">Numeric types</td>
</tr>

<tr>
<td class="org-left">=42              =</td>
<td class="org-left">Long - 64-bit integer (from -2<sup>63</sup> to 2<sup>63</sup>-1)</td>
</tr>

<tr>
<td class="org-left">=6.022e23        =</td>
<td class="org-left">Double - double-precision 64-bit floating point</td>
</tr>

<tr>
<td class="org-left">=42N             =</td>
<td class="org-left">BigInt - arbitrary precision integer</td>
</tr>

<tr>
<td class="org-left">=1.0M            =</td>
<td class="org-left">BigDecimal - arbitrary precision fixed-point decimal</td>
</tr>

<tr>
<td class="org-left">=22/7            =</td>
<td class="org-left">Ratio</td>
</tr>

<tr>
<td class="org-left">字符类型</td>
<td class="org-left">Character types</td>
</tr>

<tr>
<td class="org-left">="hello"         =</td>
<td class="org-left">String</td>
</tr>

<tr>
<td class="org-left">=\e              =</td>
<td class="org-left">Character</td>
</tr>

<tr>
<td class="org-left">其他</td>
<td class="org-left">Other types</td>
</tr>

<tr>
<td class="org-left">=nil             =</td>
<td class="org-left">null value</td>
</tr>

<tr>
<td class="org-left">=true            =</td>
<td class="org-left">Boolean (also, false)</td>
</tr>

<tr>
<td class="org-left">=="[0-9]+"       =</td>
<td class="org-left">Regular expression=</td>
</tr>

<tr>
<td class="org-left">=:alpha          =</td>
<td class="org-left">Keyword</td>
</tr>

<tr>
<td class="org-left">=:release/alpha  =</td>
<td class="org-left">Keyword with namespace</td>
</tr>

<tr>
<td class="org-left">=map             =</td>
<td class="org-left">Symbol</td>
</tr>

<tr>
<td class="org-left">=+               =</td>
<td class="org-left">Symbol - most punctuation allowed</td>
</tr>

<tr>
<td class="org-left">=clojure.core/+  =</td>
<td class="org-left">Namespaced symbol</td>
</tr>

<tr>
<td class="org-left">集合类型</td>
<td class="org-left">collection types</td>
</tr>

<tr>
<td class="org-left">='(1 2 3)     =</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">=[1 2 3]      =</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">=={1 2 3}     =</td>
<td class="org-left">set=</td>
</tr>

<tr>
<td class="org-left">={:a 1, :b 2} =</td>
<td class="org-left">map</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org9e77bd9"></a>求值过程<br />
<div class="outline-text-5" id="text-1-1-1-2">
<ol class="org-ol">
<li>求值过程为Lisp通用过程</li>
<li>使用单引号阻止求值 ='x or '(1 2 3)</li>
</ol>
</div>
</li>

<li><a id="orgaba381e"></a>REPL<br />
<div class="outline-text-5" id="text-1-1-1-3">
<ol class="org-ol">
<li>Clojure总是将函数转换为字节码，而不是解释执行</li>
<li>使用星号引用之前的结果  =*1, *2, *3</li>
</ol>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数及调用方式</td>
<td class="org-left">功能</td>
</tr>

<tr>
<td class="org-left"><code>(require '[clojure.repl :refer :all])</code></td>
<td class="org-left">导入库中所有符号</td>
</tr>

<tr>
<td class="org-left"><code>(doc +)</code></td>
<td class="org-left">显示函数文档</td>
</tr>

<tr>
<td class="org-left"><code>(apropos "+")</code></td>
<td class="org-left">模糊查询函数</td>
</tr>

<tr>
<td class="org-left"><code>(find-doc "trim")</code></td>
<td class="org-left">模糊查询函数文档</td>
</tr>

<tr>
<td class="org-left"><code>(dir clojure.repl)</code></td>
<td class="org-left">显示全部函数</td>
</tr>

<tr>
<td class="org-left"><code>(source dir)</code></td>
<td class="org-left">显示源代码</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="orgc8936a5"></a>def 定义新的符号绑定<br />
<div class="outline-text-5" id="text-1-1-1-4">
<p>
(def x 7)
</p>
</div>
</li>
<li><a id="orge56cbca"></a>打印输出<br />
<div class="outline-text-5" id="text-1-1-1-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">换行</td>
<td class="org-left">人类</td>
<td class="org-left">机器</td>
</tr>

<tr>
<td class="org-left">换行</td>
<td class="org-left">=println =</td>
<td class="org-left">= prn=</td>
</tr>

<tr>
<td class="org-left">不换行</td>
<td class="org-left">=print =</td>
<td class="org-left">= pr=</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgde44934" class="outline-4">
<h4 id="orgde44934"><span class="section-number-4">1.1.2</span> 函数</h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
<ol class="org-ol">
<li><a id="org540e737"></a>创建函数<br />
<ol class="org-ol">
<li><a id="org0c1191d"></a>创建普通函数<br />
<div class="outline-text-6" id="text-1-1-2-1-1">
<div class="org-src-container">
<pre class="src src-clojure">;;    name   params         body
;;    -----  ------  -------------------
(defn greet  [name]  (str "Hello, " name) )
</pre>
</div>
</div>
</li>

<li><a id="orgcc331e3"></a>创建多元函数（不同输入对应不同输出）<br />
<div class="outline-text-6" id="text-1-1-2-1-2">
<p>
Each arity is a list ([args*] body*)
</p>
<div class="org-src-container">
<pre class="src src-clojure">(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
</pre>
</div>
</div>
</li>

<li><a id="orgc02a1b5"></a>创建不定元函数（参数个数不定）<br />
<div class="outline-text-6" id="text-1-1-2-1-3">
<div class="org-src-container">
<pre class="src src-clojure">(defn hello [greeting &amp; who]
  (println greeting who))
</pre>
</div>
</div>
</li>

<li><a id="org9949f55"></a>创建匿名函数<br />
<div class="outline-text-6" id="text-1-1-2-1-4">
<div class="org-src-container">
<pre class="src src-clojure">;;    params         body
;;   ---------  -----------------
(fn  [message]  (println message) )
</pre>
</div>
</div>
</li>

<li><a id="org0192482"></a>defn、def、fn之间的关系<br />
<div class="outline-text-6" id="text-1-1-2-1-5">
<p>
defn是(def (fn))的语法糖
</p>
</div>
</li>

<li><a id="orgeeec96a"></a>语法匿名函数，匿名函数的语法糖<br />
<div class="outline-text-6" id="text-1-1-2-1-6">
<ol class="org-ol">
<li><code>%</code>  表示单个参数</li>
<li><code>%1, %2, %3</code>  表示第几个参数</li>
<li><code>%&amp;</code>  表示剩余参数</li>
<li><code>=()</code>  表示匿名函数</li>
</ol>

<div class="org-src-container">
<pre class="src src-clojure"> (+ 6 %)
(fn [x] (+ 6 x))
 (println %1 %2 %&amp;)
(fn [x y &amp; z] (println x y z))
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="org5962875"></a>应用函数 Apply<br />
<div class="outline-text-5" id="text-1-1-2-2">
<ol class="org-ol">
<li>Apply函数将第一个参数作为函数，将其余全部参数作为函数的参数，执行这个函数</li>
<li>同时，那些其余参数如果是列表的话，将会解开，将每个元素都作为参数，依次排列下去</li>
</ol>


<div class="org-src-container">
<pre class="src src-clojure">(apply f 1 '(2 3 4))
(f 1 2 3 4)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orge2af345" class="outline-4">
<h4 id="orge2af345"><span class="section-number-4">1.1.3</span> 局部和闭包</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<ol class="org-ol">
<li><a id="org946baa5"></a>let<br />
<div class="outline-text-5" id="text-1-1-3-1">
<p>
let会创造一个词汇语义范围，在范围内将值与符号绑定，类似局部变量
</p>
<div class="org-src-container">
<pre class="src src-clojure">;;      bindings     name is defined here
;;    ------------  ----------------------
(let  [name value]  (code that uses name))
(let [x 1
      y 2]
  (+ x y))
</pre>
</div>
</div>
</li>

<li><a id="org4008a9e"></a>闭包<br />
<div class="outline-text-5" id="text-1-1-3-2">
<ol class="org-ol">
<li>fn函数所形成的叫做闭包</li>
<li>闭包包括了周围的语义范围，参数和函数等</li>
<li>所以在这个闭包内并不能修改全局变量</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org04c4abb" class="outline-4">
<h4 id="org04c4abb"><span class="section-number-4">1.1.4</span> Java 互操作</h4>
<div class="outline-text-4" id="text-1-1-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Task</td>
<td class="org-left">Java</td>
<td class="org-left">Clojure</td>
</tr>

<tr>
<td class="org-left">Instantiation</td>
<td class="org-left">=new Widget("foo") =</td>
<td class="org-left">= (Widget. "foo")=</td>
</tr>

<tr>
<td class="org-left">Instance method</td>
<td class="org-left">=rnd.next()        =</td>
<td class="org-left">= (.nextInt rnd)=</td>
</tr>

<tr>
<td class="org-left">Instance field</td>
<td class="org-left">=object.field      =</td>
<td class="org-left">= (.-field object)=</td>
</tr>

<tr>
<td class="org-left">Static method</td>
<td class="org-left">=Math.sqrt(25)     =</td>
<td class="org-left">= (Math/sqrt 25)=</td>
</tr>

<tr>
<td class="org-left">Static field</td>
<td class="org-left">=Math.PI           =</td>
<td class="org-left">= Math/PI=</td>
</tr>
</tbody>
</table>

<p>
将java方法转换为函数
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; make a function to invoke .length on arg
(fn [obj] (.length obj))

;; same thing
 (.length %)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2a16b7" class="outline-4">
<h4 id="orgb2a16b7"><span class="section-number-4">1.1.5</span> 顺序集合</h4>
<div class="outline-text-4" id="text-1-1-5">
</div>
<ol class="org-ol">
<li><a id="org67464f4"></a>Vectors[1 2 3]<br />
<div class="outline-text-5" id="text-1-1-5-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">按序号获取元素</td>
<td class="org-left">=(get ["abc" false 99] 0) =</td>
<td class="org-left">= "abc"=</td>
</tr>

<tr>
<td class="org-left">计数</td>
<td class="org-left">=(count [1 2 3])          =</td>
<td class="org-left">= 3=</td>
</tr>

<tr>
<td class="org-left">从元素构造</td>
<td class="org-left">=(vector 1 2 3)           =</td>
<td class="org-left">= [1 2 3]=</td>
</tr>

<tr>
<td class="org-left">追加元素</td>
<td class="org-left">=(conj [1 2 3] 4 5 6)     =</td>
<td class="org-left">= [1 2 3 4 5 6]=</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="orgc44b418"></a>Lists '(1 2 3)<br />
<div class="outline-text-5" id="text-1-1-5-2">
<p>
不能用序号取值
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">创建list</td>
<td class="org-left"><code>(def cards '(10 :ace :jack 9))</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">第一个元素</td>
<td class="org-left">=(first cards)                  =</td>
<td class="org-left">= 10=</td>
</tr>

<tr>
<td class="org-left">其余列表</td>
<td class="org-left">=(rest cards)                   =</td>
<td class="org-left">= '(:ace :jack 9)=</td>
</tr>

<tr>
<td class="org-left">追加元素</td>
<td class="org-left">=(conj cards :queen)            =</td>
<td class="org-left">= (:queen 10 :ace :jack 9)=</td>
</tr>

<tr>
<td class="org-left">可以作为栈使用</td>
<td class="org-left">=(def stack '(:a :b))           =</td>
<td class="org-left">= <code>'user/stack</code></td>
</tr>

<tr>
<td class="org-left">栈顶的值</td>
<td class="org-left">=(peek stack)                   =</td>
<td class="org-left">= :a=</td>
</tr>

<tr>
<td class="org-left">出栈</td>
<td class="org-left">=(pop stack)                    =</td>
<td class="org-left">= (:b)=</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-org5d03df3" class="outline-4">
<h4 id="org5d03df3"><span class="section-number-4">1.1.6</span> 哈希集合</h4>
<div class="outline-text-4" id="text-1-1-6">
</div>
<ol class="org-ol">
<li><a id="orgac77917"></a>sets ={"a", "b". "c"}<br />
<div class="outline-text-5" id="text-1-1-6-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">定义set</td>
<td class="org-left"><code>(def players ={"Alice", "Bob", "Kelly"})</code></td>
</tr>

<tr>
<td class="org-left">追加元素</td>
<td class="org-left">= (conj players "Fred") =</td>
<td class="org-left">= <code>{"Alice" "Fred" "Bob" "Kelly"}</code></td>
</tr>

<tr>
<td class="org-left">删除元素</td>
<td class="org-left">=(disj players "Bob" "Sal")  =</td>
<td class="org-left">= <code>{"Alice" "Kelly"}</code></td>
</tr>

<tr>
<td class="org-left">判断元素是否在内</td>
<td class="org-left">=(contains? players "Kelly")  =</td>
<td class="org-left">= true=</td>
</tr>

<tr>
<td class="org-left">排序元素</td>
<td class="org-left">=(conj (sorted-set) "Bravo" "Charlie" "Sigma" "Alpha")  =</td>
<td class="org-left">= <code>{"Alpha" "Bravo"  "Charlie" "Sigma"}</code></td>
</tr>

<tr>
<td class="org-left">将另一个集合的元素放进去</td>
<td class="org-left">=(into players ["Tim" "Sue" "Greg"]) =</td>
<td class="org-left">= <code>{"Alice" "Greg" "Sue" "Bob" "Tim" "Kelly"}</code></td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org61cf25f"></a>maps {"name" 1}<br />
<div class="outline-text-5" id="text-1-1-6-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">定义map</td>
<td class="org-left"><code>(def scores {"Fred" 1400, "Bob" 1240, "Angela" 1024})</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">添加键值对</td>
<td class="org-left">=(assoc scores "Sally" 0) =</td>
<td class="org-left">= {"Angela" 1024, "Bob" 1240, "Fred" 1400, "Sally" 0}=</td>
</tr>

<tr>
<td class="org-left">删除键值</td>
<td class="org-left">=(dissoc scores "Bob") =</td>
<td class="org-left">= {"Angela" 1024, "Fred" 1400}=</td>
</tr>

<tr>
<td class="org-left">获取键值</td>
<td class="org-left">=(get scores "Angela") =</td>
<td class="org-left">= 1024=</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">=(directions :north) =</td>
<td class="org-left">= 0=</td>
</tr>

<tr>
<td class="org-left">获取键值时在最后加一项作为默认返回值</td>
<td class="org-left">=(get scores "Sam" 0) =</td>
<td class="org-left">= 0=</td>
</tr>

<tr>
<td class="org-left">判断键名是否存在</td>
<td class="org-left">=(contains? scores "Fred") =</td>
<td class="org-left">= true=</td>
</tr>

<tr>
<td class="org-left">寻找键值对</td>
<td class="org-left">=(find scores "Fred") =</td>
<td class="org-left">= ["Fred" 1400]=</td>
</tr>

<tr>
<td class="org-left">获取键名list</td>
<td class="org-left">=(keys scores) =</td>
<td class="org-left">= ("Fred" "Bob" "Angela")=</td>
</tr>

<tr>
<td class="org-left">获取值list</td>
<td class="org-left">=(vals scores) =</td>
<td class="org-left">= (1400 1240 1024)=</td>
</tr>

<tr>
<td class="org-left">由set作为键名生成map</td>
<td class="org-left">=(zipmap ={"Alice" "Bob" "Kelly"} (repeat 0)) =</td>
<td class="org-left">= {"Kelly" 0, "Bob" 0, "Alice" 0}=</td>
</tr>

<tr>
<td class="org-left">将两个map合并为一个</td>
<td class="org-left">=(merge scores new-scores) =</td>
<td class="org-left">= {"Fred" 1400, "Bob" 1240, "Jeff" 900, "Angela" 300}=</td>
</tr>

<tr>
<td class="org-left">合并map相同值并应用函数</td>
<td class="org-left">=(merge-with + scores{"Fred" 550 "Angela" 900 "Sam" 1000}) =</td>
<td class="org-left">= {"Sam" 1000, "Fred" 1950, "Bob" 1240, "Angela" 1924}=</td>
</tr>

<tr>
<td class="org-left">定义有序map</td>
<td class="org-left">=(def sm (sorted-map "Bravo" 204 "Alfa" 35  "Sigma" 99  "Charlie" 100)) =</td>
<td class="org-left">= {"Alfa" 35, "Bravo" 204, "Charlie" 100, "Sigma" 99}=</td>
</tr>

<tr>
<td class="org-left">有序map的键名列表是有序的</td>
<td class="org-left">=(keys sm) =</td>
<td class="org-left">= ("Alfa" "Bravo" "Charlie" "Sigma")=</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">=(vals sm) =</td>
<td class="org-left">= (35 204 100 99)=</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org60023a9"></a>域信息<br />
<div class="outline-text-5" id="text-1-1-6-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">使用关键字定义map</td>
<td class="org-left"><code>(def person  {:first-name "Kelly"   :last-name "Keen"   :age 32   :occupation "Programmer"})</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">获取关键字</td>
<td class="org-left">=(get person :occupation) =</td>
<td class="org-left">= "Programmer"=</td>
</tr>

<tr>
<td class="org-left">可以省略get</td>
<td class="org-left">=(person :occupation) =</td>
<td class="org-left">= "Programmer"=</td>
</tr>

<tr>
<td class="org-left">也可以调过来</td>
<td class="org-left">=(:occupation person) =</td>
<td class="org-left">= "Programmer"=</td>
</tr>

<tr>
<td class="org-left">最后一个参数可以是缺省值</td>
<td class="org-left">=(:favorite-color person "beige") =</td>
<td class="org-left">= "beige"=</td>
</tr>

<tr>
<td class="org-left">可以改变值</td>
<td class="org-left">=(assoc person :occupation "Baker") =</td>
<td class="org-left">= {:age 32, :last-name "Keen", :first-name "Kelly", :occupation "Baker"}=</td>
</tr>

<tr>
<td class="org-left">可以删除值</td>
<td class="org-left">=(dissoc person :age) =</td>
<td class="org-left">= {:last-name "Keen", :first-name "Kelly", :occupation "Programmer"}=</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">==</td>
</tr>

<tr>
<td class="org-left">定义嵌套的map</td>
<td class="org-left"><code>(def company  {:name "WidgetCo"   :address {:street "123 Main St"             :city "Springfield"             :state "IL"}})</code></td>
</tr>

<tr>
<td class="org-left">可以嵌套获取值</td>
<td class="org-left">= (get-in company [:address :city]) =</td>
<td class="org-left">= "Springfield"=</td>
</tr>

<tr>
<td class="org-left">可以嵌套修改值</td>
<td class="org-left">=(assoc-in company [:address :street] "303 Broadway") =</td>
<td class="org-left">= {:name "WidgetCo", :address {:state "IL",  :city "Springfield",  :street "303 Broadway"}}=</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org4ce4c0e"></a>记录Record<br />
<div class="outline-text-5" id="text-1-1-6-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">功能</td>
<td class="org-left">函数</td>
<td class="org-left">返回值</td>
</tr>

<tr>
<td class="org-left">首先定义记录结构</td>
<td class="org-left"><code>(defrecord Person [first-name last-name age occupation])</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">再实例化一个记录</td>
<td class="org-left"><code>(def kelly (-&gt;Person "Kelly" "Keen" 32 "Programmer"))</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">或者使用map生成记录</td>
<td class="org-left"><code>(def kelly (map-&gt;Person  {:first-name "Kelly"  :last-name "Keen"    :age 32  :occupation "Programmer"}))</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">记录的引用和map相同</td>
<td class="org-left">=(:occupation kelly) =</td>
<td class="org-left">= "Programmer"=</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb128ea5" class="outline-4">
<h4 id="orgb128ea5"><span class="section-number-4">1.1.7</span> 流程控制</h4>
<div class="outline-text-4" id="text-1-1-7">
</div>
<ol class="org-ol">
<li><a id="orgdae80c9"></a>if<br />
<div class="outline-text-5" id="text-1-1-7-1">
<div class="org-src-container">
<pre class="src src-clojure">(if (true? false) "impossible!")
(if (even? 2) "even" "odd")
</pre>
</div>
<p>
只有  <code>false nil</code> 是假的
</p>
</div>
</li>
<li><a id="org28b6ba3"></a>do<br />
<div class="outline-text-5" id="text-1-1-7-2">
<div class="org-src-container">
<pre class="src src-clojure"> (do (println "even")
      true)
</pre>
</div>
</div>
</li>
<li><a id="orgd3df6bd"></a>when<br />
<div class="outline-text-5" id="text-1-1-7-3">
<div class="org-src-container">
<pre class="src src-clojure">(when (neg? x)
  (throw (RuntimeException. (str "x must be positive: " x))))
</pre>
</div>
<p>
when 没有else路径
</p>
</div>
</li>
<li><a id="orgea75749"></a>cond<br />
<div class="outline-text-5" id="text-1-1-7-4">
<p>
对每个路径都进行判断
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [x 11]
  (cond
    (&lt; x 2)  "x is less than 2"
    (&lt; x 10) "x is less than 10"
    :else  "x is greater than or equal to 10"))
</pre>
</div>
</div>
</li>
<li><a id="org310afb0"></a>case<br />
<div class="outline-text-5" id="text-1-1-7-5">
<div class="org-src-container">
<pre class="src src-clojure">(defn foo [x]
         (case x
           5 "x is 5"
           10 "x is 10"
           "x isn't 5 or 10"))
</pre>
</div>
</div>
</li>
<li><a id="org6dd5d5f"></a>有副作用的迭代<br />
<ol class="org-ol">
<li><a id="org597f28f"></a>dotimes<br />
<div class="outline-text-6" id="text-1-1-7-6-1">
<div class="org-src-container">
<pre class="src src-clojure">(dotimes [i 3]
         (println i))
0
1
2
nil
</pre>
</div>
</div>
</li>
<li><a id="org4125a13"></a>doseq<br />
<div class="outline-text-6" id="text-1-1-7-6-2">
<div class="org-src-container">
<pre class="src src-clojure">(doseq [n (range 3)]
         (println n))
(doseq [letter [:a :b]
               number (range 3)] ; list of 0, 1, 2
         (prn [letter number]))
[:a 0]
[:a 1]
[:a 2]
[:b 0]
[:b 1]
[:b 2]
nil
</pre>
</div>
</div>
</li>
</ol>
</li>
<li><a id="org9e82c30"></a>for<br />
<div class="outline-text-5" id="text-1-1-7-7">
<p>
for并不是循环而是几个列表遍历组装新列表
</p>
<div class="org-src-container">
<pre class="src src-clojure">(for [letter [:a :b]
             number (range 3)] ; list of 0, 1, 2
         [letter number])
([:a 0] [:a 1] [:a 2] [:b 0] [:b 1] [:b 2])
</pre>
</div>
</div>
</li>
<li><a id="orgeb5f7b0"></a>递归<br />
<div class="outline-text-5" id="text-1-1-7-8">
<p>
必须使用尾递归而且显式声明
</p>
<div class="org-src-container">
<pre class="src src-clojure">(loop [i 0]
  (if (&lt; i 10)
    (recur (inc i))
    i))
(defn increase [i]
  (if (&lt; i 10)
    (recur (inc i))
    i))
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org5935f1e" class="outline-4">
<h4 id="org5935f1e"><span class="section-number-4">1.1.8</span> 异常</h4>
<div class="outline-text-4" id="text-1-1-8">
</div>
<ol class="org-ol">
<li><a id="orgad321b2"></a>try-catch捕获异常<br />
<div class="outline-text-5" id="text-1-1-8-1">
<div class="org-src-container">
<pre class="src src-clojure">(try
  (/ 2 1)
  (catch ArithmeticException e
    "divide by zero")
  (finally
    (println "cleanup")))
</pre>
</div>
</div>
</li>

<li><a id="org9243e00"></a>try-throw抛出异常<br />
<div class="outline-text-5" id="text-1-1-8-2">
<div class="org-src-container">
<pre class="src src-clojure">(try
  (throw (Exception. "something went wrong"))
  (catch Exception e (.getMessage e)))
</pre>
</div>
</div>
</li>
<li><a id="org5bccaa3"></a>ex-info 将异常信息作为map<br />
<div class="outline-text-5" id="text-1-1-8-3">
<ol class="org-ol">
<li>ex-info takes a message and a map</li>
<li>ex-data gets the map back out</li>
<li>Or nil if not created with ex-info</li>
</ol>

<div class="org-src-container">
<pre class="src src-clojure">(try
  (throw (ex-info "There was a problem" {:detail 42}))
  (catch Exception e
    (prn (:detail (ex-data e)))))
</pre>
</div>
</div>
</li>
<li><a id="org24e0741"></a>with-open 写法<br />
<div class="outline-text-5" id="text-1-1-8-4">
<div class="org-src-container">
<pre class="src src-clojure">(let [f (clojure.java.io/writer "/tmp/new")]
  (try
    (.write f "some text")
    (finally
      (.close f))))

;; Can be written:
(with-open [f (clojure.java.io/writer "/tmp/new")]
  (.write f "some text"))
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb339a08" class="outline-4">
<h4 id="orgb339a08"><span class="section-number-4">1.1.9</span> 宏</h4>
<div class="outline-text-4" id="text-1-1-9">
</div>
<ol class="org-ol">
<li><a id="orga1d3210"></a>宏的定义<br />
<div class="outline-text-5" id="text-1-1-9-1">
<div class="org-src-container">
<pre class="src src-clojure">(defmacro name doc-string? attr-map? ([params*] body) + attr-map?)
(definline name &amp; decl)
</pre>
</div>
</div>
</li>
<li><a id="org8592ea4"></a>展开宏<br />
<div class="outline-text-5" id="text-1-1-9-2">
<div class="org-src-container">
<pre class="src src-clojure">(macroexpand form)
(macroexpand-1 form)
</pre>
</div>
</div>
</li>
<li><a id="org81f3456"></a>常用宏<br />
<ol class="org-ol">
<li><a id="orgc24fb5d"></a>..<br />
<div class="outline-text-6" id="text-1-1-9-3-1">
<div class="org-src-container">
<pre class="src src-clojure">(.. x form &amp; more)
(.. System (getProperties) (get "os.name"))
expands to:
(. (. System (getProperties)) (get "os.name"))
</pre>
</div>
</div>
</li>
<li><a id="orgf22cf4f"></a>doto<br />
<div class="outline-text-6" id="text-1-1-9-3-2">
<div class="org-src-container">
<pre class="src src-clojure">(doto x &amp; forms)
(doto (new java.util.HashMap) (.put "a" 1) (.put "b" 2))
</pre>
</div>
</div>
</li>

<li><a id="org3a1356b"></a>-&gt;<br />
<div class="outline-text-6" id="text-1-1-9-3-3">
<div class="org-src-container">
<pre class="src src-clojure">(-&gt; x &amp; forms)
</pre>
</div>
</div>
</li>

<li><a id="org06756e7"></a>-&gt;&gt;<br />
<div class="outline-text-6" id="text-1-1-9-3-4">
<div class="org-src-container">
<pre class="src src-clojure">(-&gt;&gt; x &amp; forms)
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org48f7fc2" class="outline-4">
<h4 id="org48f7fc2"><span class="section-number-4">1.1.10</span> 常用的函数和宏</h4>
<div class="outline-text-4" id="text-1-1-10">
</div>
<ol class="org-ol">
<li><a id="org0f15329"></a>构造函数的函数<br />
<div class="outline-text-5" id="text-1-1-10-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-left">例子</td>
<td class="org-left">返回值</td>
<td class="org-left">功能</td>
</tr>

<tr>
<td class="org-left">partial</td>
<td class="org-left">=(map (partial + 2) [1 2 3]) =</td>
<td class="org-left">= (3 4 5)=</td>
<td class="org-left">偏函数，实现固定函数的部分值</td>
</tr>

<tr>
<td class="org-left">comp</td>
<td class="org-left">=(map (comp - *) [2 4 6] [1 2 3]) =</td>
<td class="org-left">= (-2 -8 -18)=</td>
<td class="org-left">组合函数，对同一组参数连续应用函数</td>
</tr>

<tr>
<td class="org-left">complement</td>
<td class="org-left">=(map (complement zero?) [3 2 1 0]) =</td>
<td class="org-left">= (true true true false)=</td>
<td class="org-left">返回具有同样参数的函数</td>
</tr>

<tr>
<td class="org-left">constantly</td>
<td class="org-left">=(map (constantly 9) [1 2 3]) =</td>
<td class="org-left">= (9 9 9)=</td>
<td class="org-left">常函数</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="orgb75a1c0"></a>正则表达式<br />
<div class="outline-text-5" id="text-1-1-10-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-left">例子</td>
<td class="org-left">返回值</td>
<td class="org-left">功能</td>
</tr>

<tr>
<td class="org-left">=re-find =</td>
<td class="org-left"><code>(re-find ="([-+]?[0-9]+)/([0-9]+)" "22/7")</code></td>
<td class="org-left">= ["22/7" "22" "7"]=</td>
<td class="org-left">返回正则查询的结果列表</td>
</tr>

<tr>
<td class="org-left">=re-seq =</td>
<td class="org-left"><code>(re-seq ="[0-9]+" "abs123def345ghi567")</code></td>
<td class="org-left">= ("123" "345" "567")=</td>
<td class="org-left">返回惰性查询列表</td>
</tr>

<tr>
<td class="org-left">=re-matches =</td>
<td class="org-left"><code>(re-matches ="([-+]?[0-9]+)/([0-9]+)" "22/7")</code></td>
<td class="org-left">= ["22/7" "22" "7"]=</td>
<td class="org-left">返回查找的最近组</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org80fa7de" class="outline-3">
<h3 id="org80fa7de"><span class="section-number-3">1.2</span> 高级语法</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org9f7ca71" class="outline-4">
<h4 id="org9f7ca71"><span class="section-number-4">1.2.1</span> 自定义数据类型 Datatypes</h4>
</div>
<div id="outline-container-org217aa7b" class="outline-4">
<h4 id="org217aa7b"><span class="section-number-4">1.2.2</span> Sequences 算法系列</h4>
</div>
<div id="outline-container-orgbe1022e" class="outline-4">
<h4 id="orgbe1022e"><span class="section-number-4">1.2.3</span> 临时数据结构：用可变数据进行优化</h4>
</div>
<div id="outline-container-org7b4c378" class="outline-4">
<h4 id="org7b4c378"><span class="section-number-4">1.2.4</span> 转换器：将变换算法组合起来</h4>
</div>
<div id="outline-container-org26bc45a" class="outline-4">
<h4 id="org26bc45a"><span class="section-number-4">1.2.5</span> 多重方法和层级：运行时多态的方法</h4>
</div>
<div id="outline-container-orgf8f7042" class="outline-4">
<h4 id="orgf8f7042"><span class="section-number-4">1.2.6</span> 协议：对接口进行抽象</h4>
</div>
<div id="outline-container-org4804578" class="outline-4">
<h4 id="org4804578"><span class="section-number-4">1.2.7</span> 元数据：表达数据类型信息</h4>
</div>
<div id="outline-container-org1f9af8f" class="outline-4">
<h4 id="org1f9af8f"><span class="section-number-4">1.2.8</span> 命名空间与使用库</h4>
</div>
<div id="outline-container-org531cf8a" class="outline-4">
<h4 id="org531cf8a"><span class="section-number-4">1.2.9</span> 改变值</h4>
<div class="outline-text-4" id="text-1-2-9">
</div>
<ol class="org-ol">
<li><a id="org6dc4b6e"></a>var与全局环境<br /></li>
<li><a id="org971e03d"></a>ref与STM：软件事务内存，并发<br /></li>
<li><a id="org3f16500"></a>agent与异步<br /></li>
<li><a id="orge4a0ff2"></a>atom与同步<br /></li>
</ol>
</div>
<div id="outline-container-org6458291" class="outline-4">
<h4 id="org6458291"><span class="section-number-4">1.2.10</span> reducer：从旧态到新态</h4>
</div>
<div id="outline-container-org05b0d93" class="outline-4">
<h4 id="org05b0d93"><span class="section-number-4">1.2.11</span> Java互操作</h4>
</div>
<div id="outline-container-orgfd5311b" class="outline-4">
<h4 id="orgfd5311b"><span class="section-number-4">1.2.12</span> 编译成Class</h4>
</div>
</div>
<div id="outline-container-org6a4e01b" class="outline-3">
<h3 id="org6a4e01b"><span class="section-number-3">1.3</span> 内置库</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgecec189" class="outline-4">
<h4 id="orgecec189"><span class="section-number-4">1.3.1</span> Java工具库</h4>
</div>
<div id="outline-container-org53943bd" class="outline-4">
<h4 id="org53943bd"><span class="section-number-4">1.3.2</span> clojure.reflect:反射信息</h4>
</div>
<div id="outline-container-orgac3eb87" class="outline-4">
<h4 id="orgac3eb87"><span class="section-number-4">1.3.3</span> clojure.repl:REPL有用的工具</h4>
</div>
<div id="outline-container-orgefe6dff" class="outline-4">
<h4 id="orgefe6dff"><span class="section-number-4">1.3.4</span> clojure.set:set相关算法</h4>
</div>
<div id="outline-container-orgfd8f6d4" class="outline-4">
<h4 id="orgfd8f6d4"><span class="section-number-4">1.3.5</span> clojure.string:处理字符串</h4>
</div>
<div id="outline-container-orgbbfc852" class="outline-4">
<h4 id="orgbbfc852"><span class="section-number-4">1.3.6</span> clojure.test:单元测试框架</h4>
</div>
<div id="outline-container-orgb0a8277" class="outline-4">
<h4 id="orgb0a8277"><span class="section-number-4">1.3.7</span> clojure.walk:遍历和操作最近数据结构</h4>
</div>
<div id="outline-container-org44cf905" class="outline-4">
<h4 id="org44cf905"><span class="section-number-4">1.3.8</span> clojure.xml:xml处理</h4>
</div>
<div id="outline-container-org8e387c6" class="outline-4">
<h4 id="org8e387c6"><span class="section-number-4">1.3.9</span> clojure.zip:纯函数的树编辑</h4>
</div>
<div id="outline-container-org3f326b9" class="outline-4">
<h4 id="org3f326b9"><span class="section-number-4">1.3.10</span> 依赖处理与命令行工具</h4>
</div>
</div>

<div id="outline-container-org9d20f52" class="outline-3">
<h3 id="org9d20f52"><span class="section-number-3">1.4</span> 相关项目</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org1a8b247" class="outline-4">
<h4 id="org1a8b247"><span class="section-number-4">1.4.1</span> ring</h4>
</div>
<div id="outline-container-org46fc7ef" class="outline-4">
<h4 id="org46fc7ef"><span class="section-number-4">1.4.2</span> compojure</h4>
</div>
<div id="outline-container-org3d13540" class="outline-4">
<h4 id="org3d13540"><span class="section-number-4">1.4.3</span> enlive</h4>
</div>
<div id="outline-container-orgf3da48f" class="outline-4">
<h4 id="orgf3da48f"><span class="section-number-4">1.4.4</span> hiccup</h4>
</div>
</div>
<div id="outline-container-org8011861" class="outline-3">
<h3 id="org8011861"><span class="section-number-3">1.5</span> leiningen:依赖管理</h3>
</div>
<div id="outline-container-org00eabd8" class="outline-3">
<h3 id="org00eabd8"><span class="section-number-3">1.6</span> ClojureScript：JS</h3>
</div>
</div>

<div id="outline-container-orge72f8ad" class="outline-2">
<h2 id="orge72f8ad"><span class="section-number-2">2</span> Clojure参考</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org6c9605c" class="outline-3">
<h3 id="org6c9605c"><span class="section-number-3">2.1</span> 基本的程序</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org9170367" class="outline-4">
<h4 id="org9170367"><span class="section-number-4">2.1.1</span> 特殊形式</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Clojure的特殊形式指的是不按照常规的求值规则返回值的那些形式,类似于其它语言中的保留关键字.
下面的列表中 <code>*</code> 表示0个及以上, <code>+</code> 表示1个及以上, <code>?</code> 表示可选
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">关键字</th>
<th scope="col" class="org-left">语法</th>
<th scope="col" class="org-left">意义</th>
<th scope="col" class="org-left">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>def</code></td>
<td class="org-left"><code>(def symbol doc-string? init?)</code></td>
<td class="org-left">定义一个全局符号</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>if</code></td>
<td class="org-left"><code>(if test then else?)</code></td>
<td class="org-left">条件判断</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>do</code></td>
<td class="org-left"><code>(do expr*)</code></td>
<td class="org-left">顺序执行</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>let</code></td>
<td class="org-left"><code>(let [ binding* ] expr*)</code></td>
<td class="org-left">局部绑定量到符号</td>
<td class="org-left">中括号内的绑定为从上到下依次求值,因此可以用来做~do~</td>
</tr>

<tr>
<td class="org-left"><code>quote</code></td>
<td class="org-left"><code>(quote form)</code> 或 <code>'(form)</code></td>
<td class="org-left">返回一个不求值的形式</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>var</code></td>
<td class="org-left"><code>(var symbol)</code> 或 <code>#'(symbol)</code></td>
<td class="org-left">返回一个符号的 <code>Var</code> 对象</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>fn</code></td>
<td class="org-left"><code>(fn name? [params* ] expr*)</code> 或 <code>(fn name? ([params* ] expr*)+)</code></td>
<td class="org-left">返回匿名函数</td>
<td class="org-left">当给出多个参数列表-求值过程的形式时为一个多态函数.函数还支持前后判断,在参数列表之后加上 <code>{:pre [pre-expr*] :post [post-expr*]}</code></td>
</tr>

<tr>
<td class="org-left"><code>loop recur</code></td>
<td class="org-left"><code>(loop [binding* ] expr* (recur expr*))</code></td>
<td class="org-left">尾递归形式</td>
<td class="org-left">由于没有被动尾递归优化,必须显式声明展开</td>
</tr>

<tr>
<td class="org-left"><code>throw</code></td>
<td class="org-left"><code>(throw expr)</code></td>
<td class="org-left">抛出异常</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>try</code></td>
<td class="org-left"><code>(try expr* (catch classname name expr*)* (finally expr*)?)</code></td>
<td class="org-left">异常处理</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>.</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>new</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>set!</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org27abd57" class="outline-4">
<h4 id="org27abd57"><span class="section-number-4">2.1.2</span> 文档与注释</h4>
</div>
<div id="outline-container-org3676c5f" class="outline-4">
<h4 id="org3676c5f"><span class="section-number-4">2.1.3</span> 基本数据类型</h4>
</div>
<div id="outline-container-org97abf2e" class="outline-4">
<h4 id="org97abf2e"><span class="section-number-4">2.1.4</span> 集合数据类型</h4>
</div>
<div id="outline-container-org70a4285" class="outline-4">
<h4 id="org70a4285"><span class="section-number-4">2.1.5</span> 基本控制流程</h4>
</div>
<div id="outline-container-orga43d56b" class="outline-4">
<h4 id="orga43d56b"><span class="section-number-4">2.1.6</span> 编写简单的宏</h4>
</div>
</div>
<div id="outline-container-org54783c4" class="outline-3">
<h3 id="org54783c4"><span class="section-number-3">2.2</span> 函数式编程</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org7da2421" class="outline-4">
<h4 id="org7da2421"><span class="section-number-4">2.2.1</span> 宏</h4>
</div>
<div id="outline-container-orgd588d62" class="outline-4">
<h4 id="orgd588d62"><span class="section-number-4">2.2.2</span> 高阶函数与函数式算法基本思想</h4>
</div>
<div id="outline-container-org8c31f30" class="outline-4">
<h4 id="org8c31f30"><span class="section-number-4">2.2.3</span> 列表及其算法</h4>
</div>
<div id="outline-container-org0948351" class="outline-4">
<h4 id="org0948351"><span class="section-number-4">2.2.4</span> 数据结构</h4>
</div>
<div id="outline-container-org8e0cf65" class="outline-4">
<h4 id="org8e0cf65"><span class="section-number-4">2.2.5</span> 瞬态数据结构</h4>
</div>
</div>
<div id="outline-container-org2551759" class="outline-3">
<h3 id="org2551759"><span class="section-number-3">2.3</span> 提高抽象度</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-orgc11b5c1" class="outline-4">
<h4 id="orgc11b5c1"><span class="section-number-4">2.3.1</span> 协议</h4>
</div>
<div id="outline-container-org1e5f42a" class="outline-4">
<h4 id="org1e5f42a"><span class="section-number-4">2.3.2</span> 数据类型</h4>
</div>
<div id="outline-container-org625ed27" class="outline-4">
<h4 id="org625ed27"><span class="section-number-4">2.3.3</span> 记录类型</h4>
</div>
<div id="outline-container-org7a1c412" class="outline-4">
<h4 id="org7a1c412"><span class="section-number-4">2.3.4</span> 多重方法和层级：运行时多态的方法</h4>
</div>
<div id="outline-container-org7d7c906" class="outline-4">
<h4 id="org7d7c906"><span class="section-number-4">2.3.5</span> 函数转换器</h4>
</div>
<div id="outline-container-orgdc5a30d" class="outline-4">
<h4 id="orgdc5a30d"><span class="section-number-4">2.3.6</span> 并发</h4>
</div>
<div id="outline-container-org5748d9b" class="outline-4">
<h4 id="org5748d9b"><span class="section-number-4">2.3.7</span> 原子类型</h4>
</div>
<div id="outline-container-orgdad9f3f" class="outline-4">
<h4 id="orgdad9f3f"><span class="section-number-4">2.3.8</span> 引用与事务</h4>
</div>
<div id="outline-container-org7a8cb84" class="outline-4">
<h4 id="org7a8cb84"><span class="section-number-4">2.3.9</span> 代理与异步</h4>
</div>
</div>
<div id="outline-container-org03b5422" class="outline-3">
<h3 id="org03b5422"><span class="section-number-3">2.4</span> 组织一个项目</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org9a5a2cc" class="outline-4">
<h4 id="org9a5a2cc"><span class="section-number-4">2.4.1</span> 命名空间</h4>
</div>
<div id="outline-container-org2789997" class="outline-4">
<h4 id="org2789997"><span class="section-number-4">2.4.2</span> 库</h4>
</div>
<div id="outline-container-orga97c835" class="outline-4">
<h4 id="orga97c835"><span class="section-number-4">2.4.3</span> 变量与环境</h4>
</div>
</div>
<div id="outline-container-org7aa5e4b" class="outline-3">
<h3 id="org7aa5e4b"><span class="section-number-3">2.5</span> 真实的程序总要用到的东西</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org927a360" class="outline-4">
<h4 id="org927a360"><span class="section-number-4">2.5.1</span> I/O</h4>
</div>
<div id="outline-container-org0620db6" class="outline-4">
<h4 id="org0620db6"><span class="section-number-4">2.5.2</span> Java互操作</h4>
</div>
<div id="outline-container-org0dbda5d" class="outline-4">
<h4 id="org0dbda5d"><span class="section-number-4">2.5.3</span> 正则表达式</h4>
</div>
<div id="outline-container-org1e1a678" class="outline-4">
<h4 id="org1e1a678"><span class="section-number-4">2.5.4</span> 元数据</h4>
</div>
<div id="outline-container-org9e329ac" class="outline-4">
<h4 id="org9e329ac"><span class="section-number-4">2.5.5</span> 测试</h4>
</div>
<div id="outline-container-org42b7e38" class="outline-4">
<h4 id="org42b7e38"><span class="section-number-4">2.5.6</span> 依赖与命令行工具</h4>
</div>
<div id="outline-container-org75f15d8" class="outline-4">
<h4 id="org75f15d8"><span class="section-number-4">2.5.7</span> Spec</h4>
</div>
<div id="outline-container-org8b4238d" class="outline-4">
<h4 id="org8b4238d"><span class="section-number-4">2.5.8</span> Zippers</h4>
</div>
</div>
</div>
<div id="outline-container-org71fd23a" class="outline-2">
<h2 id="org71fd23a"><span class="section-number-2">3</span> Clojure算法笔记</h2>
<div class="outline-text-2" id="text-3">
</div>
<ol class="org-ol">
<li><a id="org4966431"></a>从vec构造map<br />
<div class="outline-text-5" id="text-3-0-0-1">
<div class="org-src-container">
<pre class="src src-clojure">(map #(hash-map (first %1) (first (rest %1)))  ["a" "b" "c" "d"])
</pre>
</div>
</div>
</li>

<li><a id="org8ae24ff"></a>在map中查找与某值最接近的val的key<br />
<div class="outline-text-5" id="text-3-0-0-2">
<p>
先对keys排序,并按大小分成两份,后一份的第一个或者前一份的最后一个就是目标
</p>
<div class="org-src-container">
<pre class="src src-clojure">  (let [map-raw {:a 2 :c 4 :d 1}
        num-target 3
        map-sorted  (into (sorted-map-by &lt;) map-raw)
        this (first (vec  (peek (split-with (partial &gt; num-target)
                                            (keys map-sorted)))))]
    this)

</pre>
</div>
</div>
</li>

<li><a id="org140b309"></a>vec去重复<br />
<div class="outline-text-5" id="text-3-0-0-3">
<p>
先将vec转成set,再转回来,set是没有重复的
</p>
<div class="org-src-container">
<pre class="src src-clojure">(vec (set [1 2 3 4 4 4 ]))
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org8314757" class="outline-2">
<h2 id="org8314757"><span class="section-number-2">4</span> Leiningen使用</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgc225174" class="outline-3">
<h3 id="orgc225174"><span class="section-number-3">4.1</span> 安装</h3>
<div class="outline-text-3" id="text-4-1">
<p>
参照 <a href="https://github.com/technomancy/leiningen/blob/stable/README.md">readme</a> 很容易
</p>
</div>
</div>
<div id="outline-container-org67baac1" class="outline-3">
<h3 id="org67baac1"><span class="section-number-3">4.2</span> </h3>
</div>
</div>
<div id="outline-container-org9a7c7c2" class="outline-2">
<h2 id="org9a7c7c2"><span class="section-number-2">5</span> spec</h2>
<div class="outline-text-2" id="text-5">
<p>
clojure.spec为clojure提供了一个可选的类型系统，用来定义数据结构和类型，并进行校验，可以补足Clojure作为动态类型语言的一些缺陷，特别是在传递参数时。
</p>
</div>
<div id="outline-container-orgafca6f1" class="outline-3">
<h3 id="orgafca6f1"><span class="section-number-3">5.1</span> 安装与应用</h3>
<div class="outline-text-3" id="text-5-1">
<p>
clojure.spec是标准库的一部分，在1.9版本正式引入，所以不需要安装依赖
引用格式为：
</p>
<div class="org-src-container">
<pre class="src src-clojure">(require [clojure.spec.alpha :as s])
</pre>
</div>
</div>
</div>

<div id="outline-container-org716a0f1" class="outline-3">
<h3 id="org716a0f1"><span class="section-number-3">5.2</span> 基本使用</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org5b78325" class="outline-4">
<h4 id="org5b78325"><span class="section-number-4">5.2.1</span> 定义规范</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
使用 <code>s/def</code> 定义一个规范，规范函数接受参数作为输入值并返回一个布尔值, 被定义的符号用 <code>::</code> 表示当前命名空间，为了避免冲突可以用自定义的不真实存在的命名空间 <code>:a/b</code>
</p>
<div class="org-src-container">
<pre class="src src-clojure">(s/def ::even-val even?)

</pre>
</div>
<p>
规范函数可以使用组合条件 <code>s/and</code> 和 <code>s/or</code>
</p>

<div class="org-src-container">
<pre class="src src-clojure">(s/def ::or-test
 (s/or :int-number int?
  :string-number string?))

</pre>
</div>

<p>
在spec中有一些内置的规范函数可以使用
 <code>s/valid?</code> 判断给定数据的是否满足当前的规范
</p>
<div class="org-src-container">
<pre class="src src-clojure">    (s/valid? ::even-val 10)
    ;;=&gt; true
    (s/valid? ::even-val 11)
    ;;=&gt; false

</pre>
</div>

<p>
 <code>s/conform</code> 根据给定的规范和数据进行解析，如果不符合就返回 <code>s/invalid</code>
 <code>s/explain</code> 用来解释匹配失败的原因
对于数组可用的函数有： <code>s/coll-of ~,  ~s/every</code> , <code>s/tuple</code>
对于map可用的函数有： <code>s/map-of ~,  ~s/every-of</code> , <code>s/keys</code>
对于nil的处理： <code>s/nilable</code> 表示可以传入nil
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: chimez</p>
<p class="date">Created: 2020-09-27 Sun 17:23</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
